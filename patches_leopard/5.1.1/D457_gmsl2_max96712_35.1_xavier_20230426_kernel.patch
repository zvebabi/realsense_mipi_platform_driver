diff -urN ori/kernel/kernel-5.10/arch/arm64/configs/defconfig intel/kernel/kernel-5.10/arch/arm64/configs/defconfig
--- ori/kernel/kernel-5.10/arch/arm64/configs/defconfig	2022-08-11 11:15:28.000000000 +0800
+++ intel/kernel/kernel-5.10/arch/arm64/configs/defconfig	2023-04-10 17:16:55.487134439 +0800
@@ -893,6 +893,7 @@
 CONFIG_I2C_IOEXPANDER_SER_MAX9295=y
 CONFIG_I2C_IOEXPANDER_DESER_MAX9296=y
 CONFIG_NV_VIDEO_IMX390=y
+CONFIG_VIDEO_D4XX=m
 CONFIG_NV_DESER_MAX96712=m
 CONFIG_NV_VIDEO_AR0234=m
 CONFIG_NV_VIDEO_HAWK_OWL=m
diff -urN ori/kernel/kernel-5.10/drivers/media/common/videobuf2/videobuf2-core.c intel/kernel/kernel-5.10/drivers/media/common/videobuf2/videobuf2-core.c
--- ori/kernel/kernel-5.10/drivers/media/common/videobuf2/videobuf2-core.c	2022-08-11 11:15:30.000000000 +0800
+++ intel/kernel/kernel-5.10/drivers/media/common/videobuf2/videobuf2-core.c	2023-04-10 17:16:55.487134439 +0800
@@ -1884,7 +1884,7 @@
 
 	switch (vb->state) {
 	case VB2_BUF_STATE_DONE:
-		dprintk(q, 3, "returning done buffer\n");
+		dprintk(q, 3, "returning done buffer type %d\n", vb->type);
 		break;
 	case VB2_BUF_STATE_ERROR:
 		dprintk(q, 3, "returning done buffer with errors\n");
@@ -1922,8 +1922,8 @@
 		media_request_put(vb->request);
 	vb->request = NULL;
 
-	dprintk(q, 2, "dqbuf of buffer %d, state: %s\n",
-		vb->index, vb2_state_name(vb->state));
+	dprintk(q, 2, "dqbuf of buffer %d, state: %s type: %d\n",
+		vb->index, vb2_state_name(vb->state), vb->type);
 
 	return 0;
 
diff -urN ori/kernel/kernel-5.10/drivers/media/common/videobuf2/videobuf2-dma-contig.c intel/kernel/kernel-5.10/drivers/media/common/videobuf2/videobuf2-dma-contig.c
--- ori/kernel/kernel-5.10/drivers/media/common/videobuf2/videobuf2-dma-contig.c	2022-08-11 11:15:30.000000000 +0800
+++ intel/kernel/kernel-5.10/drivers/media/common/videobuf2/videobuf2-dma-contig.c	2023-04-10 17:16:55.487134439 +0800
@@ -139,8 +139,8 @@
 {
 	struct vb2_dc_buf *buf;
 
-	if (WARN_ON(!dev))
-		return ERR_PTR(-EINVAL);
+	// if (WARN_ON(!dev))
+	// 	return ERR_PTR(-EINVAL);
 
 	buf = kzalloc(sizeof *buf, GFP_KERNEL);
 	if (!buf)
diff -urN ori/kernel/kernel-5.10/drivers/media/usb/uvc/Makefile intel/kernel/kernel-5.10/drivers/media/usb/uvc/Makefile
--- ori/kernel/kernel-5.10/drivers/media/usb/uvc/Makefile	2022-08-11 11:15:30.000000000 +0800
+++ intel/kernel/kernel-5.10/drivers/media/usb/uvc/Makefile	2023-04-10 17:16:55.487134439 +0800
@@ -1,4 +1,5 @@
 # SPDX-License-Identifier: GPL-2.0
+CONFIG_MODULE_SIG=n
 uvcvideo-objs  := uvc_driver.o uvc_queue.o uvc_v4l2.o uvc_video.o uvc_ctrl.o \
 		  uvc_status.o uvc_isight.o uvc_debugfs.o uvc_metadata.o
 ifeq ($(CONFIG_MEDIA_CONTROLLER),y)
diff -urN ori/kernel/kernel-5.10/drivers/media/usb/uvc/uvc_ctrl.c intel/kernel/kernel-5.10/drivers/media/usb/uvc/uvc_ctrl.c
--- ori/kernel/kernel-5.10/drivers/media/usb/uvc/uvc_ctrl.c	2022-08-11 11:15:30.000000000 +0800
+++ intel/kernel/kernel-5.10/drivers/media/usb/uvc/uvc_ctrl.c	2023-04-10 17:16:55.487134439 +0800
@@ -353,6 +353,7 @@
 	{ 0, "Disabled" },
 	{ 1, "50 Hz" },
 	{ 2, "60 Hz" },
+	{ 3, "Auto" },
 };
 
 static const struct uvc_menu_info exposure_auto_controls[] = {
diff -urN ori/kernel/kernel-5.10/drivers/media/usb/uvc/uvc_driver.c intel/kernel/kernel-5.10/drivers/media/usb/uvc/uvc_driver.c
--- ori/kernel/kernel-5.10/drivers/media/usb/uvc/uvc_driver.c	2022-08-11 11:15:30.000000000 +0800
+++ intel/kernel/kernel-5.10/drivers/media/usb/uvc/uvc_driver.c	2023-04-10 17:16:55.487134439 +0800
@@ -272,6 +272,109 @@
 		.guid		= UVC_GUID_FORMAT_PAIR,
 		.fcc		= V4L2_PIX_FMT_PAIR,
 	},
+	{
+		.name           = "Raw data 8-bit (RAW8)",
+		.guid           = UVC_GUID_FORMAT_RAW8,
+		.fcc            = V4L2_PIX_FMT_GREY,
+	},
+	{
+		.name           = "Raw data 16-bit (RW16)",
+		.guid           = UVC_GUID_FORMAT_RW16,
+		.fcc            = V4L2_PIX_FMT_RW16,
+	},
+	{
+		.name           = "Depth 16-bit (INVZ)",
+		.guid           = UVC_GUID_FORMAT_INVZ,
+		.fcc            = V4L2_PIX_FMT_Z16,
+	},
+	{
+		.name           = "Depth:IR 16:8 24-bit (INZI)",
+		.guid           = UVC_GUID_FORMAT_INZI,
+		.fcc            = V4L2_PIX_FMT_INZI,
+	},
+	{
+		.name           = "Depth 16-bit (INVR)",
+		.guid           = UVC_GUID_FORMAT_INVR,
+		.fcc            = V4L2_PIX_FMT_INVR,
+	},
+	{
+		.name           = "Depth:IR 16:8 24-bit (INRI)",
+		.guid           = UVC_GUID_FORMAT_INRI,
+		.fcc            = V4L2_PIX_FMT_INRI,
+	},
+	{
+		.name           = "Infrared 8-bit (INVI)",
+		.guid           = UVC_GUID_FORMAT_INVI,
+		.fcc            = V4L2_PIX_FMT_GREY,
+	},
+	{
+		.name           = "FlickerIR 8-bit (RELI)",
+		.guid           = UVC_GUID_FORMAT_RELI,
+		.fcc            = V4L2_PIX_FMT_RELI,
+	},
+	{
+		.name           = "Luminosity data 8-bit (L8)",
+		.guid           = UVC_GUID_FORMAT_L8,
+		.fcc            = V4L2_PIX_FMT_GREY,
+	},
+	{
+		.name           = "Luminosity data 16-bit (L16)",
+		.guid           = UVC_GUID_FORMAT_L16,
+		.fcc            = V4L2_PIX_FMT_Y16,
+	},
+	{
+		.name           = "Depth data 16-bit (D16)",
+		.guid           = UVC_GUID_FORMAT_D16,
+		.fcc            = V4L2_PIX_FMT_Z16,
+	},
+	{
+		.name           = "16-bit Bayer BGBG/GRGR",
+		.guid           = UVC_GUID_FORMAT_BAYER16,
+		.fcc            = V4L2_PIX_FMT_SBGGR16,
+	},
+	{
+		.name           = "Packed raw data 10-bit",
+		.guid           = UVC_GUID_FORMAT_W10,
+		.fcc            = V4L2_PIX_FMT_W10,
+	},
+	{
+		.name           = "Confidence data (C   )",
+		.guid           = UVC_GUID_FORMAT_CONFIDENCE_MAP,
+		.fcc            = V4L2_PIX_FMT_CONFIDENCE_MAP,
+	},
+    /* FishEye 8-bit monochrome */
+    {
+		.name           = "Raw data 8-bit (RAW8)",
+		.guid           = UVC_GUID_FORMAT_RAW8,
+		.fcc            = V4L2_PIX_FMT_GREY,
+    },
+    /* Legacy/Development formats for backward-compatibility*/
+    {
+		.name           = "Raw data 16-bit (RW16)",
+		.guid           = UVC_GUID_FORMAT_RW16,
+		.fcc            = V4L2_PIX_FMT_RW16,
+    },
+    {
+		.name           = "Frame Grabber (FG  )",
+		.guid           = UVC_GUID_FORMAT_FG,
+		.fcc            = V4L2_PIX_FMT_FG,
+    },
+    {
+		.name           = "SR300 Depth/Confidence (INZC)",
+		.guid           = UVC_GUID_FORMAT_INZC,
+		.fcc            = V4L2_PIX_FMT_INZC,
+    },
+    {
+		.name           = "Relative IR (PAIR)",
+		.guid           = UVC_GUID_FORMAT_PAIR,
+		.fcc            = V4L2_PIX_FMT_PAIR,
+    },
+    {
+		.name           = "Z16 Huffman Compression",
+		.guid           = UVC_GUID_FORMAT_Z16H,
+		.fcc            = V4L2_PIX_FMT_Z16H,
+    },
+
 };
 
 /* ------------------------------------------------------------------------
diff -urN ori/kernel/kernel-5.10/drivers/media/usb/uvc/uvcvideo.h intel/kernel/kernel-5.10/drivers/media/usb/uvc/uvcvideo.h
--- ori/kernel/kernel-5.10/drivers/media/usb/uvc/uvcvideo.h	2022-08-11 11:15:30.000000000 +0800
+++ intel/kernel/kernel-5.10/drivers/media/usb/uvc/uvcvideo.h	2023-04-10 17:16:55.487134439 +0800
@@ -151,9 +151,24 @@
 #define UVC_GUID_FORMAT_INZI \
 	{ 'I',  'N',  'Z',  'I', 0x66, 0x1a, 0x42, 0xa2, \
 	 0x90, 0x65, 0xd0, 0x18, 0x14, 0xa8, 0xef, 0x8a}
+#define UVC_GUID_FORMAT_INVR \
+	{ 'I',  'N',  'V',  'R', 0x90, 0x2d, 0x58, 0x4a, \
+	 0x92, 0x0b, 0x77, 0x3f, 0x1f, 0x2c, 0x55, 0x6b}
+#define UVC_GUID_FORMAT_INRI \
+	{ 'I',  'N',  'R',  'I', 0x90, 0x2d, 0x58, 0x4a, \
+	 0x92, 0x0b, 0x77, 0x3f, 0x1f, 0x2c, 0x55, 0x6b}
 #define UVC_GUID_FORMAT_INVI \
 	{ 'I',  'N',  'V',  'I', 0xdb, 0x57, 0x49, 0x5e, \
 	 0x8e, 0x3f, 0xf4, 0x79, 0x53, 0x2b, 0x94, 0x6f}
+#define UVC_GUID_FORMAT_RELI \
+	{ 'R',  'E',  'L',  'I', 0x14, 0x13, 0x43, 0xf9, \
+	 0xa7, 0x5a, 0xee, 0x6b, 0xbf, 0x01, 0x2e, 0x23}
+#define UVC_GUID_FORMAT_L8 \
+	{ '2', 0x00,  0x00,  0x00, 0x00, 0x00, 0x10, 0x00, \
+	 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
+#define UVC_GUID_FORMAT_L16 \
+    { 'Q', 0x00,  0x00,  0x00, 0x00, 0x00, 0x10, 0x00, \
+	 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
 #define UVC_GUID_FORMAT_CNF4 \
 	{ 'C',  ' ',  ' ',  ' ', 0x00, 0x00, 0x10, 0x00, \
 	 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
diff -urN ori/kernel/kernel-5.10/drivers/media/v4l2-core/v4l2-compat-ioctl32.c intel/kernel/kernel-5.10/drivers/media/v4l2-core/v4l2-compat-ioctl32.c
--- ori/kernel/kernel-5.10/drivers/media/v4l2-core/v4l2-compat-ioctl32.c	2022-08-11 11:15:30.000000000 +0800
+++ intel/kernel/kernel-5.10/drivers/media/v4l2-core/v4l2-compat-ioctl32.c	2023-04-10 17:16:55.487134439 +0800
@@ -224,6 +224,20 @@
 	return 0;
 }
 
+static inline int get_v4l2_meta_format(struct v4l2_meta_format *kp, struct v4l2_meta_format __user *up)
+{
+	if (copy_from_user(kp, up, sizeof(struct v4l2_meta_format)))
+		return -EFAULT;
+	return 0;
+}
+
+static inline int put_v4l2_meta_format(struct v4l2_meta_format *kp, struct v4l2_meta_format __user *up)
+{
+	if (copy_to_user(up, kp, sizeof(struct v4l2_meta_format)))
+		return -EFAULT;
+	return 0;
+}
+
 struct v4l2_format32 {
 	__u32	type;	/* enum v4l2_buf_type */
 	union {
diff -urN ori/kernel/kernel-5.10/drivers/media/v4l2-core/v4l2-dev.c intel/kernel/kernel-5.10/drivers/media/v4l2-core/v4l2-dev.c
--- ori/kernel/kernel-5.10/drivers/media/v4l2-core/v4l2-dev.c	2022-08-11 11:15:30.000000000 +0800
+++ intel/kernel/kernel-5.10/drivers/media/v4l2-core/v4l2-dev.c	2023-04-10 17:16:55.487134439 +0800
@@ -602,26 +602,30 @@
 	if (is_vid) {
 		/* video specific ioctls */
 		if ((is_rx && (ops->vidioc_enum_fmt_vid_cap ||
-			       ops->vidioc_enum_fmt_vid_overlay)) ||
+			       ops->vidioc_enum_fmt_vid_overlay ||
+				   ops->vidioc_enum_fmt_meta_cap)) ||
 		    (is_tx && ops->vidioc_enum_fmt_vid_out))
 			set_bit(_IOC_NR(VIDIOC_ENUM_FMT), valid_ioctls);
 		if ((is_rx && (ops->vidioc_g_fmt_vid_cap ||
 			       ops->vidioc_g_fmt_vid_cap_mplane ||
-			       ops->vidioc_g_fmt_vid_overlay)) ||
+			       ops->vidioc_g_fmt_vid_overlay ||
+				   ops->vidioc_g_fmt_meta_cap)) ||
 		    (is_tx && (ops->vidioc_g_fmt_vid_out ||
 			       ops->vidioc_g_fmt_vid_out_mplane ||
 			       ops->vidioc_g_fmt_vid_out_overlay)))
 			 set_bit(_IOC_NR(VIDIOC_G_FMT), valid_ioctls);
 		if ((is_rx && (ops->vidioc_s_fmt_vid_cap ||
 			       ops->vidioc_s_fmt_vid_cap_mplane ||
-			       ops->vidioc_s_fmt_vid_overlay)) ||
+			       ops->vidioc_s_fmt_vid_overlay ||
+				   ops->vidioc_s_fmt_meta_cap)) ||
 		    (is_tx && (ops->vidioc_s_fmt_vid_out ||
 			       ops->vidioc_s_fmt_vid_out_mplane ||
 			       ops->vidioc_s_fmt_vid_out_overlay)))
 			 set_bit(_IOC_NR(VIDIOC_S_FMT), valid_ioctls);
 		if ((is_rx && (ops->vidioc_try_fmt_vid_cap ||
 			       ops->vidioc_try_fmt_vid_cap_mplane ||
-			       ops->vidioc_try_fmt_vid_overlay)) ||
+			       ops->vidioc_try_fmt_vid_overlay ||
+				   ops->vidioc_try_fmt_meta_cap)) ||
 		    (is_tx && (ops->vidioc_try_fmt_vid_out ||
 			       ops->vidioc_try_fmt_vid_out_mplane ||
 			       ops->vidioc_try_fmt_vid_out_overlay)))
diff -urN ori/kernel/kernel-5.10/drivers/media/v4l2-core/v4l2-ioctl.c intel/kernel/kernel-5.10/drivers/media/v4l2-core/v4l2-ioctl.c
--- ori/kernel/kernel-5.10/drivers/media/v4l2-core/v4l2-ioctl.c	2022-08-11 11:15:30.000000000 +0800
+++ intel/kernel/kernel-5.10/drivers/media/v4l2-core/v4l2-ioctl.c	2023-04-10 17:16:55.487134439 +0800
@@ -1300,6 +1300,7 @@
 	case V4L2_PIX_FMT_GREY:		descr = "8-bit Greyscale"; break;
 	case V4L2_PIX_FMT_Y4:		descr = "4-bit Greyscale"; break;
 	case V4L2_PIX_FMT_Y6:		descr = "6-bit Greyscale"; break;
+	case V4L2_PIX_FMT_Y8:           descr = "Y8-bit Greyscale"; break;
 	case V4L2_PIX_FMT_Y10:		descr = "10-bit Greyscale"; break;
 	case V4L2_PIX_FMT_Y12:		descr = "12-bit Greyscale"; break;
 	case V4L2_PIX_FMT_Y14:		descr = "14-bit Greyscale"; break;
diff -urN ori/kernel/kernel-5.10/include/uapi/linux/videodev2.h intel/kernel/kernel-5.10/include/uapi/linux/videodev2.h
--- ori/kernel/kernel-5.10/include/uapi/linux/videodev2.h	2022-08-11 11:15:33.000000000 +0800
+++ intel/kernel/kernel-5.10/include/uapi/linux/videodev2.h	2023-04-10 17:16:55.487134439 +0800
@@ -738,11 +738,15 @@
 #define V4L2_PIX_FMT_JPGL	v4l2_fourcc('J', 'P', 'G', 'L') /* JPEG-Lite */
 #define V4L2_PIX_FMT_SE401      v4l2_fourcc('S', '4', '0', '1') /* se401 janggu compressed rgb */
 #define V4L2_PIX_FMT_S5C_UYVY_JPG v4l2_fourcc('S', '5', 'C', 'I') /* S5C73M3 interleaved UYVY/JPEG */
+#define V4L2_PIX_FMT_Y8       v4l2_fourcc('Y', '8', ' ', ' ') /* Greyscale 8-bit */
 #define V4L2_PIX_FMT_Y8I      v4l2_fourcc('Y', '8', 'I', ' ') /* Greyscale 8-bit L/R interleaved */
 #define V4L2_PIX_FMT_Y12I     v4l2_fourcc('Y', '1', '2', 'I') /* Greyscale 12-bit L/R interleaved */
 #define V4L2_PIX_FMT_Z16      v4l2_fourcc('Z', '1', '6', ' ') /* Depth data 16-bit */
 #define V4L2_PIX_FMT_MT21C    v4l2_fourcc('M', 'T', '2', '1') /* Mediatek compressed block mode  */
 #define V4L2_PIX_FMT_INZI     v4l2_fourcc('I', 'N', 'Z', 'I') /* Intel Planar Greyscale 10-bit and Depth 16-bit */
+#define V4L2_PIX_FMT_INVR     v4l2_fourcc('I', 'N', 'V', 'R') /* 16 Depth */
+#define V4L2_PIX_FMT_INRI     v4l2_fourcc('I', 'N', 'R', 'I') /* 24 Depth/IR 16:8 */
+#define V4L2_PIX_FMT_RELI     v4l2_fourcc('R', 'E', 'L', 'I') /* 8 IR alternating on off illumination */
 #define V4L2_PIX_FMT_SUNXI_TILED_NV12 v4l2_fourcc('S', 'T', '1', '2') /* Sunxi Tiled NV12 Format */
 #define V4L2_PIX_FMT_CNF4     v4l2_fourcc('C', 'N', 'F', '4') /* Intel 4-bit packed depth confidence information */
 #define V4L2_PIX_FMT_RW16     v4l2_fourcc('R', 'W', '1', '6') /* Raw data 16-bit */
@@ -2287,6 +2291,7 @@
 struct v4l2_meta_format {
 	__u32				dataformat;
 	__u32				buffersize;
+	__u8                reserved[24];
 } __attribute__ ((packed));
 
 /**
diff -urN ori/kernel/kernel-5.10/Makefile intel/kernel/kernel-5.10/Makefile
--- ori/kernel/kernel-5.10/Makefile	2022-08-11 11:15:28.000000000 +0800
+++ intel/kernel/kernel-5.10/Makefile	2023-04-10 17:17:02.579115845 +0800
@@ -1398,7 +1398,8 @@
 dtbs_check: dtbs
 
 dtbs_install:
-	$(Q)$(MAKE) $(dtbinst)=$(dtstree) dst=$(INSTALL_DTBS_PATH)
+	mkdir -p $(INSTALL_DTBS_PATH)
+	cp -rf $(dtstree)/nvidia/*.dtb $(INSTALL_DTBS_PATH)
 
 ifdef CONFIG_OF_EARLY_FLATTREE
 all: dtbs
diff -urN ori/kernel/kernel-5.10/scripts/package/builddeb intel/kernel/kernel-5.10/scripts/package/builddeb
--- ori/kernel/kernel-5.10/scripts/package/builddeb	2022-08-11 11:15:33.000000000 +0800
+++ intel/kernel/kernel-5.10/scripts/package/builddeb	2023-04-10 17:17:02.579115845 +0800
@@ -146,6 +146,7 @@
 else
 	cp System.map "$tmpdir/boot/System.map-$version"
 	cp $KCONFIG_CONFIG "$tmpdir/boot/config-$version"
+	cp "arch/$SRCARCH/boot/Image" "$tmpdir/boot/Image-$version"
 fi
 cp "$($MAKE -s -f $srctree/Makefile image_name)" "$tmpdir/$installed_image_path"
 
diff -urN ori/kernel/nvidia/drivers/media/i2c/d4xx.c intel/kernel/nvidia/drivers/media/i2c/d4xx.c
--- ori/kernel/nvidia/drivers/media/i2c/d4xx.c	1970-01-01 08:00:00.000000000 +0800
+++ intel/kernel/nvidia/drivers/media/i2c/d4xx.c	2023-04-26 10:40:19.991043069 +0800
@@ -0,0 +1,4021 @@
+/*
+ * ds5.c - Intel(R) RealSense(TM) D4XX camera driver
+ *
+ * Copyright (c) 2017-2019, INTEL CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+//#define DEBUG 1
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/kernel.h>
+#include <linux/media.h>
+#include <linux/module.h>
+#include <linux/of_gpio.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/videodev2.h>
+
+#include <media/media-entity.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-mediabus.h>
+
+//#define DS5_DRIVER_NAME "DS5 RealSense camera driver"
+#define DS5_DRIVER_NAME "d4xx"
+#define DS5_DRIVER_NAME_AWG "d4xx-awg"
+#define DS5_DRIVER_NAME_ASR "d4xx-asr"
+#define DS5_DRIVER_NAME_CLASS "d4xx-class"
+#define DS5_DRIVER_NAME_DFU "d4xx-dfu"
+
+#define DS5_MIPI_SUPPORT_LINES		0x0300
+#define DS5_MIPI_SUPPORT_PHY		0x0304
+#define DS5_MIPI_DATARATE_MIN		0x0308
+#define DS5_MIPI_DATARATE_MAX		0x030A
+#define DS5_FW_VERSION			0x030C
+#define DS5_FW_BUILD			0x030E
+#define DS5_DEVICE_TYPE			0x0310
+#define DS5_DEVICE_TYPE_D45X		6
+#define DS5_DEVICE_TYPE_D43X		5
+#define DS5_DEVICE_TYPE_D46X		4
+
+#define DS5_MIPI_LANE_NUMS		0x0400
+#define DS5_MIPI_LANE_DATARATE		0x0402
+#define DS5_MIPI_CONF_STATUS		0x0500
+
+#define DS5_START_STOP_STREAM		0x1000
+#define DS5_DEPTH_STREAM_STATUS		0x1004
+#define DS5_RGB_STREAM_STATUS		0x1008
+#define DS5_IMU_STREAM_STATUS		0x100C
+#define DS5_IR_STREAM_STATUS		0x1014
+
+#define DS5_STREAM_DEPTH		0x0
+#define DS5_STREAM_RGB			0x1
+#define DS5_STREAM_IMU			0x2
+#define DS5_STREAM_IR			0x4
+#define DS5_STREAM_STOP			0x100
+#define DS5_STREAM_START		0x200
+#define DS5_STREAM_IDLE			0x1
+#define DS5_STREAM_STREAMING		0x2
+
+#define DS5_DEPTH_STREAM_DT		0x4000
+#define DS5_DEPTH_STREAM_MD		0x4002
+#define DS5_DEPTH_RES_WIDTH		0x4004
+#define DS5_DEPTH_RES_HEIGHT		0x4008
+#define DS5_DEPTH_FPS			0x400C
+#define DS5_DEPTH_OVERRIDE		0x401C
+
+#define DS5_RGB_STREAM_DT		0x4020
+#define DS5_RGB_STREAM_MD		0x4022
+#define DS5_RGB_RES_WIDTH		0x4024
+#define DS5_RGB_RES_HEIGHT		0x4028
+#define DS5_RGB_FPS			0x402C
+
+#define DS5_IMU_STREAM_DT		0x4040
+#define DS5_IMU_STREAM_MD		0x4042
+#define DS5_IMU_RES_WIDTH		0x4044
+#define DS5_IMU_RES_HEIGHT		0x4048
+#define DS5_IMU_FPS			0x404C
+
+#define DS5_IR_STREAM_DT		0x4080
+#define DS5_IR_STREAM_MD		0x4082
+#define DS5_IR_RES_WIDTH		0x4084
+#define DS5_IR_RES_HEIGHT		0x4088
+#define DS5_IR_FPS			0x408C
+#define DS5_IR_OVERRIDE			0x409C
+
+#define DS5_DEPTH_CONTROL_BASE		0x4100
+#define DS5_RGB_CONTROL_BASE		0x4200
+#define DS5_MANUAL_EXPOSURE_LSB		0x0000
+#define DS5_MANUAL_EXPOSURE_MSB		0x0002
+#define DS5_MANUAL_GAIN			0x0004
+#define DS5_LASER_POWER			0x0008
+#define DS5_AUTO_EXPOSURE_MODE		0x000C
+#define DS5_EXPOSURE_ROI_TOP		0x0010
+#define DS5_EXPOSURE_ROI_LEFT		0x0014
+#define DS5_EXPOSURE_ROI_BOTTOM		0x0018
+#define DS5_EXPOSURE_ROI_RIGHT		0x001C
+#define DS5_MANUAL_LASER_POWER		0x0024
+#define DS5_PWM_FREQUENCY		0x0028
+
+#define DS5_DEPTH_CONFIG_STATUS		0x4800
+#define DS5_RGB_CONFIG_STATUS		0x4802
+#define DS5_IMU_CONFIG_STATUS		0x4804
+#define DS5_IR_CONFIG_STATUS		0x4808
+
+#define DS5_STATUS_STREAMING		0x1
+#define DS5_STATUS_INVALID_DT		0x2
+#define DS5_STATUS_INVALID_RES		0x4
+#define DS5_STATUS_INVALID_FPS		0x8
+
+#define MIPI_LANE_RATE			1000
+
+#define MAX_DEPTH_EXP			200000
+#define MAX_RGB_EXP			10000
+#define DEF_DEPTH_EXP			33000
+#define DEF_RGB_EXP			1660
+
+/* Currently both depth and IR use VC 0 */
+#define DS5_DEPTH_VCHAN_N		0
+#define DS5_MOTION_T_VCHAN_N		0
+//#define DS5_DEBUG_VCHAN_N		1
+//#define DS5_MOTION_T_VCHAN_N		2
+
+enum ds5_mux_pad {
+	DS5_MUX_PAD_EXTERNAL,
+	DS5_MUX_PAD_DEPTH,
+	DS5_MUX_PAD_MOTION_T,
+	DS5_MUX_PAD_RGB,
+	DS5_MUX_PAD_IMU,
+	DS5_MUX_PAD_COUNT,
+};
+
+#define DS5_N_CONTROLS			8
+
+#define CSI2_MAX_VIRTUAL_CHANNELS	4
+
+#define DFU_WAIT_RET_LEN 6
+
+#define DS5_START_POLL_TIME	10
+#define DS5_START_MAX_TIME	1000
+#define DS5_START_MAX_COUNT	(DS5_START_MAX_TIME / DS5_START_POLL_TIME)
+
+/* DFU definition section */
+#define DFU_MAGIC_NUMBER "/0x01/0x02/0x03/0x04"
+#define DFU_BLOCK_SIZE 1024
+
+#define DFU_I2C_STANDARD_MODE		100000
+#define DFU_I2C_FAST_MODE			400000
+#define DFU_I2C_BUS_CLK_RATE		DFU_I2C_FAST_MODE
+
+#define ds5_read_with_check(state, addr, val) {\
+	if (ds5_read(state, addr, val))	\
+		return -EINVAL;}
+#define ds5_raw_read_with_check(state, addr, buf, size)	{\
+	if (ds5_raw_read(state, addr, buf, size))	\
+		return -EINVAL;}
+#define ds5_write_with_check(state, addr, val) {\
+	if (ds5_write(state, addr, val)) 	\
+		return -EINVAL;}
+#define ds5_raw_write_with_check(state, addr, buf, size) {\
+	if (ds5_raw_write(state, addr, buf, size)) 	\
+		return -EINVAL;}
+enum dfu_fw_state {
+	appIDLE                = 0x0000,
+	appDETACH              = 0x0001,
+	dfuIDLE                = 0x0002,
+	dfuDNLOAD_SYNC         = 0x0003,
+	dfuDNBUSY              = 0x0004,
+	dfuDNLOAD_IDLE         = 0x0005,
+	dfuMANIFEST_SYNC       = 0x0006,
+	dfuMANIFEST            = 0x0007,
+	dfuMANIFEST_WAIT_RESET = 0x0008,
+	dfuUPLOAD_IDLE         = 0x0009,
+	dfuERROR               = 0x000a
+};
+
+enum dfu_state {
+	DS5_DFU_IDLE = 0,
+	DS5_DFU_RECOVERY,
+	DS5_DFU_OPEN,
+	DS5_DFU_IN_PROGRESS,
+	DS5_DFU_DONE,
+	DS5_DFU_ERROR
+} dfu_state_t;
+
+struct hwm_cmd {
+	u16 header;
+	u16 magic_word;
+	u32 opcode;
+	u32 param1;
+	u32 param2;
+	u32 param3;
+	u32 param4;
+	unsigned char Data[0];
+};
+
+static const struct hwm_cmd cmd_switch_to_dfu = {
+	.header = 0x14,
+	.magic_word = 0xCDAB,
+	.opcode = 0x1e,
+	.param1 = 0x01,
+};
+
+enum table_id {
+	COEF_CALIBRATION_ID = 0x19,
+	DEPTH_CALIBRATION_ID = 0x1f,
+	RGB_CALIBRATION_ID = 0x20,
+	IMU_CALIBRATION_ID = 0x22
+} table_id_t;
+
+static const struct hwm_cmd get_calib_data = {
+	.header = 0x14,
+	.magic_word = 0xCDAB,
+	.opcode = 0x15,
+	.param1 = 0x00,	//table_id
+};
+
+static const struct hwm_cmd set_calib_data = {
+	.header = 0x0114,
+	.magic_word = 0xCDAB,
+	.opcode = 0x62,
+	.param1 = 0x00,	//table_id
+	.param2 = 0x02,	//region
+};
+
+static const struct hwm_cmd gvd = {
+	.header = 0x14,
+	.magic_word = 0xCDAB,
+	.opcode = 0x10,
+};
+
+static const struct hwm_cmd set_ae_roi = {
+	.header = 0x14,
+	.magic_word = 0xCDAB,
+	.opcode = 0x44,
+};
+
+static const struct hwm_cmd get_ae_roi = {
+	.header = 0x014,
+	.magic_word = 0xCDAB,
+	.opcode = 0x45,
+};
+
+static const struct hwm_cmd set_ae_setpoint = {
+	.header = 0x18,
+	.magic_word = 0xCDAB,
+	.opcode = 0x2B,
+	.param1 = 0xa, // AE control
+};
+
+static const struct hwm_cmd get_ae_setpoint = {
+	.header = 0x014,
+	.magic_word = 0xCDAB,
+	.opcode = 0x2C,
+	.param1 = 0xa, // AE control
+	.param2 = 0, // get current
+};
+
+static const struct hwm_cmd erb = {
+	.header = 0x14,
+	.magic_word = 0xCDAB,
+	.opcode = 0x17,
+};
+
+static const struct hwm_cmd ewb = {
+	.header = 0x14,
+	.magic_word = 0xCDAB,
+	.opcode = 0x18,
+};
+
+struct __fw_status {
+	uint32_t	spare1;
+	uint32_t	FW_lastVersion;
+	uint32_t	FW_highestVersion;
+	uint16_t	FW_DownloadStatus;
+	uint16_t	DFU_isLocked;
+	uint16_t	DFU_version;
+	uint8_t		ivcamSerialNum[8];
+	uint8_t		spare2[42];
+};
+
+
+/*************************/
+
+struct ds5_ctrls {
+	struct v4l2_ctrl_handler handler;
+	struct {
+		struct v4l2_ctrl *log;
+		struct v4l2_ctrl *fw_version;
+		struct v4l2_ctrl *gvd;
+		struct v4l2_ctrl *get_depth_calib;
+		struct v4l2_ctrl *set_depth_calib;
+		struct v4l2_ctrl *get_coeff_calib;
+		struct v4l2_ctrl *set_coeff_calib;
+		struct v4l2_ctrl *ae_roi_get;
+		struct v4l2_ctrl *ae_roi_set;
+		struct v4l2_ctrl *ae_setpoint_get;
+		struct v4l2_ctrl *ae_setpoint_set;
+		struct v4l2_ctrl *erb;
+		struct v4l2_ctrl *ewb;
+		struct v4l2_ctrl *hwmc;
+		struct v4l2_ctrl *laser_power;
+		struct v4l2_ctrl *manual_laser_power;
+		struct v4l2_ctrl *auto_exp;
+		struct v4l2_ctrl *exposure;
+		/* in DS5 manual gain only works with manual exposure */
+		struct v4l2_ctrl *gain;
+	};
+};
+
+struct ds5_resolution {
+	u16 width;
+	u16 height;
+	u8 n_framerates;
+	const u16 *framerates;
+};
+
+struct ds5_format {
+	unsigned int n_resolutions;
+	const struct ds5_resolution *resolutions;
+	u32 mbus_code;
+	u8 data_type;
+};
+
+struct ds5_sensor {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt format;
+	u16 mux_pad;
+	struct {
+		const struct ds5_format *format;
+		const struct ds5_resolution *resolution;
+		u16 framerate;
+	} config;
+	bool streaming;
+	/*struct ds5_vchan *vchan;*/
+	const struct ds5_format *formats;
+	unsigned int n_formats;
+};
+
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+#include <media/camera_common.h>
+#define ds5_mux_subdev camera_common_data
+#else
+struct ds5_mux_subdev {
+	struct v4l2_subdev subdev;
+};
+#endif
+
+struct ds5_variant {
+	const struct ds5_format *formats;
+	unsigned int n_formats;
+};
+
+struct ds5_dfu_dev {
+	struct cdev ds5_cdev;
+	struct class *ds5_class;
+	int device_open_count;
+	enum dfu_state dfu_state_flag;
+	unsigned char *dfu_msg;
+	u16 msg_write_once;
+	unsigned char init_v4l_f;
+	u32 bus_clk_rate;
+};
+
+enum {
+	DS5_DS5U,
+	DS5_ASR,
+	DS5_AWG,
+};
+
+struct ds5 {
+	struct {
+		struct ds5_sensor sensor;
+	} depth;
+	struct {
+		struct ds5_sensor sensor;
+	} motion_t;
+	struct {
+		struct ds5_sensor sensor;
+	} rgb;
+	struct {
+		struct ds5_sensor sensor;
+	} imu;
+	struct {
+		struct ds5_mux_subdev sd;
+		struct media_pad pads[DS5_MUX_PAD_COUNT];
+		struct ds5_sensor *last_set;
+	} mux;
+	struct ds5_ctrls ctrls;
+	struct ds5_dfu_dev dfu_dev;
+	bool power;
+	struct i2c_client *client;
+	/*struct ds5_vchan virtual_channels[CSI2_MAX_VIRTUAL_CHANNELS];*/
+	/* All below pointers are used for writing, cannot be const */
+	struct mutex lock;
+	struct regmap *regmap;
+	struct regulator *vcc;
+	const struct ds5_variant *variant;
+	int is_depth;
+	int is_y8;
+	int is_rgb;
+	int is_imu;
+	u16 fw_version;
+	u16 fw_build;
+};
+
+struct ds5_counters {
+	unsigned int n_res;
+	unsigned int n_fmt;
+	unsigned int n_ctrl;
+};
+
+#define ds5_from_depth_sd(sd) container_of(sd, struct ds5, depth.sd)
+#define ds5_from_motion_t_sd(sd) container_of(sd, struct ds5, motion_t.sd)
+#define ds5_from_rgb_sd(sd) container_of(sd, struct ds5, rgb.sd)
+
+static int ds5_write(struct ds5 *state, u16 reg, u16 val)
+{
+	int ret;
+	u8 value[2];
+
+	value[1] = val >> 8;
+	value[0] = val & 0x00FF;
+
+	dev_dbg(&state->client->dev,
+			"%s(): writing to register: 0x%04x, value1: 0x%x, value2:0x%x\n",
+			__func__, reg, value[1], value[0]);
+
+	state->client->addr = 0x10;
+	ret = regmap_raw_write(state->regmap, reg, value, sizeof(value));
+	if (ret < 0)
+		dev_err(&state->client->dev,
+				"%s(): i2c write failed %d, 0x%04x = 0x%x\n",
+				__func__, ret, reg, val);
+	else
+		if (state->dfu_dev.dfu_state_flag == DS5_DFU_IDLE)
+			dev_dbg(&state->client->dev, "%s(): i2c write 0x%04x: 0x%x\n",
+				__func__, reg, val);
+
+	return ret;
+}
+
+static int ds5_raw_write(struct ds5 *state, u16 reg,
+		const void *val, size_t val_len)
+{
+	int ret = 0;
+	state->client->addr = 0x10;
+	ret = regmap_raw_write(state->regmap, reg, val, val_len);
+	if (ret < 0)
+		dev_err(&state->client->dev,
+				"%s(): i2c raw write failed %d, %04x size(%d) bytes\n",
+				__func__, ret, reg, (int)val_len);
+	else
+		if (state->dfu_dev.dfu_state_flag == DS5_DFU_IDLE)
+			dev_dbg(&state->client->dev,
+					"%s(): i2c raw write 0x%04x: %d bytes\n",
+					__func__, reg, (int)val_len);
+
+	return ret;
+}
+
+static int ds5_read(struct ds5 *state, u16 reg, u16 *val)
+{
+	int ret = 0;
+
+	state->client->addr = 0x10;
+	ret = regmap_raw_read(state->regmap, reg, val, 2);
+	if (ret < 0)
+		dev_err(&state->client->dev, "%s(): i2c read failed %d, 0x%04x\n",
+				__func__, ret, reg);
+	else {
+		if (state->dfu_dev.dfu_state_flag == DS5_DFU_IDLE)
+			dev_dbg(&state->client->dev, "%s(): i2c read 0x%04x: 0x%x\n",
+					__func__, reg, *val);
+	}
+
+	return ret;
+}
+
+static int ds5_raw_read(struct ds5 *state, u16 reg, void *val,
+ size_t val_len)
+{
+	int ret = 0;
+	state->client->addr = 0x10;
+	ret = regmap_raw_read(state->regmap, reg, val, val_len);
+	if (ret < 0)
+		dev_err(&state->client->dev, "%s(): i2c read failed %d, 0x%04x\n",
+			__func__, ret, reg);
+
+	return ret;
+}
+
+/* Pad ops */
+
+static const u16 ds5_default_framerate = 30;
+
+// **********************
+// FIXME: D16 width must be doubled, because an 8-bit format is used. Check how
+// the Tegra driver propagates resolutions and formats.
+// **********************
+
+//TODO: keep 6, till 5 is supported by FW
+static const u16 ds5_framerates[] = {5, 30};
+
+#define DS5_FRAMERATE_DEFAULT_IDX 1
+
+static const u16 ds5_framerate_30 = 30;
+
+static const u16 ds5_framerate_15_30[] = {15, 30};
+
+static const u16 ds5_framerate_25 = 25;
+
+static const u16 ds5_depth_framerate_to_30[] = {5, 15, 30};
+static const u16 ds5_framerate_to_30[] = {5, 10, 15, 30};
+static const u16 ds5_framerate_to_60[] = {5, 15, 30, 60};
+static const u16 ds5_framerate_to_90[] = {5, 15, 30, 60, 90};
+static const u16 ds5_framerate_100[] = {100};
+static const u16 ds5_framerate_90[] = {90};
+static const u16 ds5_imu_framerates[] = {50, 100, 200, 400};
+
+static const struct ds5_resolution d43x_depth_sizes[] = {
+	{
+		.width = 1280,
+		.height = 720,
+		.framerates = ds5_depth_framerate_to_30,
+		.n_framerates = ARRAY_SIZE(ds5_depth_framerate_to_30),
+	}, {
+		.width =  848,
+		.height = 480,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width =  848,
+		.height = 100,
+		.framerates = ds5_framerate_100,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_100),
+	}, {
+		.width =  640,
+		.height = 480,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width =  640,
+		.height = 360,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width =  480,
+		.height = 270,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width =  424,
+		.height = 240,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width =  256,
+		.height = 144,
+		.framerates = ds5_framerate_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_90),
+	},
+};
+
+static const struct ds5_resolution d46x_depth_sizes[] = {
+	{
+		.width = 1280,
+		.height = 960,
+		.framerates = ds5_framerates,
+		.n_framerates = ARRAY_SIZE(ds5_framerates),
+	},{
+		.width =  640,
+		.height = 480,
+		.framerates = ds5_framerates,
+		.n_framerates = ARRAY_SIZE(ds5_framerates),
+	},
+};
+
+static const struct ds5_resolution y8_sizes[] = {
+	{
+		.width = 1280,
+		.height = 720,
+		.framerates = ds5_depth_framerate_to_30,
+		.n_framerates = ARRAY_SIZE(ds5_depth_framerate_to_30),
+	}, {
+		.width =  848,
+		.height = 480,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width =  640,
+		.height = 480,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width =  640,
+		.height = 360,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width =  480,
+		.height = 270,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width =  424,
+		.height = 240,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}
+};
+
+static const struct ds5_resolution ds5_rlt_rgb_sizes[] = {
+	{
+		.width = 1280,
+		.height = 800,
+		.framerates = ds5_framerate_to_30,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_30),
+	}, {
+		.width = 1280,
+		.height = 720,
+		.framerates = ds5_framerate_to_30,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_30),
+	}, {
+		.width = 848,
+		.height = 480,
+		.framerates = ds5_framerate_to_60,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_60),
+	}, {
+		.width = 640,
+		.height = 480,
+		.framerates = ds5_framerate_to_60,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_60),
+	}, {
+		.width = 640,
+		.height = 360,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width = 480,
+		.height = 270,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width = 424,
+		.height = 240,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	},
+};
+
+static const struct ds5_resolution ds5_onsemi_rgb_sizes[] = {
+	{
+		.width = 640,
+		.height = 480,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width = 960,
+		.height = 720,
+		.framerates = ds5_framerate_to_60,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_60),
+	}, {
+		.width = 1280,
+		.height = 720,
+		.framerates = ds5_framerates,
+		.n_framerates = ARRAY_SIZE(ds5_framerates),
+	}, {
+		.width = 1920,
+		.height = 1080,
+		.framerates = ds5_framerates,
+		.n_framerates = ARRAY_SIZE(ds5_framerates),
+	}, {
+		.width = 2048,
+		.height = 1536,
+		.framerates = ds5_framerates,
+		.n_framerates = ARRAY_SIZE(ds5_framerates),
+	},
+};
+
+static const struct ds5_resolution ds5_size_w10 = {
+	.width =  1920,
+	.height = 1080,
+	.framerates = &ds5_framerate_30,
+	.n_framerates = 1,
+};
+
+static const struct ds5_resolution d43x_calibration_sizes[] = {
+	{
+		.width =  1280,
+		.height = 800,
+		.framerates = ds5_framerate_15_30,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_15_30),
+	},
+};
+
+static const struct ds5_resolution d46x_calibration_sizes[] = {
+	{
+		.width =  1600,
+		.height = 1300,
+		.framerates = ds5_framerate_15_30,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_15_30),
+	},
+};
+
+static const struct ds5_resolution ds5_size_imu[] = {
+	{
+	.width =  32,
+	.height = 1,
+	.framerates = ds5_imu_framerates,
+	.n_framerates = ARRAY_SIZE(ds5_imu_framerates),
+	},
+};
+
+static const struct ds5_format ds5_depth_formats_d43x[] = {
+	{
+		// TODO: 0x31 is replaced with 0x1e since it caused low FPS in Jetson.
+		.data_type = 0x1e,	/* Z16 */
+		.mbus_code = MEDIA_BUS_FMT_UYVY8_1X16,
+		.n_resolutions = ARRAY_SIZE(d43x_depth_sizes),
+		.resolutions = d43x_depth_sizes,
+	}, {
+		.data_type = 0x2a,	/* Y8 */
+		.mbus_code = MEDIA_BUS_FMT_Y8_1X8,
+		.n_resolutions = ARRAY_SIZE(d43x_depth_sizes),
+		.resolutions = d43x_depth_sizes,
+	}, {
+		.data_type = 0x24,	/* 24-bit Calibration */
+		.mbus_code = MEDIA_BUS_FMT_RGB888_1X24,	/* FIXME */
+		.n_resolutions = ARRAY_SIZE(d43x_calibration_sizes),
+		.resolutions = d43x_calibration_sizes,
+	},
+};
+
+static const struct ds5_format ds5_depth_formats_d46x[] = {
+	{
+		// TODO: 0x31 is replaced with 0x1e since it caused low FPS in Jetson.
+		.data_type = 0x1e,	/* Z16 */
+		.mbus_code = MEDIA_BUS_FMT_UYVY8_1X16,
+		.n_resolutions = ARRAY_SIZE(d46x_depth_sizes),
+		.resolutions = d46x_depth_sizes,
+	}, {
+		/* First format: default */
+		.data_type = 0x2a,	/* Y8 */
+		.mbus_code = MEDIA_BUS_FMT_Y8_1X8,
+		.n_resolutions = ARRAY_SIZE(d46x_depth_sizes),
+		.resolutions = d46x_depth_sizes,
+	}, {
+		.data_type = 0x24,	/* 24-bit Calibration */
+		.mbus_code = MEDIA_BUS_FMT_RGB888_1X24,	/* FIXME */
+		.n_resolutions = ARRAY_SIZE(d46x_calibration_sizes),
+		.resolutions = d46x_calibration_sizes,
+	},
+};
+
+#define DS5_DEPTH_N_FORMATS 1
+
+static const struct ds5_format ds5_y_formats_ds5u[] = {
+	{
+		/* First format: default */
+		.data_type = 0x2a,	/* Y8 */
+		.mbus_code = MEDIA_BUS_FMT_Y8_1X8,
+		.n_resolutions = ARRAY_SIZE(y8_sizes),
+		.resolutions = y8_sizes,
+	}, {
+		.data_type = 0x1e,	/* Y8I */
+		.mbus_code = MEDIA_BUS_FMT_VYUY8_1X16,
+		.n_resolutions = ARRAY_SIZE(y8_sizes),
+		.resolutions = y8_sizes,
+	}, {
+		.data_type = 0x24,	/* 24-bit Calibration */
+		.mbus_code = MEDIA_BUS_FMT_RGB888_1X24,	/* FIXME */
+		.n_resolutions = ARRAY_SIZE(d43x_calibration_sizes),
+		.resolutions = d43x_calibration_sizes,
+	},
+};
+
+static const struct ds5_format ds5_rlt_rgb_format = {
+	.data_type = 0x1e,	/* UYVY */
+	.mbus_code = MEDIA_BUS_FMT_YUYV8_1X16,
+	.n_resolutions = ARRAY_SIZE(ds5_rlt_rgb_sizes),
+	.resolutions = ds5_rlt_rgb_sizes,
+};
+#define DS5_RLT_RGB_N_FORMATS 1
+
+static const struct ds5_format ds5_onsemi_rgb_format = {
+	.data_type = 0x1e,	/* UYVY */
+	.mbus_code = MEDIA_BUS_FMT_YUYV8_1X16,
+	.n_resolutions = ARRAY_SIZE(ds5_onsemi_rgb_sizes),
+	.resolutions = ds5_onsemi_rgb_sizes,
+};
+#define DS5_ONSEMI_RGB_N_FORMATS 1
+
+static const struct ds5_variant ds5_variants[] = {
+	[DS5_DS5U] = {
+		.formats = ds5_y_formats_ds5u,
+		.n_formats = ARRAY_SIZE(ds5_y_formats_ds5u),
+	},
+};
+
+static const struct ds5_format ds5_imu_formats[] = {
+	{
+		/* First format: default */
+		.data_type = 0x2a,	/* IMU DT */
+		.mbus_code = MEDIA_BUS_FMT_Y8_1X8,
+		.n_resolutions = ARRAY_SIZE(ds5_size_imu),
+		.resolutions = ds5_size_imu,
+	},
+};
+
+static const struct v4l2_mbus_framefmt ds5_mbus_framefmt_template = {
+	.width = 0,
+	.height = 0,
+	.code = MEDIA_BUS_FMT_FIXED,
+	.field = V4L2_FIELD_NONE,
+	.colorspace = V4L2_COLORSPACE_DEFAULT,
+	.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT,
+	.quantization = V4L2_QUANTIZATION_DEFAULT,
+	.xfer_func = V4L2_XFER_FUNC_DEFAULT,
+};
+
+/* Get readable sensor name */
+static const char *ds5_get_sensor_name(struct ds5 *state)
+{
+	static const char *sensor_name[] = {"unknown", "RGB", "DEPTH", "Y8", "IMU"};
+	int sensor_id = state->is_rgb * 1 + state->is_depth * 2 + \
+			state->is_y8 * 3 + state->is_imu * 4;
+	if (sensor_id >= (sizeof(sensor_name)/sizeof(*sensor_name)))
+		sensor_id = 0;
+
+	return sensor_name[sensor_id];
+}
+
+/* This is needed for .get_fmt()
+ * and if streaming is started without .set_fmt() */
+static void ds5_sensor_format_init(struct ds5_sensor *sensor)
+{
+	const struct ds5_format *fmt;
+	struct v4l2_mbus_framefmt *ffmt;
+	unsigned int i;
+
+	if (sensor->config.format)
+		return;
+
+	dev_dbg(sensor->sd.dev, "%s(): on pad %u\n", __func__, sensor->mux_pad);
+
+	ffmt = &sensor->format;
+	*ffmt = ds5_mbus_framefmt_template;
+	/* Use the first format */
+	fmt = sensor->formats;
+	ffmt->code = fmt->mbus_code;
+	/* and the first resolution */
+	ffmt->width = fmt->resolutions->width;
+	ffmt->height = fmt->resolutions->height;
+
+	sensor->config.format = fmt;
+	sensor->config.resolution = fmt->resolutions;
+	/* Set default framerate to 30, or to 1st one if not supported */
+	for (i = 0; i < fmt->resolutions->n_framerates;i++) {
+		if (fmt->resolutions->framerates[i] == ds5_framerate_30 /* fps */) {
+			sensor->config.framerate = ds5_framerate_30;
+			return;
+		}
+	}
+	sensor->config.framerate = fmt->resolutions->framerates[0];
+}
+
+/* No locking needed for enumeration methods */
+static int ds5_sensor_enum_mbus_code(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_mbus_code_enum *mce)
+{
+	struct ds5_sensor *sensor = container_of(sd, struct ds5_sensor, sd);
+
+	if (mce->pad)
+		return -EINVAL;
+
+	if (mce->index >= sensor->n_formats)
+		return -EINVAL;
+
+	mce->code = sensor->formats[mce->index].mbus_code;
+
+	return 0;
+}
+
+static int ds5_sensor_enum_frame_size(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct ds5_sensor *sensor = container_of(sd, struct ds5_sensor, sd);
+	const struct ds5_format *fmt;
+	unsigned int i;
+
+	for (i = 0, fmt = sensor->formats; i < sensor->n_formats; i++, fmt++)
+		if (fse->code == fmt->mbus_code)
+			break;
+
+	if (i == sensor->n_formats)
+		return -EINVAL;
+
+	if (fse->index >= fmt->n_resolutions)
+		return -EINVAL;
+
+	fse->min_width = fse->max_width = fmt->resolutions[fse->index].width;
+	fse->min_height = fse->max_height = fmt->resolutions[fse->index].height;
+
+	return 0;
+}
+
+static int ds5_sensor_enum_frame_interval(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_frame_interval_enum *fie)
+{
+	struct ds5_sensor *sensor = container_of(sd, struct ds5_sensor, sd);
+	const struct ds5_format *fmt;
+	const struct ds5_resolution *res;
+	unsigned int i;
+
+	for (i = 0, fmt = sensor->formats; i < sensor->n_formats; i++, fmt++)
+		if (fie->code == fmt->mbus_code)
+			break;
+
+	if (i == sensor->n_formats)
+		return -EINVAL;
+
+	for (i = 0, res = fmt->resolutions; i < fmt->n_resolutions; i++, res++)
+		if (res->width == fie->width && res->height == fie->height)
+			break;
+
+	if (i == fmt->n_resolutions)
+		return -EINVAL;
+
+	if (fie->index >= res->n_framerates)
+		return -EINVAL;
+
+	fie->interval.numerator = 1;
+	fie->interval.denominator = res->framerates[fie->index];
+
+	return 0;
+}
+
+static int ds5_sensor_get_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_format *fmt)
+{
+	struct ds5_sensor *sensor = container_of(sd, struct ds5_sensor, sd);
+	struct ds5 *state = v4l2_get_subdevdata(sd);
+
+	if (fmt->pad)
+		return -EINVAL;
+
+	mutex_lock(&state->lock);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY)
+		fmt->format = *v4l2_subdev_get_try_format(sd, cfg, fmt->pad);
+	else
+		fmt->format = sensor->format;
+
+	mutex_unlock(&state->lock);
+
+	dev_dbg(sd->dev, "%s(): pad %x, code %x, res %ux%u\n",
+			__func__, fmt->pad, fmt->format.code,
+			fmt->format.width, fmt->format.height);
+
+	return 0;
+}
+
+/* Called with lock held */
+static const struct ds5_format *ds5_sensor_find_format(
+		struct ds5_sensor *sensor,
+		struct v4l2_mbus_framefmt *ffmt,
+		const struct ds5_resolution **best)
+{
+	const struct ds5_resolution *res;
+	const struct ds5_format *fmt;
+	unsigned long best_delta = ~0;
+	unsigned int i;
+
+	for (i = 0, fmt = sensor->formats; i < sensor->n_formats; i++, fmt++) {
+		if (fmt->mbus_code == ffmt->code)
+			break;
+	}
+	dev_dbg(sensor->sd.dev, "%s(): mbus_code = %x, code = %x \n",
+			__func__, fmt->mbus_code, ffmt->code);
+
+	if (i == sensor->n_formats)
+		/* Not found, use default */
+		fmt = sensor->formats;
+
+	for (i = 0, res = fmt->resolutions; i < fmt->n_resolutions; i++, res++) {
+		unsigned long delta = abs(ffmt->width * ffmt->height -
+				res->width * res->height);
+		if (delta < best_delta) {
+			best_delta = delta;
+			*best = res;
+		}
+	}
+
+	ffmt->code = fmt->mbus_code;
+	ffmt->width = (*best)->width;
+	ffmt->height = (*best)->height;
+
+	ffmt->field = V4L2_FIELD_NONE;
+	/* Should we use V4L2_COLORSPACE_RAW for Y12I? */
+	ffmt->colorspace = V4L2_COLORSPACE_SRGB;
+
+	return fmt;
+}
+
+static int __ds5_sensor_set_fmt(struct ds5 *state, struct ds5_sensor *sensor,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_format *fmt)
+{
+	struct v4l2_mbus_framefmt *mf;// = &fmt->format;
+	//unsigned r;
+
+	dev_dbg(sensor->sd.dev, "%s(): state %p, "
+			"sensor %p, cfg %p, fmt %p, fmt->format %p\n",
+			__func__, state, sensor, cfg, fmt,  &fmt->format);
+
+	mf = &fmt->format;
+
+	if (fmt->pad)
+		return -EINVAL;
+
+	mutex_lock(&state->lock);
+
+	sensor->config.format = ds5_sensor_find_format(sensor, mf,
+						&sensor->config.resolution);
+	//r = DS5_FRAMERATE_DEFAULT_IDX < sensor->config.resolution->n_framerates ?
+	//	DS5_FRAMERATE_DEFAULT_IDX : 0;
+	/* FIXME: check if a framerate has been set */
+	//sensor->config.framerate = sensor->config.resolution->framerates[r];
+
+	if (cfg && fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
+		*v4l2_subdev_get_try_format(&sensor->sd, cfg, fmt->pad) = *mf;
+		dev_dbg(sensor->sd.dev, "%s():4l2_subdev_get_try_format ret: %p\n",
+				__func__, cfg);
+	}
+
+	else
+// FIXME: use this format in .s_stream()
+		sensor->format = *mf;
+
+	state->mux.last_set = sensor;
+
+	mutex_unlock(&state->lock);
+
+	dev_dbg(sensor->sd.dev, "%s(): pad: %x, code: %x, %ux%u\n",
+			__func__, fmt->pad, fmt->format.code,
+			fmt->format.width, fmt->format.height);
+
+	return 0;
+}
+
+static int ds5_sensor_set_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_format *fmt)
+{
+	struct ds5_sensor *sensor = container_of(sd, struct ds5_sensor, sd);
+	struct ds5 *state = v4l2_get_subdevdata(sd);
+
+	return __ds5_sensor_set_fmt(state, sensor, cfg, fmt);
+}
+
+static int ds5_configure(struct ds5 *state)
+{
+	struct ds5_sensor *sensor;
+	u16 fmt, md_fmt, vc_id;
+	u16 dt_addr, md_addr, override_addr, fps_addr, width_addr, height_addr;
+	int ret;
+
+	if (state->is_depth) {
+		sensor = &state->depth.sensor;
+		dt_addr = DS5_DEPTH_STREAM_DT;
+		md_addr = DS5_DEPTH_STREAM_MD;
+		override_addr = DS5_DEPTH_OVERRIDE;
+		fps_addr = DS5_DEPTH_FPS;
+		width_addr = DS5_DEPTH_RES_WIDTH;
+		height_addr = DS5_DEPTH_RES_HEIGHT;
+		// TODO: read VC from device tree
+		vc_id = 0;
+		md_fmt = 0x12;
+	} else if (state->is_rgb) {
+		sensor = &state->rgb.sensor;
+		dt_addr = DS5_RGB_STREAM_DT;
+		md_addr = DS5_RGB_STREAM_MD;
+		override_addr = 0;
+		fps_addr = DS5_RGB_FPS;
+		width_addr = DS5_RGB_RES_WIDTH;
+		height_addr = DS5_RGB_RES_HEIGHT;
+		vc_id = 1;
+		md_fmt = 0x12;
+	} else if (state->is_y8) {
+		sensor = &state->motion_t.sensor;
+		dt_addr = DS5_IR_STREAM_DT;
+		md_addr = DS5_IR_STREAM_MD;
+		override_addr = DS5_IR_OVERRIDE;
+		fps_addr = DS5_IR_FPS;
+		width_addr = DS5_IR_RES_WIDTH;
+		height_addr = DS5_IR_RES_HEIGHT;
+		vc_id = 2;
+		md_fmt = 0x12;
+	} else if (state->is_imu) {
+		sensor = &state->imu.sensor;
+		dt_addr = DS5_IMU_STREAM_DT;
+		md_addr = DS5_IMU_STREAM_MD;
+		override_addr = 0;
+		fps_addr = DS5_IMU_FPS;
+		width_addr = DS5_IMU_RES_WIDTH;
+		height_addr = DS5_IMU_RES_HEIGHT;
+		vc_id = 3;
+		md_fmt = 0x0;
+	} else {
+		return -EINVAL;
+	}
+
+	fmt = sensor->streaming ? sensor->config.format->data_type : 0;
+
+	/*
+	 * Set depth stream Z16 data type as 0x31
+	 * Set IR stream Y8I data type as 0x32
+	 */
+	if (state->is_depth && fmt != 0)
+		ret = ds5_write(state, dt_addr, 0x31);
+	else if (state->is_y8 && fmt != 0 &&
+		 sensor->config.format->data_type == 0x1e)
+		ret = ds5_write(state, dt_addr, 0x32);
+	else
+		ret = ds5_write(state, dt_addr, fmt);
+	if (ret < 0)
+		return ret;
+
+	ret = ds5_write(state, md_addr, (vc_id << 8) | md_fmt);
+	if (ret < 0)
+		return ret;
+
+	if (!sensor->streaming)
+		return ret;
+
+	if (override_addr != 0) {
+		ret = ds5_write(state, override_addr, fmt);
+		if (ret < 0)
+			return ret;
+	}
+
+	ret = ds5_write(state, fps_addr, sensor->config.framerate);
+	if (ret < 0)
+		return ret;
+
+	ret = ds5_write(state, width_addr, sensor->config.resolution->width);
+	if (ret < 0)
+		return ret;
+
+	ret = ds5_write(state, height_addr, sensor->config.resolution->height);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static const struct v4l2_subdev_pad_ops ds5_depth_pad_ops = {
+	.enum_mbus_code		= ds5_sensor_enum_mbus_code,
+	.enum_frame_size	= ds5_sensor_enum_frame_size,
+	.enum_frame_interval	= ds5_sensor_enum_frame_interval,
+	.get_fmt		= ds5_sensor_get_fmt,
+	.set_fmt		= ds5_sensor_set_fmt,
+};
+
+static int ds5_sensor_s_stream(struct v4l2_subdev *sd, int on)
+{
+	struct ds5_sensor *sensor = container_of(sd, struct ds5_sensor, sd);
+	dev_dbg(sensor->sd.dev,
+			"%s(): sensor: name=%s state=%d\n",
+			__func__, sensor->sd.name, on);
+
+	sensor->streaming = on;
+
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops ds5_sensor_video_ops = {
+	.s_stream		= ds5_sensor_s_stream,
+};
+
+static const struct v4l2_subdev_ops ds5_depth_subdev_ops = {
+	.pad = &ds5_depth_pad_ops,
+	.video = &ds5_sensor_video_ops,
+};
+
+/* Motion detection */
+
+/* FIXME: identical to ds5_depth_pad_ops, use one for both */
+static const struct v4l2_subdev_pad_ops ds5_motion_t_pad_ops = {
+	.enum_mbus_code		= ds5_sensor_enum_mbus_code,
+	.enum_frame_size	= ds5_sensor_enum_frame_size,
+	.enum_frame_interval	= ds5_sensor_enum_frame_interval,
+	.get_fmt		= ds5_sensor_get_fmt,
+	.set_fmt		= ds5_sensor_set_fmt,
+};
+
+static const struct v4l2_subdev_ops ds5_motion_t_subdev_ops = {
+	.pad = &ds5_motion_t_pad_ops,
+	.video = &ds5_sensor_video_ops,
+};
+
+/* FIXME: identical to ds5_depth_pad_ops, use one for both? */
+static const struct v4l2_subdev_pad_ops ds5_rgb_pad_ops = {
+	.enum_mbus_code		= ds5_sensor_enum_mbus_code,
+	.enum_frame_size	= ds5_sensor_enum_frame_size,
+	.enum_frame_interval	= ds5_sensor_enum_frame_interval,
+	.get_fmt		= ds5_sensor_get_fmt,
+	.set_fmt		= ds5_sensor_set_fmt,
+};
+
+static const struct v4l2_subdev_ops ds5_rgb_subdev_ops = {
+	.pad = &ds5_rgb_pad_ops,
+	.video = &ds5_sensor_video_ops,
+};
+
+static const struct v4l2_subdev_pad_ops ds5_imu_pad_ops = {
+	.enum_mbus_code		= ds5_sensor_enum_mbus_code,
+	.enum_frame_size	= ds5_sensor_enum_frame_size,
+	.enum_frame_interval	= ds5_sensor_enum_frame_interval,
+	.get_fmt		= ds5_sensor_get_fmt,
+	.set_fmt		= ds5_sensor_set_fmt,
+};
+
+static const struct v4l2_subdev_ops ds5_imu_subdev_ops = {
+	.pad = &ds5_imu_pad_ops,
+	.video = &ds5_sensor_video_ops,
+};
+
+static int ds5_hw_set_auto_exposure(struct ds5 *state, u32 base, s32 val)
+{
+	if (val != V4L2_EXPOSURE_APERTURE_PRIORITY &&
+			val != V4L2_EXPOSURE_MANUAL)
+		return -EINVAL;
+
+	/*
+	 * In firmware color auto exposure setting follow the uvc_menu_info
+	 * exposure_auto_controls numbers, in drivers/media/usb/uvc/uvc_ctrl.c.
+	 */
+	if (state->is_rgb && val == V4L2_EXPOSURE_APERTURE_PRIORITY)
+		val = 8;
+
+	/*
+	 * In firmware depth auto exposure on: 1, off: 0.
+	 */
+	if (!state->is_rgb) {
+		if (val == V4L2_EXPOSURE_APERTURE_PRIORITY)
+			val = 1;
+		else if (val == V4L2_EXPOSURE_MANUAL)
+			val = 0;
+	}
+
+	return ds5_write(state, base | DS5_AUTO_EXPOSURE_MODE, (u16)val);
+}
+
+/*
+ * Manual exposure in us
+ * Depth/Y8: between 100 and 200000 (200ms)
+ * Color: between 100 and 1000000 (1s)
+ */
+static int ds5_hw_set_exposure(struct ds5 *state, u32 base, s32 val)
+{
+	int ret;
+
+	if (val < 1)
+		val = 1;
+	if ((state->is_depth || state->is_y8) && val > MAX_DEPTH_EXP)
+		val = MAX_DEPTH_EXP;
+	if (state->is_rgb && val > MAX_RGB_EXP)
+		val = MAX_RGB_EXP;
+
+	/*
+	 * Color and depth uses different unit:
+	 *	Color: 1 is 100 us
+	 *	Depth: 1 is 1 us
+	 */
+
+	ret = ds5_write(state, base | DS5_MANUAL_EXPOSURE_MSB, (u16)(val >> 16));
+	if (!ret)
+		ret = ds5_write(state, base | DS5_MANUAL_EXPOSURE_LSB,
+				(u16)(val & 0xffff));
+
+	return ret;
+}
+
+#define DS5_MAX_LOG_WAIT 200
+#define DS5_MAX_LOG_SLEEP 10
+#define DS5_MAX_LOG_POLL (DS5_MAX_LOG_WAIT / DS5_MAX_LOG_SLEEP)
+
+// TODO: why to use DS5_DEPTH_Y_STREAMS_DT?
+#define DS5_CAMERA_CID_BASE	(V4L2_CTRL_CLASS_CAMERA | DS5_DEPTH_STREAM_DT)
+
+#define DS5_CAMERA_CID_LOG			(DS5_CAMERA_CID_BASE+0)
+#define DS5_CAMERA_CID_LASER_POWER		(DS5_CAMERA_CID_BASE+1)
+#define DS5_CAMERA_CID_MANUAL_LASER_POWER	(DS5_CAMERA_CID_BASE+2)
+#define DS5_CAMERA_DEPTH_CALIBRATION_TABLE_GET	(DS5_CAMERA_CID_BASE+3)
+#define DS5_CAMERA_DEPTH_CALIBRATION_TABLE_SET	(DS5_CAMERA_CID_BASE+4)
+#define DS5_CAMERA_COEFF_CALIBRATION_TABLE_GET	(DS5_CAMERA_CID_BASE+5)
+#define DS5_CAMERA_COEFF_CALIBRATION_TABLE_SET	(DS5_CAMERA_CID_BASE+6)
+#define DS5_CAMERA_CID_FW_VERSION		(DS5_CAMERA_CID_BASE+7)
+#define DS5_CAMERA_CID_GVD			(DS5_CAMERA_CID_BASE+8)
+#define DS5_CAMERA_CID_AE_ROI_GET		(DS5_CAMERA_CID_BASE+9)
+#define DS5_CAMERA_CID_AE_ROI_SET		(DS5_CAMERA_CID_BASE+10)
+#define DS5_CAMERA_CID_AE_SETPOINT_GET		(DS5_CAMERA_CID_BASE+11)
+#define DS5_CAMERA_CID_AE_SETPOINT_SET		(DS5_CAMERA_CID_BASE+12)
+#define DS5_CAMERA_CID_ERB			(DS5_CAMERA_CID_BASE+13)
+#define DS5_CAMERA_CID_EWB			(DS5_CAMERA_CID_BASE+14)
+#define DS5_CAMERA_CID_HWMC			(DS5_CAMERA_CID_BASE+15)
+
+#define DS5_CAMERA_CID_PWM			(DS5_CAMERA_CID_BASE+22)
+
+/* the HWMC will remain for legacy tools compatibility,
+ * HWMC_RW used for UVC compatibility*/
+#define DS5_CAMERA_CID_HWMC_RW		(DS5_CAMERA_CID_BASE+32)
+
+static int ds5_send_hwmc(struct ds5 *state, u16 cmdLen, struct hwm_cmd *cmd,
+			 bool isRead, u16 *dataLen)
+{
+	int ret = 0;
+	u16 status = 2;
+	int retries = 100;
+	int errorCode;
+	int iter = retries;
+
+	dev_dbg(&state->client->dev,
+			"%s(): HWMC header: 0x%x, magic: 0x%x, opcode: 0x%x, "
+			"param1: %d, param2: %d, param3: %d, param4: %d\n",
+			__func__, cmd->header, cmd->magic_word, cmd->opcode,
+			cmd->param1, cmd->param2, cmd->param3, cmd->param4);
+
+	ds5_raw_write_with_check(state, 0x4900, cmd, cmdLen);
+
+	ds5_write_with_check(state, 0x490C, 0x01); /* execute cmd */
+	do {
+		if (iter != retries)
+			msleep_range(10);
+		ret = ds5_read(state, 0x4904, &status);
+	} while (iter-- && status != 0);
+
+	if (ret || status != 0) {
+		ds5_raw_read(state, 0x4900, &errorCode, 4);
+		dev_err(&state->client->dev,
+				"%s(): HWMC failed, ret: %d, status: %x, error code: %d\n",
+				__func__, ret, status, errorCode);
+		ret = -EAGAIN;
+	}
+
+	if (isRead) {
+		if (*dataLen == 0) {
+			state->client->addr = 0x10;
+			ret = regmap_raw_read(state->regmap, 0x4908, dataLen, sizeof(u16));
+			if (ret)
+				return -EAGAIN;
+		}
+
+		dev_dbg(&state->client->dev, "%s(): HWMC read len: %d\n",
+				__func__, *dataLen);
+		// First 4 bytes of cmd->Data after read will include opcode
+		ds5_raw_read_with_check(state, 0x4900, cmd->Data, *dataLen);
+
+		/*This is neede for libreealsense, to align there code with UVC*/
+		cmd->Data[1000] = (unsigned char)((*dataLen) & 0x00FF);
+		cmd->Data[1001] = (unsigned char)(((*dataLen) & 0xFF00) >> 8);
+	}
+
+	return 0;
+}
+
+#define DS5_HWMC_DATA			0x4900
+#define DS5_HWMC_STATUS			0x4904
+#define DS5_HWMC_RESP_LEN		0x4908
+#define DS5_HWMC_EXEC			0x490C
+
+#define DS5_HWMC_STATUS_OK		0
+#define DS5_HWMC_STATUS_ERR		1
+#define DS5_HWMC_STATUS_WIP		2
+#define DS5_HWMC_BUFFER_SIZE	1024
+
+static int ds5_get_hwmc(struct ds5 *state, unsigned char *data)
+{
+	int ret = 0;
+	u16 status = DS5_HWMC_STATUS_WIP;
+	int retries = 100;
+	int errorCode;
+	u16 tmp_len = 0;
+	const int SIZE_OF_HW_MONITOR_HEADER = 4;
+
+	memset(data, 0, DS5_HWMC_BUFFER_SIZE);
+
+	do {
+		if (retries != 100)
+			msleep_range(1);
+		ret = ds5_read(state, DS5_HWMC_STATUS, &status);
+	} while (!ret && retries-- && status != DS5_HWMC_STATUS_OK);
+
+	if (ret || status != DS5_HWMC_STATUS_OK) {
+		if (status == DS5_HWMC_STATUS_ERR) {
+			ds5_raw_read(state, DS5_HWMC_DATA, &errorCode, sizeof(errorCode));
+			dev_err(&state->client->dev,
+					"%s(): HWMC failed, ret: %d, error code: %d\n",
+					__func__, ret, errorCode);
+		} else {
+			dev_err(&state->client->dev,
+					"%s(): HWMC failed because of timeout, ret: %d\n",
+					__func__, ret);
+		}
+		return -EAGAIN;
+	}
+
+	state->client->addr = 0x10;
+	ret = regmap_raw_read(state->regmap, DS5_HWMC_RESP_LEN,
+			&tmp_len, sizeof(tmp_len));
+	if (ret)
+		return -EAGAIN;
+
+	if (tmp_len > DS5_HWMC_BUFFER_SIZE)
+		return -ENOBUFS;
+
+	dev_dbg(&state->client->dev,
+			"%s(): HWMC read len: %d, lrs_len: %d\n",
+			__func__, tmp_len, tmp_len - SIZE_OF_HW_MONITOR_HEADER);
+
+	ds5_raw_read_with_check(state, DS5_HWMC_DATA, data, tmp_len);
+
+	/* This is needed for librealsense, to align there code with UVC,
+	 * last word is length - 4 bytes header length */
+	tmp_len -= SIZE_OF_HW_MONITOR_HEADER;
+	data[DS5_HWMC_BUFFER_SIZE - 4] = (unsigned char)(tmp_len & 0x00FF);
+	data[DS5_HWMC_BUFFER_SIZE - 3] = (unsigned char)((tmp_len & 0xFF00) >> 8);
+	data[DS5_HWMC_BUFFER_SIZE - 2] = 0;
+	data[DS5_HWMC_BUFFER_SIZE - 1] = 0;
+
+	return 0;
+}
+
+static int ds5_set_calibration_data(struct ds5 *state,
+		struct hwm_cmd *cmd, u16 length)
+{
+	int ret;
+	int retries = 10;
+	u16 status = 2;
+
+	ds5_raw_write_with_check(state, 0x4900, cmd, length);
+
+	ds5_write_with_check(state, 0x490c, 0x01); /* execute cmd */
+	do {
+		if (retries != 10)
+			msleep_range(200);
+		ret = ds5_read(state, 0x4904, &status);
+	} while (retries-- && status != 0);
+
+	if (ret || status != 0) {
+		dev_err(&state->client->dev,
+				"%s(): Failed to set calibration table %d,"
+				"ret: %d, fw error: %x\n",
+				__func__, cmd->param1, ret, status);
+	}
+
+	return -EINVAL;
+}
+
+static int ds5_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ds5 *state = container_of(ctrl->handler, struct ds5,
+					 ctrls.handler);
+	struct v4l2_subdev *sd = &state->mux.sd.subdev;
+	int ret = 0;
+	u16 base = DS5_DEPTH_CONTROL_BASE;
+
+	if (state->is_rgb)
+		base = DS5_RGB_CONTROL_BASE;
+	else if (state->is_imu)
+		return -EINVAL;
+
+	v4l2_dbg(3, 1, sd, "ctrl: %s, value: %d\n", ctrl->name, ctrl->val);
+
+	mutex_lock(&state->lock);
+
+	switch (ctrl->id) {
+	case V4L2_CID_ANALOGUE_GAIN:
+		ret = ds5_write(state, base | DS5_MANUAL_GAIN, ctrl->val);
+		break;
+
+	case V4L2_CID_EXPOSURE_AUTO:
+		ret = ds5_hw_set_auto_exposure(state, base, ctrl->val);
+		break;
+
+	case V4L2_CID_EXPOSURE_ABSOLUTE:
+		ret = ds5_hw_set_exposure(state, base, ctrl->val);
+		break;
+	case DS5_CAMERA_CID_LASER_POWER:
+		if (!state->is_rgb)
+			ret = ds5_write(state, base | DS5_LASER_POWER,
+					ctrl->val);
+		break;
+	case DS5_CAMERA_CID_MANUAL_LASER_POWER:
+		if (!state->is_rgb)
+			ret = ds5_write(state, base | DS5_MANUAL_LASER_POWER,
+					ctrl->val);
+		break;
+	case DS5_CAMERA_DEPTH_CALIBRATION_TABLE_SET: {
+		struct hwm_cmd *calib_cmd;
+
+		dev_dbg(&state->client->dev,
+				"%s(): DS5_CAMERA_DEPTH_CALIBRATION_TABLE_SET \n",
+				__func__);
+		dev_dbg(&state->client->dev,
+				"%s(): table id: 0x%x\n",
+				__func__, *((u8*)ctrl->p_new.p + 2));
+		if (ctrl->p_new.p && DEPTH_CALIBRATION_ID ==
+				*((u8*)ctrl->p_new.p + 2)) {
+			calib_cmd = devm_kzalloc(&state->client->dev,
+					sizeof(struct hwm_cmd) + 256, GFP_KERNEL);
+			if (!calib_cmd) {
+				dev_err(&state->client->dev,
+						"%s(): Can't allocate memory for 0x%x\n",
+						__func__, ctrl->id);
+				ret = -ENOMEM;
+				break;
+			}
+			memcpy(calib_cmd, &set_calib_data, sizeof (set_calib_data));
+			calib_cmd->header = 276;
+			calib_cmd->param1 = DEPTH_CALIBRATION_ID;
+			memcpy(calib_cmd->Data, (u8*)ctrl->p_new.p , 256);
+			ret = ds5_set_calibration_data(state, calib_cmd,
+					sizeof(struct hwm_cmd) + 256);
+			devm_kfree(&state->client->dev, calib_cmd);
+		}
+		break;
+		}
+	case DS5_CAMERA_COEFF_CALIBRATION_TABLE_SET: {
+			struct hwm_cmd *calib_cmd;
+
+			dev_dbg(&state->client->dev,
+					"%s(): DS5_CAMERA_COEFF_CALIBRATION_TABLE_SET \n",
+					__func__);
+			dev_dbg(&state->client->dev,
+					"%s(): table id %d\n",
+					__func__, *((u8*)ctrl->p_new.p + 2));
+			if (ctrl->p_new.p && COEF_CALIBRATION_ID ==
+					*((u8*)ctrl->p_new.p + 2)) {
+				calib_cmd = devm_kzalloc(&state->client->dev,
+						sizeof(struct hwm_cmd) + 512, GFP_KERNEL);
+				if (!calib_cmd) {
+					dev_err(&state->client->dev,
+							"%s(): Can't allocate memory for 0x%x\n",
+							__func__, ctrl->id);
+					ret = -ENOMEM;
+					break;
+				}
+				memcpy(calib_cmd, &set_calib_data, sizeof (set_calib_data));
+				calib_cmd->header = 532;
+				calib_cmd->param1 = COEF_CALIBRATION_ID;
+				memcpy(calib_cmd->Data, (u8*)ctrl->p_new.p , 512);
+				ret = ds5_set_calibration_data(state, calib_cmd,
+						sizeof(struct hwm_cmd) + 512);
+				devm_kfree(&state->client->dev, calib_cmd);
+			}
+
+		}
+		break;
+	case DS5_CAMERA_CID_AE_ROI_SET: {
+		struct hwm_cmd ae_roi_cmd;
+		memcpy(&ae_roi_cmd, &set_ae_roi, sizeof(ae_roi_cmd));
+		ae_roi_cmd.param1 = *((u16*)ctrl->p_new.p_u16);
+		ae_roi_cmd.param2 = *((u16*)ctrl->p_new.p_u16 + 1);
+		ae_roi_cmd.param3 = *((u16*)ctrl->p_new.p_u16 + 2);
+		ae_roi_cmd.param4 = *((u16*)ctrl->p_new.p_u16 + 3);
+		ret = ds5_send_hwmc(state, sizeof(struct hwm_cmd),
+				&ae_roi_cmd, false, NULL);
+		break;
+		}
+	case DS5_CAMERA_CID_AE_SETPOINT_SET: {
+		struct hwm_cmd *ae_setpoint_cmd;
+		if (ctrl->p_new.p_s32) {
+			dev_dbg(&state->client->dev, "%s():0x%x \n",
+					__func__, *(ctrl->p_new.p_s32));
+			ae_setpoint_cmd = devm_kzalloc(&state->client->dev,
+					sizeof(struct hwm_cmd) + 4, GFP_KERNEL);
+			if (!ae_setpoint_cmd) {
+				dev_err(&state->client->dev,
+						"%s(): Can't allocate memory for 0x%x\n",
+						__func__, ctrl->id);
+				ret = -ENOMEM;
+				break;
+			}
+			memcpy(ae_setpoint_cmd, &set_ae_setpoint, sizeof (set_ae_setpoint));
+			memcpy(ae_setpoint_cmd->Data, (u8*)ctrl->p_new.p_s32 , 4);
+			ret = ds5_send_hwmc(state, sizeof(struct hwm_cmd) + 4,
+					ae_setpoint_cmd, false, NULL);
+			devm_kfree(&state->client->dev, ae_setpoint_cmd);
+		}
+		break;
+	}
+	case DS5_CAMERA_CID_ERB:
+		if (ctrl->p_new.p_u8) {
+			u16 offset = 0;
+			u16 size = 0;
+			struct hwm_cmd *erb_cmd;
+
+			offset = *(ctrl->p_new.p_u8) << 8;
+			offset |= *(ctrl->p_new.p_u8 + 1);
+			size = *(ctrl->p_new.p_u8 + 2) << 8;
+			size |= *(ctrl->p_new.p_u8 + 3);
+
+			dev_dbg(&state->client->dev, "%s(): offset %x, size: %x\n",
+							__func__, offset, size);
+
+			erb_cmd = devm_kzalloc(&state->client->dev,
+					sizeof(struct hwm_cmd) + size, GFP_KERNEL);
+			if (!erb_cmd) {
+				dev_err(&state->client->dev,
+						"%s(): Can't allocate memory for 0x%x\n",
+						__func__, ctrl->id);
+				ret = -ENOMEM;
+				break;
+			}
+			memcpy(erb_cmd, &erb, sizeof(struct hwm_cmd));
+			erb_cmd->param1 = offset;
+			erb_cmd->param2 = size;
+			ret = ds5_send_hwmc(state, sizeof(struct hwm_cmd),
+					erb_cmd, true, &size);
+
+			if (ret) {
+				dev_err(&state->client->dev,
+						"%s(): ERB cmd failed, ret: %d,"
+						"requested size: %d, actual size: %d\n",
+						__func__, ret, erb_cmd->param2, size);
+				devm_kfree(&state->client->dev, erb_cmd);
+				return -EAGAIN;
+			}
+
+			// Actual size returned from FW
+			*(ctrl->p_new.p_u8 + 2) = (size & 0xFF00) >> 8;
+			*(ctrl->p_new.p_u8 + 3) = (size & 0x00FF);
+
+			memcpy(ctrl->p_new.p_u8 + 4, erb_cmd->Data + 4, size - 4);
+			dev_dbg(&state->client->dev, "%s(): 0x%x 0x%x 0x%x 0x%x \n",
+				__func__,
+				*(ctrl->p_new.p_u8),
+				*(ctrl->p_new.p_u8+1),
+				*(ctrl->p_new.p_u8+2),
+				*(ctrl->p_new.p_u8+3));
+			devm_kfree(&state->client->dev, erb_cmd);
+		}
+		break;
+	case DS5_CAMERA_CID_EWB:
+		if (ctrl->p_new.p_u8) {
+			u16 offset = 0;
+			u16 size = 0;
+			struct hwm_cmd *ewb_cmd;
+
+			offset = *((u8*)ctrl->p_new.p_u8) << 8;
+			offset |= *((u8*)ctrl->p_new.p_u8 + 1);
+			size = *((u8*)ctrl->p_new.p_u8 + 2) << 8;
+			size |= *((u8*)ctrl->p_new.p_u8 + 3);
+
+			dev_dbg(&state->client->dev, "%s():0x%x 0x%x 0x%x 0x%x\n",
+					__func__,
+					*((u8*)ctrl->p_new.p_u8),
+					*((u8*)ctrl->p_new.p_u8 + 1),
+					*((u8*)ctrl->p_new.p_u8 + 2),
+					*((u8*)ctrl->p_new.p_u8 + 3));
+
+			ewb_cmd = devm_kzalloc(&state->client->dev,
+					sizeof(struct hwm_cmd) + size,
+					GFP_KERNEL);
+			if (!ewb_cmd) {
+				dev_err(&state->client->dev,
+						"%s(): Can't allocate memory for 0x%x\n",
+						__func__, ctrl->id);
+				ret = -ENOMEM;
+				break;
+			}
+			memcpy(ewb_cmd, &ewb, sizeof (ewb));
+			ewb_cmd->header = 0x14 + size;
+			ewb_cmd->param1 = offset; // start index
+			ewb_cmd->param2 = size; // size
+			memcpy(ewb_cmd->Data, (u8*)ctrl->p_new.p_u8 + 4, size);
+			ret = ds5_send_hwmc(state, sizeof(struct hwm_cmd) + size,
+					ewb_cmd, false, NULL);
+
+			if (ret) {
+				dev_err(&state->client->dev,
+						"%s(): EWB cmd failed, ret: %d,"
+						"requested size: %d, actual size: %d\n",
+						__func__, ret, ewb_cmd->param2, size);
+				devm_kfree(&state->client->dev, ewb_cmd);
+				return -EAGAIN;
+			}
+
+			devm_kfree(&state->client->dev, ewb_cmd);
+		}
+		break;
+	case DS5_CAMERA_CID_HWMC:
+		if (ctrl->p_new.p_u8) {
+			u16 dataLen = 0;
+			u16 size = 0;
+
+			size = *((u8*)ctrl->p_new.p_u8 + 1) << 8;
+			size |= *((u8*)ctrl->p_new.p_u8 + 0);
+			dev_dbg(&state->client->dev,
+					"%s(): HWMC size %d\n",
+					__func__, size);
+			ret = ds5_send_hwmc(state, size + 4,
+					(struct hwm_cmd *)ctrl->p_new.p_u8, true, &dataLen);
+		}
+		break;
+	case DS5_CAMERA_CID_HWMC_RW:
+		if (ctrl->p_new.p_u8) {
+			u16 size = *((u8*)ctrl->p_new.p_u8 + 1) << 8;
+			size |= *((u8*)ctrl->p_new.p_u8 + 0);
+			ret = ds5_send_hwmc(state, size + 4,
+					(struct hwm_cmd *)ctrl->p_new.p_u8, false, NULL);
+		}
+		break;
+	case DS5_CAMERA_CID_PWM:
+		if (state->is_depth)
+			ret = ds5_write(state, base | DS5_PWM_FREQUENCY, ctrl->val);
+		break;
+	}
+
+	mutex_unlock(&state->lock);
+
+	return ret;
+}
+
+static int ds5_get_calibration_data(struct ds5 *state, enum table_id id,
+		unsigned char *table, unsigned int length)
+{
+	struct hwm_cmd *cmd;
+	int ret;
+	int retries = 3;
+	u16 status = 2;
+	u16 table_length;
+
+	cmd = devm_kzalloc(&state->client->dev,
+			sizeof(struct hwm_cmd) + length + 4, GFP_KERNEL);
+	if (!cmd) {
+		dev_err(&state->client->dev, "%s(): Can't allocate memory\n", __func__);
+		return -ENOMEM;
+	}
+
+	memcpy(cmd, &get_calib_data, sizeof(get_calib_data));
+	cmd->param1 = id;
+	ds5_raw_write_with_check(state, 0x4900, cmd, sizeof(struct hwm_cmd));
+	ds5_write_with_check(state, 0x490c, 0x01); /* execute cmd */
+	do {
+		if (retries != 3)
+			msleep_range(10);
+		ret = ds5_read(state, 0x4904, &status);
+	} while (ret && retries-- && status != 0);
+
+	if (ret || status != 0) {
+		dev_err(&state->client->dev,
+				"%s(): Failed to get calibration table %d, fw error: %x\n",
+				__func__, id, status);
+		devm_kfree(&state->client->dev, cmd);
+		return status;
+	}
+
+	// get table length from fw
+	state->client->addr = 0x10;
+	ret = regmap_raw_read(state->regmap, 0x4908,
+			&table_length, sizeof(table_length));
+
+	// read table
+	ds5_raw_read_with_check(state, 0x4900, cmd->Data, table_length);
+
+	// first 4 bytes are opcode HWM, not part of calibration table
+	memcpy(table, cmd->Data + 4, length);
+	devm_kfree(&state->client->dev, cmd);
+	return 0;
+}
+
+static int ds5_gvd(struct ds5 *state, unsigned char *data)
+{
+	struct hwm_cmd cmd;
+	int ret;
+	u16 length = 0;
+	u16 status = 2;
+	u8 retries = 3;
+
+	memcpy(&cmd, &gvd, sizeof(gvd));
+	ds5_raw_write_with_check(state, 0x4900, &cmd, sizeof(cmd));
+	ds5_write_with_check(state, 0x490c, 0x01); /* execute cmd */
+	do {
+		if (retries != 3)
+			msleep_range(10);
+
+		ret = ds5_read(state, 0x4904, &status);
+	} while (ret && retries-- && status != 0);
+
+	if (ret || status != 0) {
+		dev_err(&state->client->dev,
+				"%s(): Failed to read GVD, HWM cmd status: %x\n",
+				__func__, status);
+		return status;
+	}
+
+	state->client->addr = 0x10;
+	ret = regmap_raw_read(state->regmap, 0x4908, &length, sizeof(length));
+	ds5_raw_read_with_check(state, 0x4900, data, length);
+
+	return ret;
+}
+
+
+static int ds5_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ds5 *state = container_of(ctrl->handler, struct ds5,
+			ctrls.handler);
+	u16 log_prepare[] = {0x0014, 0xcdab, 0x000f, 0x0000, 0x0400, 0x0000,
+			0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000};
+	u16 execute_cmd = 0x0001;
+	unsigned int i;
+	u32 data;
+	int ret = 0;
+	u16 base = (state->is_rgb) ? DS5_RGB_CONTROL_BASE : DS5_DEPTH_CONTROL_BASE;
+	u16 reg;
+
+	dev_dbg(&state->client->dev, "%s(): ctrl: %s \n",
+		__func__, ctrl->name);
+
+	switch (ctrl->id) {
+
+	case V4L2_CID_ANALOGUE_GAIN:
+		if (state->is_imu)
+			return -EINVAL;
+		ret = ds5_read(state, base | DS5_MANUAL_GAIN, ctrl->p_new.p_u16);
+		break;
+
+	case V4L2_CID_EXPOSURE_AUTO:
+		if (state->is_imu)
+			return -EINVAL;
+		ds5_read(state, base | DS5_AUTO_EXPOSURE_MODE, &reg);
+		*ctrl->p_new.p_u16 = reg;
+		/* see ds5_hw_set_auto_exposure */
+		if (!state->is_rgb) {
+			if (reg == 1)
+				*ctrl->p_new.p_u16 = V4L2_EXPOSURE_APERTURE_PRIORITY;
+			else if (reg == 0)
+				*ctrl->p_new.p_u16 = V4L2_EXPOSURE_MANUAL;
+		}
+
+		if (state->is_rgb && reg == 8)
+			*ctrl->p_new.p_u16 = V4L2_EXPOSURE_APERTURE_PRIORITY;
+
+		break;
+
+	case V4L2_CID_EXPOSURE_ABSOLUTE:
+		if (state->is_imu)
+			return -EINVAL;
+		/* see ds5_hw_set_exposure */
+		ds5_read(state, base | DS5_MANUAL_EXPOSURE_MSB, &reg);
+		data = ((u32)reg << 16) & 0xffff0000;
+		ds5_read(state, base | DS5_MANUAL_EXPOSURE_LSB, &reg);
+		data |= reg;
+		*ctrl->p_new.p_u32 = data;
+		break;
+
+	case DS5_CAMERA_CID_LASER_POWER:
+		if (!state->is_rgb)
+			ds5_read(state, base | DS5_LASER_POWER, ctrl->p_new.p_u16);
+		break;
+
+	case DS5_CAMERA_CID_MANUAL_LASER_POWER:
+		if (!state->is_rgb)
+			ds5_read(state, base | DS5_MANUAL_LASER_POWER, ctrl->p_new.p_u16);
+		break;
+
+	case DS5_CAMERA_CID_LOG:
+		// TODO: wrap HWMonitor command
+		//       1. prepare and send command
+		//       2. send command
+		//       3. execute command
+		//       4. wait for ccompletion
+		state->client->addr = 0x10;
+		ret = regmap_raw_write(state->regmap, 0x4900,
+				log_prepare, sizeof(log_prepare));
+		if (ret < 0)
+			return ret;
+
+		ret = regmap_raw_write(state->regmap, 0x490C,
+				&execute_cmd, sizeof(execute_cmd));
+		if (ret < 0)
+			return ret;
+
+		for (i = 0; i < DS5_MAX_LOG_POLL; i++) {
+			state->client->addr = 0x10;
+			ret = regmap_raw_read(state->regmap, 0x4904,
+					&data, sizeof(data));
+			dev_dbg(&state->client->dev, "%s(): log ready 0x%x\n",
+				 __func__, data);
+			if (ret < 0)
+				return ret;
+			if (!data)
+				break;
+			msleep_range(5);
+		}
+
+//		if (i == DS5_MAX_LOG_POLL)
+//			return -ETIMEDOUT;
+
+		state->client->addr = 0x10;
+		ret = regmap_raw_read(state->regmap, 0x4908,
+				&data, sizeof(data));
+		dev_dbg(&state->client->dev, "%s(): log size 0x%x\n",
+			 __func__, data);
+		if (ret < 0)
+			return ret;
+		if (!data)
+			return 0;
+		if (data > 1024)
+			return -ENOBUFS;
+		state->client->addr = 0x10;
+		ret = regmap_raw_read(state->regmap, 0x4900,
+				ctrl->p_new.p_u8, data);
+		break;
+	case DS5_CAMERA_DEPTH_CALIBRATION_TABLE_GET:
+		ret = ds5_get_calibration_data(state, DEPTH_CALIBRATION_ID,
+				ctrl->p_new.p_u8, 256);
+		break;
+	case DS5_CAMERA_COEFF_CALIBRATION_TABLE_GET:
+		ret = ds5_get_calibration_data(state, COEF_CALIBRATION_ID,
+				ctrl->p_new.p_u8, 512);
+		break;
+	case DS5_CAMERA_CID_FW_VERSION:
+		ret = ds5_read(state, DS5_FW_VERSION, &state->fw_version);
+		ret = ds5_read(state, DS5_FW_BUILD, &state->fw_build);
+		*ctrl->p_new.p_u32 = state->fw_version << 16;
+		*ctrl->p_new.p_u32 |= state->fw_build;
+		break;
+	case DS5_CAMERA_CID_GVD:
+		ret = ds5_gvd(state, ctrl->p_new.p_u8);
+		break;
+	case DS5_CAMERA_CID_AE_ROI_GET: {
+		u16 len = 0;
+		struct hwm_cmd *ae_roi_cmd;
+		ae_roi_cmd = devm_kzalloc(&state->client->dev,
+				sizeof(struct hwm_cmd) + 12, GFP_KERNEL);
+		if (!ae_roi_cmd) {
+			dev_err(&state->client->dev,
+					"%s(): Can't allocate memory for 0x%x\n",
+					__func__, ctrl->id);
+			ret = -ENOMEM;
+			break;
+		}
+		memcpy(ae_roi_cmd, &get_ae_roi, sizeof(struct hwm_cmd));
+		ret = ds5_send_hwmc(state, sizeof(struct hwm_cmd),
+				ae_roi_cmd, true, &len);
+		memcpy(ctrl->p_new.p_u16, ae_roi_cmd->Data + 4, 8);
+		devm_kfree(&state->client->dev, ae_roi_cmd);
+		}
+		break;
+	case DS5_CAMERA_CID_AE_SETPOINT_GET: {
+		u16 len = 0;
+		struct hwm_cmd *ae_setpoint_cmd;
+		ae_setpoint_cmd = devm_kzalloc(&state->client->dev,
+				sizeof(struct hwm_cmd) + 8, GFP_KERNEL);
+		if (!ae_setpoint_cmd) {
+			dev_err(&state->client->dev,
+					"%s(): Can't allocate memory for 0x%x\n",
+					__func__, ctrl->id);
+			ret = -ENOMEM;
+			break;
+		}
+		memcpy(ae_setpoint_cmd, &get_ae_setpoint, sizeof(struct hwm_cmd));
+		ret = ds5_send_hwmc(state, sizeof(struct hwm_cmd),
+				ae_setpoint_cmd, true, &len);
+		memcpy(ctrl->p_new.p_s32, ae_setpoint_cmd->Data + 4, 4);
+		dev_dbg(&state->client->dev, "%s(): 0x%x \n",
+					__func__,
+					*(ctrl->p_new.p_s32));
+		devm_kfree(&state->client->dev, ae_setpoint_cmd);
+		}
+		break;
+	case DS5_CAMERA_CID_HWMC_RW:
+		ds5_get_hwmc(state, ctrl->p_new.p_u8);
+		break;
+	case DS5_CAMERA_CID_PWM:
+		if (state->is_depth)
+			ds5_read(state, base | DS5_PWM_FREQUENCY, ctrl->p_new.p_u16);
+		break;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops ds5_ctrl_ops = {
+	.s_ctrl	= ds5_s_ctrl,
+	.g_volatile_ctrl = ds5_g_volatile_ctrl,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_log = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_LOG,
+	.name = "Logger",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {1024},
+	.elem_size = sizeof(u8),
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_laser_power = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_LASER_POWER,
+	.name = "Laser power on/off",
+	.type = V4L2_CTRL_TYPE_BOOLEAN,
+	.min = 0,
+	.max = 1,
+	.step = 1,
+	.def = 1,
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_manual_laser_power = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_MANUAL_LASER_POWER,
+	.name = "Manual laser power",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.min = 0,
+	.max = 360,
+	.step = 30,
+	.def = 150,
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_fw_version = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_FW_VERSION,
+	.name = "fw version",
+	.type = V4L2_CTRL_TYPE_U32,
+	.dims = {1},
+	.elem_size = sizeof(u32),
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_gvd = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_GVD,
+	.name = "GVD",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {239},
+	.elem_size = sizeof(u8),
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_get_depth_calib = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_DEPTH_CALIBRATION_TABLE_GET,
+	.name = "get depth calib",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {256},
+	.elem_size = sizeof(u8),
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_set_depth_calib = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_DEPTH_CALIBRATION_TABLE_SET,
+	.name = "set depth calib",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {256},
+	.elem_size = sizeof(u8),
+	.min = 0,
+	.max = 0xFFFFFFFF,
+	.def = 240,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_get_coeff_calib = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_COEFF_CALIBRATION_TABLE_GET,
+	.name = "get coeff calib",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {512},
+	.elem_size = sizeof(u8),
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_set_coeff_calib = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_COEFF_CALIBRATION_TABLE_SET,
+	.name = "set coeff calib",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {512},
+	.elem_size = sizeof(u8),
+	.min = 0,
+	.max = 0xFFFFFFFF,
+	.def = 240,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_ae_roi_get = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_AE_ROI_GET,
+	.name = "ae roi get",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {8},
+	.elem_size = sizeof(u16),
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_ae_roi_set = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_AE_ROI_SET,
+	.name = "ae roi set",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {8},
+	.elem_size = sizeof(u16),
+	.min = 0,
+	.max = 0xFFFFFFFF,
+	.def = 240,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_ae_setpoint_get = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_AE_SETPOINT_GET,
+	.name = "ae setpoint get",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_ae_setpoint_set = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_AE_SETPOINT_SET,
+	.name = "ae setpoint set",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.min = 0,
+	.max = 4095,
+	.step = 1,
+	.def = 0,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_erb = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_ERB,
+	.name = "ERB eeprom read",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {1020},
+	.elem_size = sizeof(u8),
+	.min = 0,
+	.max = 0xFFFFFFFF,
+	.def = 240,
+	.step = 1,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_ewb = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_EWB,
+	.name = "EWB eeprom write",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {1020},
+	.elem_size = sizeof(u8),
+	.min = 0,
+	.max = 0xFFFFFFFF,
+	.def = 240,
+	.step = 1,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_hwmc = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_HWMC,
+	.name = "HWMC",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {DS5_HWMC_BUFFER_SIZE + 4},
+	.elem_size = sizeof(u8),
+	.min = 0,
+	.max = 0xFFFFFFFF,
+	.def = 240,
+	.step = 1,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_hwmc_rw = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_HWMC_RW,
+	.name = "HWMC_RW",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {DS5_HWMC_BUFFER_SIZE},
+	.elem_size = sizeof(u8),
+	.min = 0,
+	.max = 0xFFFFFFFF,
+	.def = 240,
+	.step = 1,
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_pwm = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_PWM,
+	.name = "PWM Frequency Selector",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.min = 0,
+	.max = 1,
+	.step = 1,
+	.def = 1,
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+};
+
+static int ds5_mux_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct ds5 *state = v4l2_get_subdevdata(sd);
+
+	dev_dbg(sd->dev, "%s(): %s (%p)\n", __func__, sd->name, fh);
+	if (state->dfu_dev.dfu_state_flag)
+		return -EBUSY;
+	state->dfu_dev.device_open_count++;
+
+	return 0;
+};
+
+static int ds5_mux_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct ds5 *state = v4l2_get_subdevdata(sd);
+
+	dev_dbg(sd->dev, "%s(): %s (%p)\n", __func__, sd->name, fh);
+	state->dfu_dev.device_open_count--;
+	return 0;
+};
+
+static const struct v4l2_subdev_internal_ops ds5_sensor_internal_ops = {
+	.open = ds5_mux_open,
+	.close = ds5_mux_close,
+};
+
+static int ds5_ctrl_init(struct ds5 *state)
+{
+	const struct v4l2_ctrl_ops *ops = &ds5_ctrl_ops;
+	struct ds5_ctrls *ctrls = &state->ctrls;
+	struct v4l2_ctrl_handler *hdl = &ctrls->handler;
+	struct v4l2_subdev *sd = &state->mux.sd.subdev;
+	int ret;
+
+	if (state->is_imu)
+		return 0;
+
+	ret = v4l2_ctrl_handler_init(hdl, DS5_N_CONTROLS);
+	if (ret < 0) {
+		v4l2_err(sd, "cannot init ctrl handler (%d)\n", ret);
+		return ret;
+	}
+
+	if (state->is_depth || state->is_y8) {
+		ctrls->laser_power = v4l2_ctrl_new_custom(hdl,
+						&ds5_ctrl_laser_power,
+						NULL);
+		ctrls->manual_laser_power = v4l2_ctrl_new_custom(hdl,
+						&ds5_ctrl_manual_laser_power,
+						NULL);
+	}
+
+	/* Total gain */
+	if (state->is_depth || state->is_y8) {
+		ctrls->gain = v4l2_ctrl_new_std(hdl, ops,
+						V4L2_CID_ANALOGUE_GAIN,
+						16, 248, 1, 16);
+	} else if (state->is_rgb) {
+		ctrls->gain = v4l2_ctrl_new_std(hdl, ops,
+						V4L2_CID_ANALOGUE_GAIN,
+						0, 128, 1, 64);
+	}
+
+	if (ctrls->gain)
+		ctrls->gain->flags =
+				V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+
+	ctrls->auto_exp = v4l2_ctrl_new_std_menu(hdl, ops,
+			V4L2_CID_EXPOSURE_AUTO,
+			V4L2_EXPOSURE_APERTURE_PRIORITY,
+			~((1 << V4L2_EXPOSURE_MANUAL) |
+					(1 << V4L2_EXPOSURE_APERTURE_PRIORITY)),
+					V4L2_EXPOSURE_APERTURE_PRIORITY);
+
+	if (ctrls->auto_exp)
+		ctrls->auto_exp->flags |=
+				V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+
+	/* Exposure time: V4L2_CID_EXPOSURE_ABSOLUTE default unit: 100 us. */
+	if (state->is_depth || state->is_y8) {
+		ctrls->exposure = v4l2_ctrl_new_std(hdl, ops,
+					V4L2_CID_EXPOSURE_ABSOLUTE,
+					1, MAX_DEPTH_EXP, 1, DEF_DEPTH_EXP);
+	} else if (state->is_rgb) {
+		ctrls->exposure = v4l2_ctrl_new_std(hdl, ops,
+					V4L2_CID_EXPOSURE_ABSOLUTE,
+					1, MAX_RGB_EXP, 1, DEF_RGB_EXP);
+	}
+
+	if (ctrls->exposure) {
+		ctrls->exposure->flags |=
+				V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+		/* override default int type to u32 to match SKU & UVC */
+		ctrls->exposure->type = V4L2_CTRL_TYPE_U32;
+	}
+
+	if (hdl->error) {
+		v4l2_err(sd, "error creating controls (%d)\n", hdl->error);
+		ret = hdl->error;
+		v4l2_ctrl_handler_free(hdl);
+		return ret;
+	}
+
+	ret = v4l2_ctrl_handler_setup(hdl);
+	if (ret < 0) {
+		dev_err(&state->client->dev,
+			"failed to set default values for controls\n");
+		v4l2_ctrl_handler_free(hdl);
+		return ret;
+	}
+
+	// Add these after v4l2_ctrl_handler_setup so they won't be set up
+	ctrls->log = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_log, NULL);
+	ctrls->fw_version = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_fw_version, NULL);
+	ctrls->gvd = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_gvd, NULL);
+	ctrls->get_depth_calib =
+			v4l2_ctrl_new_custom(hdl, &ds5_ctrl_get_depth_calib, NULL);
+	ctrls->set_depth_calib =
+			v4l2_ctrl_new_custom(hdl, &ds5_ctrl_set_depth_calib, NULL);
+	ctrls->get_coeff_calib =
+			v4l2_ctrl_new_custom(hdl, &ds5_ctrl_get_coeff_calib, NULL);
+	ctrls->set_coeff_calib =
+			v4l2_ctrl_new_custom(hdl, &ds5_ctrl_set_coeff_calib, NULL);
+	ctrls->ae_roi_get = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_ae_roi_get, NULL);
+	ctrls->ae_roi_set = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_ae_roi_set, NULL);
+	ctrls->ae_setpoint_get =
+			v4l2_ctrl_new_custom(hdl, &ds5_ctrl_ae_setpoint_get, NULL);
+	ctrls->ae_setpoint_set =
+			v4l2_ctrl_new_custom(hdl, &ds5_ctrl_ae_setpoint_set, NULL);
+	ctrls->erb = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_erb, NULL);
+	ctrls->ewb = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_ewb, NULL);
+	ctrls->hwmc = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_hwmc, NULL);
+	v4l2_ctrl_new_custom(hdl, &ds5_ctrl_hwmc_rw, NULL);
+
+	if (state->is_depth)
+		v4l2_ctrl_new_custom(hdl, &ds5_ctrl_pwm, NULL);
+
+	state->mux.sd.subdev.ctrl_handler = hdl;
+
+	return 0;
+}
+
+static int ds5_sensor_init(struct i2c_client *c, struct ds5 *state,
+		struct ds5_sensor *sensor, const struct v4l2_subdev_ops *ops,
+		const char *name)
+{
+	struct v4l2_subdev *sd = &sensor->sd;
+	struct media_entity *entity = &sensor->sd.entity;
+	struct media_pad *pad = &sensor->pad;
+	dev_t *dev_num = &state->client->dev.devt;
+
+	dev_dbg(sd->dev, "%s(): %p %s %p %p",
+			__func__, c, c->name, state, state->client);
+
+	v4l2_i2c_subdev_init(sd, c, ops);
+	// See tegracam_v4l2.c tegracam_v4l2subdev_register()
+	// Set owner to NULL so we can unload the driver module
+	sd->owner = NULL;
+	sd->internal_ops = &ds5_sensor_internal_ops;
+	sd->grp_id = *dev_num;
+	v4l2_set_subdevdata(sd, state);
+	snprintf(sd->name, sizeof(sd->name), "D4XX %s %d-%04x",
+		 name, i2c_adapter_id(c->adapter), c->addr);
+
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	pad->flags = MEDIA_PAD_FL_SOURCE;
+	entity->obj_type = MEDIA_ENTITY_TYPE_V4L2_SUBDEV;
+	entity->function = MEDIA_ENT_F_CAM_SENSOR;
+	return media_entity_pads_init(entity, 1, pad);
+}
+
+static int ds5_sensor_register(struct ds5 *state, struct ds5_sensor *sensor)
+{
+	struct v4l2_subdev *sd = &sensor->sd;
+	struct media_entity *entity = &sensor->sd.entity;
+	int ret;
+
+	// FIXME: is async needed?
+	ret = v4l2_device_register_subdev(state->mux.sd.subdev.v4l2_dev, sd);
+	if (ret < 0) {
+		dev_err(sd->dev, "%s(): %d: %d\n", __func__, __LINE__, ret);
+		return ret;
+	}
+
+	ret = media_create_pad_link(entity, 0,
+			&state->mux.sd.subdev.entity, sensor->mux_pad,
+			MEDIA_LNK_FL_IMMUTABLE | MEDIA_LNK_FL_ENABLED);
+	if (ret < 0) {
+		dev_err(sd->dev, "%s(): %d: %d\n", __func__, __LINE__, ret);
+		goto e_sd;
+	}
+
+	dev_dbg(sd->dev, "%s(): 0 -> %d\n", __func__, sensor->mux_pad);
+
+	return 0;
+
+e_sd:
+	v4l2_device_unregister_subdev(sd);
+
+	return ret;
+}
+
+static void ds5_sensor_remove(struct ds5_sensor *sensor)
+{
+	v4l2_device_unregister_subdev(&sensor->sd);
+
+	media_entity_cleanup(&sensor->sd.entity);
+}
+
+static int ds5_depth_init(struct i2c_client *c, struct ds5 *state)
+{
+	/* Which mux pad we're connecting to */
+	state->depth.sensor.mux_pad = DS5_MUX_PAD_DEPTH;
+	return ds5_sensor_init(c, state, &state->depth.sensor,
+			&ds5_depth_subdev_ops, "depth");
+}
+
+static int ds5_motion_t_init(struct i2c_client *c, struct ds5 *state)
+{
+	state->motion_t.sensor.mux_pad = DS5_MUX_PAD_MOTION_T;
+	return ds5_sensor_init(c, state, &state->motion_t.sensor,
+			&ds5_motion_t_subdev_ops, "motion detection");
+}
+
+static int ds5_rgb_init(struct i2c_client *c, struct ds5 *state)
+{
+	state->rgb.sensor.mux_pad = DS5_MUX_PAD_RGB;
+	return ds5_sensor_init(c, state, &state->rgb.sensor,
+			&ds5_rgb_subdev_ops, "rgb");
+}
+
+static int ds5_imu_init(struct i2c_client *c, struct ds5 *state)
+{
+	state->imu.sensor.mux_pad = DS5_MUX_PAD_IMU;
+	return ds5_sensor_init(c, state, &state->imu.sensor,
+			&ds5_imu_subdev_ops, "imu");
+}
+
+/* No locking needed */
+static int ds5_mux_enum_mbus_code(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_mbus_code_enum *mce)
+{
+	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
+	struct v4l2_subdev_mbus_code_enum tmp = *mce;
+	struct v4l2_subdev *remote_sd;
+	int ret;
+
+	switch (mce->pad) {
+	case DS5_MUX_PAD_MOTION_T:
+		remote_sd = &state->motion_t.sensor.sd;
+		break;
+	case DS5_MUX_PAD_DEPTH:
+		remote_sd = &state->depth.sensor.sd;
+		break;
+	case DS5_MUX_PAD_RGB:
+		remote_sd = &state->rgb.sensor.sd;
+		break;
+	case DS5_MUX_PAD_IMU:
+		remote_sd = &state->imu.sensor.sd;
+		break;
+	case DS5_MUX_PAD_EXTERNAL:
+		if (mce->index >= state->motion_t.sensor.n_formats +
+				state->depth.sensor.n_formats)
+			return -EINVAL;
+
+		/*
+		 * First list Left node / Motion Tracker formats, then depth.
+		 * This should also help because D16 doesn't have a direct
+		 * analog in MIPI CSI-2.
+		 */
+		if (mce->index < state->motion_t.sensor.n_formats) {
+			remote_sd = &state->motion_t.sensor.sd;
+		} else {
+			tmp.index = mce->index - state->motion_t.sensor.n_formats;
+			remote_sd = &state->depth.sensor.sd;
+		}
+
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	tmp.pad = 0;
+	if (state->is_rgb)
+		remote_sd = &state->rgb.sensor.sd;
+	if (state->is_depth)
+		remote_sd = &state->depth.sensor.sd;
+	if (state->is_y8)
+		remote_sd = &state->motion_t.sensor.sd;
+	if (state->is_imu)
+		remote_sd = &state->imu.sensor.sd;
+
+	/* Locks internally */
+	ret = ds5_sensor_enum_mbus_code(remote_sd, cfg, &tmp);
+	if (!ret)
+		mce->code = tmp.code;
+
+	return ret;
+}
+
+/* No locking needed */
+static int ds5_mux_enum_frame_size(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
+	struct v4l2_subdev_frame_size_enum tmp = *fse;
+	struct v4l2_subdev *remote_sd;
+	u32 pad = fse->pad;
+	int ret;
+
+	tmp.pad = 0;
+
+	if (state->is_depth)
+		pad = DS5_MUX_PAD_DEPTH;
+	if (state->is_y8)
+		pad = DS5_MUX_PAD_MOTION_T;
+	if (state->is_rgb)
+		pad = DS5_MUX_PAD_RGB;
+	if (state->is_imu)
+		pad = DS5_MUX_PAD_IMU;
+
+	switch (pad) {
+	case DS5_MUX_PAD_MOTION_T:
+		remote_sd = &state->motion_t.sensor.sd;
+		break;
+	case DS5_MUX_PAD_DEPTH:
+		remote_sd = &state->depth.sensor.sd;
+		break;
+	case DS5_MUX_PAD_RGB:
+		remote_sd = &state->rgb.sensor.sd;
+		break;
+	case DS5_MUX_PAD_IMU:
+		remote_sd = &state->imu.sensor.sd;
+		break;
+	case DS5_MUX_PAD_EXTERNAL:
+		/*
+		 * Assume, that different sensors don't support the same formats
+		 * Try the Depth sensor first, then the Motion Tracker
+		 */
+		remote_sd = &state->depth.sensor.sd;
+		ret = ds5_sensor_enum_frame_size(remote_sd, NULL, &tmp);
+		if (!ret) {
+			*fse = tmp;
+			fse->pad = pad;
+			return 0;
+		}
+
+		remote_sd = &state->motion_t.sensor.sd;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* Locks internally */
+	ret = ds5_sensor_enum_frame_size(remote_sd, NULL, &tmp);
+	if (!ret) {
+		*fse = tmp;
+		fse->pad = pad;
+	}
+
+	return ret;
+}
+
+/* No locking needed */
+static int ds5_mux_enum_frame_interval(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_frame_interval_enum *fie)
+{
+	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
+	struct v4l2_subdev_frame_interval_enum tmp = *fie;
+	struct v4l2_subdev *remote_sd;
+	u32 pad = fie->pad;
+	int ret;
+
+	tmp.pad = 0;
+
+	dev_dbg(state->depth.sensor.sd.dev,
+			"%s(): pad %d code %x width %d height %d\n",
+			__func__, pad, tmp.code, tmp.width, tmp.height);
+
+	if (state->is_depth)
+		pad = DS5_MUX_PAD_DEPTH;
+	if (state->is_y8)
+		pad = DS5_MUX_PAD_MOTION_T;
+	if (state->is_rgb)
+		pad = DS5_MUX_PAD_RGB;
+	if (state->is_imu)
+		pad = DS5_MUX_PAD_IMU;
+
+	switch (pad) {
+	case DS5_MUX_PAD_MOTION_T:
+		remote_sd = &state->motion_t.sensor.sd;
+		break;
+	case DS5_MUX_PAD_DEPTH:
+		remote_sd = &state->depth.sensor.sd;
+		break;
+	case DS5_MUX_PAD_RGB:
+		remote_sd = &state->rgb.sensor.sd;
+		break;
+	case DS5_MUX_PAD_IMU:
+		remote_sd = &state->imu.sensor.sd;
+		break;
+	case DS5_MUX_PAD_EXTERNAL:
+		/* Similar to ds5_mux_enum_frame_size() above */
+		if (state->is_rgb)
+			remote_sd = &state->rgb.sensor.sd;
+		else
+			remote_sd = &state->motion_t.sensor.sd;
+		ret = ds5_sensor_enum_frame_interval(remote_sd, NULL, &tmp);
+		if (!ret) {
+			*fie = tmp;
+			fie->pad = pad;
+			return 0;
+		}
+
+		remote_sd = &state->motion_t.sensor.sd;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* Locks internally */
+	ret = ds5_sensor_enum_frame_interval(remote_sd, NULL, &tmp);
+	if (!ret) {
+		*fie = tmp;
+		fie->pad = pad;
+	}
+
+	return ret;
+}
+
+/* No locking needed */
+static int ds5_mux_set_fmt(struct v4l2_subdev *sd, struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_format *fmt)
+{
+	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
+	struct v4l2_subdev_format tmp = *fmt;
+	struct v4l2_subdev *remote_sd;
+	u32 pad = fmt->pad;
+	int ret = 0;
+
+	if (state->is_depth)
+		pad = DS5_MUX_PAD_DEPTH;
+	if (state->is_y8)
+		pad = DS5_MUX_PAD_MOTION_T;
+	if (state->is_rgb)
+		pad = DS5_MUX_PAD_RGB;
+	if (state->is_imu)
+		pad = DS5_MUX_PAD_IMU;
+	//if (!state->is_rgb)
+	//	if (fmt->format.code == MEDIA_BUS_FMT_UYVY8_1X16)
+	//		pad = DS5_MUX_PAD_DEPTH;
+	//	else
+	//		pad = DS5_MUX_PAD_MOTION_T;
+	//else
+	//	pad = DS5_MUX_PAD_RGB;
+
+	dev_dbg(sd->dev, "%s(): pad: %x %x: %ux%u\n",
+			__func__, pad, fmt->format.code,
+			fmt->format.width, fmt->format.height);
+
+	switch (pad) {
+	case DS5_MUX_PAD_MOTION_T:
+		remote_sd = &state->motion_t.sensor.sd;
+		break;
+	case DS5_MUX_PAD_DEPTH:
+		remote_sd = &state->depth.sensor.sd;
+		break;
+	case DS5_MUX_PAD_RGB:
+		remote_sd = &state->rgb.sensor.sd;
+		break;
+	case DS5_MUX_PAD_IMU:
+		remote_sd = &state->imu.sensor.sd;
+		break;
+	case DS5_MUX_PAD_EXTERNAL:
+		if (state->is_rgb)
+			remote_sd = &state->rgb.sensor.sd;
+		else
+			remote_sd = &state->mux.last_set->sd;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	tmp.pad = 0;
+
+	/* Locks internally */
+	ret = ds5_sensor_set_fmt(remote_sd, cfg, &tmp);
+	if (!ret) {
+		*fmt = tmp;
+		fmt->pad = pad;
+	}
+
+	return ret;
+}
+
+/* No locking needed */
+static int ds5_mux_get_fmt(struct v4l2_subdev *sd, struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_format *fmt)
+{
+	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
+	struct v4l2_subdev_format tmp = *fmt;
+	struct v4l2_subdev *remote_sd;
+	u32 pad = fmt->pad;
+	int ret;
+
+	dev_dbg(sd->dev, "%s(): %u %p\n", __func__, pad, state->mux.last_set);
+
+	if (state->is_depth)
+		pad = DS5_MUX_PAD_DEPTH;
+	if (state->is_y8)
+		pad = DS5_MUX_PAD_MOTION_T;
+	if (state->is_rgb)
+		pad = DS5_MUX_PAD_RGB;
+	if (state->is_imu)
+		pad = DS5_MUX_PAD_IMU;
+
+	switch (pad) {
+	case DS5_MUX_PAD_MOTION_T:
+		remote_sd = &state->motion_t.sensor.sd;
+		break;
+	case DS5_MUX_PAD_DEPTH:
+		remote_sd = &state->depth.sensor.sd;
+		break;
+	case DS5_MUX_PAD_EXTERNAL:
+		remote_sd = &state->mux.last_set->sd;
+		break;
+	case DS5_MUX_PAD_RGB:
+		remote_sd = &state->rgb.sensor.sd;
+		break;
+	case DS5_MUX_PAD_IMU:
+		remote_sd = &state->imu.sensor.sd;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+
+	/* Locks internally */
+	ret = ds5_sensor_get_fmt(remote_sd, cfg, &tmp);
+	if (!ret) {
+		*fmt = tmp;
+		fmt->pad = pad;
+	}
+
+	return ret;
+}
+
+/* Video ops */
+static int ds5_mux_g_frame_interval(struct v4l2_subdev *sd,
+		struct v4l2_subdev_frame_interval *fi)
+{
+	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
+	struct ds5_sensor *sensor = NULL;
+
+	if (NULL == sd || NULL == fi)
+		return -EINVAL;
+
+	sensor = state->mux.last_set;
+
+	fi->interval.numerator = 1;
+	fi->interval.denominator = sensor->config.framerate;
+
+	dev_dbg(sd->dev, "%s(): %s %u\n", __func__, sd->name,
+			fi->interval.denominator);
+
+	return 0;
+}
+
+static u16 __ds5_probe_framerate(const struct ds5_resolution *res, u16 target)
+{
+	int i;
+	u16 framerate;
+
+	for (i = 0; i < res->n_framerates; i++) {
+		framerate = res->framerates[i];
+		if (target <= framerate)
+			return framerate;
+	}
+
+	return res->framerates[res->n_framerates - 1];
+}
+
+static int ds5_mux_s_frame_interval(struct v4l2_subdev *sd,
+		struct v4l2_subdev_frame_interval *fi)
+{
+	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
+	struct ds5_sensor *sensor = NULL;
+	u16 framerate = 1;
+
+	if (NULL == sd || NULL == fi || fi->interval.numerator == 0)
+		return -EINVAL;
+
+	sensor = state->mux.last_set;
+
+	framerate = fi->interval.denominator / fi->interval.numerator;
+	framerate = __ds5_probe_framerate(sensor->config.resolution, framerate);
+	sensor->config.framerate = framerate;
+	fi->interval.numerator = 1;
+	fi->interval.denominator = framerate;
+
+	dev_dbg(sd->dev, "%s(): %s %u\n", __func__, sd->name, framerate);
+
+	return 0;
+}
+
+static int ds5_mux_s_stream(struct v4l2_subdev *sd, int on)
+{
+	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
+	u16 streaming, status;
+	int ret = 0;
+	unsigned int i = 0;
+	int restore_val = 0;
+	u16 config_status_base, stream_status_base, stream_id;
+
+	if (state->is_depth) {
+		config_status_base = DS5_DEPTH_CONFIG_STATUS;
+		stream_status_base = DS5_DEPTH_STREAM_STATUS;
+		stream_id = DS5_STREAM_DEPTH;
+	} else if (state->is_rgb) {
+		config_status_base = DS5_RGB_CONFIG_STATUS;
+		stream_status_base = DS5_RGB_STREAM_STATUS;
+		stream_id = DS5_STREAM_RGB;
+	} else if (state->is_y8) {
+		config_status_base = DS5_IR_CONFIG_STATUS;
+		stream_status_base = DS5_IR_STREAM_STATUS;
+		stream_id = DS5_STREAM_IR;
+	} else if (state->is_imu) {
+		config_status_base = DS5_IMU_CONFIG_STATUS;
+		stream_status_base = DS5_IMU_STREAM_STATUS;
+		stream_id = DS5_STREAM_IMU;
+	} else {
+		return -EINVAL;
+	}
+
+	dev_dbg(&state->client->dev, "s_stream for stream %s, on = %d\n",
+			state->mux.last_set->sd.name, on);
+
+	restore_val = state->mux.last_set->streaming;
+	state->mux.last_set->streaming = on;
+
+	if (on) {
+		ret = ds5_configure(state);
+		if (ret)
+			goto restore_s_state;
+
+		ret = ds5_write(state, DS5_START_STOP_STREAM,
+				DS5_STREAM_START | stream_id);
+		if (ret < 0)
+			goto restore_s_state;
+
+		// check streaming status from FW
+		for (i = 0; i < DS5_START_MAX_COUNT; i++) {
+			ds5_read(state, stream_status_base, &streaming);
+			ds5_read(state, config_status_base, &status);
+			if ((status & DS5_STATUS_STREAMING) &&
+					streaming == DS5_STREAM_STREAMING)
+				break;
+
+			msleep_range(DS5_START_POLL_TIME);
+		}
+
+		if (DS5_START_MAX_COUNT == i) {
+			dev_err(&state->client->dev,
+				"start streaming failed, exit on timeout\n");
+			/* notify fw */
+			ret = ds5_write(state, DS5_START_STOP_STREAM,
+					DS5_STREAM_STOP | stream_id);
+			ret = -EAGAIN;
+			goto restore_s_state;
+		} else {
+			dev_dbg(&state->client->dev, "started after %dms\n",
+				i * DS5_START_POLL_TIME);
+		}
+	} else {
+		ret = ds5_write(state, DS5_START_STOP_STREAM,
+				DS5_STREAM_STOP | stream_id);
+		if (ret < 0)
+			goto restore_s_state;
+	}
+
+	ds5_read(state, config_status_base, &status);
+	ds5_read(state, stream_status_base, &streaming);
+	dev_info(&state->client->dev,
+			"%s %s, stream_status 0x%x:%x, config_status 0x%x:%x\n",
+			ds5_get_sensor_name(state),
+			(on)?"START":"STOP",
+			stream_status_base, streaming,
+			config_status_base, status);
+
+	return ret;
+
+restore_s_state:
+	ds5_read(state, config_status_base, &status);
+	dev_err(&state->client->dev,
+			"%s stream toggle failed! %x status 0x%04x\n",
+			ds5_get_sensor_name(state) ,restore_val, status);
+
+	state->mux.last_set->streaming = restore_val;
+
+	return ret;
+}
+
+//static int ds5_set_power(struct ds5 *state, int on)
+//{
+//	int ret = 0;
+//
+//	mutex_lock(&state->lock);
+//
+//	if (state->power != !on) {
+//		mutex_unlock(&state->lock);
+//		return 0;
+//	}
+//
+////	gpio_set_value_cansleep(state->pwdn_gpio, on);
+//
+//	dev_info(&state->client->dev, "%s(): power %d\n", __func__, on);
+//
+//	usleep_range(100, 200);
+//
+//	if (on) {
+//		state->power = true;
+//	} else {
+//		state->power = false;
+//	}
+//
+//	mutex_unlock(&state->lock);
+//
+//	/* TODO: Restore controls when powering on */
+//	//if (on)
+//	//	ret = v4l2_ctrl_handler_setup(&state->ctrls.handler);
+//
+//	return ret;
+//}
+
+/* Core ops */
+/*static int ds5_mux_set_power(struct v4l2_subdev *sd, int on)
+{
+	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
+
+	return ds5_set_power(state, on);
+}*/
+
+static const struct v4l2_subdev_pad_ops ds5_mux_pad_ops = {
+	.enum_mbus_code		= ds5_mux_enum_mbus_code,
+	.enum_frame_size	= ds5_mux_enum_frame_size,
+	.enum_frame_interval	= ds5_mux_enum_frame_interval,
+	.get_fmt		= ds5_mux_get_fmt,
+	.set_fmt		= ds5_mux_set_fmt,
+};
+
+static const struct v4l2_subdev_core_ops ds5_mux_core_ops = {
+	//.s_power = ds5_mux_set_power,
+	.log_status = v4l2_ctrl_subdev_log_status,
+};
+
+static const struct v4l2_subdev_video_ops ds5_mux_video_ops = {
+	.g_frame_interval	= ds5_mux_g_frame_interval,
+	.s_frame_interval	= ds5_mux_s_frame_interval,
+	.s_stream		= ds5_mux_s_stream,
+};
+
+static const struct v4l2_subdev_ops ds5_mux_subdev_ops = {
+	.core = &ds5_mux_core_ops,
+	.pad = &ds5_mux_pad_ops,
+	.video = &ds5_mux_video_ops,
+};
+
+static int ds5_mux_registered(struct v4l2_subdev *sd)
+{
+	struct ds5 *state = v4l2_get_subdevdata(sd);
+	int ret = ds5_sensor_register(state, &state->depth.sensor);
+	if (ret < 0)
+		return ret;
+
+	ret = ds5_sensor_register(state, &state->motion_t.sensor);
+	if (ret < 0)
+		goto e_depth;
+
+	ret = ds5_sensor_register(state, &state->rgb.sensor);
+	if (ret < 0)
+		goto e_rgb;
+
+	ret = ds5_sensor_register(state, &state->imu.sensor);
+	if (ret < 0)
+		goto e_imu;
+
+	return 0;
+
+e_imu:
+	v4l2_device_unregister_subdev(&state->rgb.sensor.sd);
+
+e_rgb:
+	v4l2_device_unregister_subdev(&state->motion_t.sensor.sd);
+
+e_depth:
+	v4l2_device_unregister_subdev(&state->depth.sensor.sd);
+
+	return ret;
+}
+
+static void ds5_mux_unregistered(struct v4l2_subdev *sd)
+{
+	struct ds5 *state = v4l2_get_subdevdata(sd);
+	ds5_sensor_remove(&state->imu.sensor);
+	ds5_sensor_remove(&state->rgb.sensor);
+	ds5_sensor_remove(&state->motion_t.sensor);
+	ds5_sensor_remove(&state->depth.sensor);
+}
+
+static const struct v4l2_subdev_internal_ops ds5_mux_internal_ops = {
+	.open = ds5_mux_open,
+	.close = ds5_mux_close,
+	.registered = ds5_mux_registered,
+	.unregistered = ds5_mux_unregistered,
+};
+
+static int ds5_mux_register(struct i2c_client *c, struct ds5 *state)
+{
+	return v4l2_async_register_subdev(&state->mux.sd.subdev);
+}
+
+static int ds5_hw_init(struct i2c_client *c, struct ds5 *state)
+{
+	struct v4l2_subdev *sd = &state->mux.sd.subdev;
+	u16 mipi_status, n_lanes, phy, drate_min, drate_max;
+	int ret = ds5_read(state, DS5_MIPI_SUPPORT_LINES, &n_lanes);
+	if (!ret)
+		ret = ds5_read(state, DS5_MIPI_SUPPORT_PHY, &phy);
+
+	if (!ret)
+		ret = ds5_read(state, DS5_MIPI_DATARATE_MIN, &drate_min);
+
+	if (!ret)
+		ret = ds5_read(state, DS5_MIPI_DATARATE_MAX, &drate_max);
+
+	if (!ret)
+		dev_info(sd->dev, "%s(): %d: %u lanes, phy %x, data rate %u-%u\n",
+			 __func__, __LINE__, n_lanes, phy, drate_min, drate_max);
+
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+	n_lanes = state->mux.sd.numlanes;
+#else
+	n_lanes = 2;
+#error get lane information
+#endif
+
+	ret = ds5_write(state, DS5_MIPI_LANE_NUMS, n_lanes - 1);
+	if (!ret)
+		ret = ds5_write(state, DS5_MIPI_LANE_DATARATE, MIPI_LANE_RATE);
+
+	ret = ds5_read(state, DS5_MIPI_CONF_STATUS, &mipi_status);
+
+	dev_dbg(sd->dev, "%s(): %d phandle %x node %s status %x\n", __func__, __LINE__,
+		 c->dev.of_node->phandle, c->dev.of_node->full_name, mipi_status);
+
+	return ret;
+}
+
+static int ds5_mux_init(struct i2c_client *c, struct ds5 *state)
+{
+	struct v4l2_subdev *sd = &state->mux.sd.subdev;
+	struct media_entity *entity = &state->mux.sd.subdev.entity;
+	struct media_pad *pads = state->mux.pads, *pad;
+	unsigned int i;
+	int ret;
+
+	v4l2_i2c_subdev_init(sd, c, &ds5_mux_subdev_ops);
+	// See tegracam_v4l2.c tegracam_v4l2subdev_register()
+	// Set owner to NULL so we can unload the driver module
+	sd->owner = NULL;
+	sd->internal_ops = &ds5_mux_internal_ops;
+	v4l2_set_subdevdata(sd, state);
+	snprintf(sd->name, sizeof(sd->name), "DS5 mux %d-%04x",
+		 i2c_adapter_id(c->adapter), c->addr);
+
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	entity->obj_type = MEDIA_ENTITY_TYPE_V4L2_SUBDEV;
+	entity->function = MEDIA_ENT_F_CAM_SENSOR;
+
+	pads[0].flags = MEDIA_PAD_FL_SOURCE;
+	for (i = 1, pad = pads + 1; i < ARRAY_SIZE(state->mux.pads); i++, pad++)
+		pad->flags = MEDIA_PAD_FL_SINK;
+
+	ret = media_entity_pads_init(entity, ARRAY_SIZE(state->mux.pads), pads);
+	if (ret < 0)
+		return ret;
+
+	ret = ds5_ctrl_init(state);
+	if (ret < 0)
+		goto e_entity;
+
+	if (state->is_depth)
+		state->mux.last_set = &state->depth.sensor;
+	else if (state->is_rgb)
+		state->mux.last_set = &state->rgb.sensor;
+	else if (state->is_y8)
+		state->mux.last_set = &state->motion_t.sensor;
+	else
+		state->mux.last_set = &state->imu.sensor;
+
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+	state->mux.sd.dev = &c->dev;
+	ret = camera_common_initialize(&state->mux.sd, "d4xx");
+	if (ret) {
+		dev_err(&c->dev, "Failed to initialize d4xx.\n");
+		goto e_ctrl;
+	}
+#endif
+
+	return 0;
+
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+e_ctrl:
+	v4l2_ctrl_handler_free(sd->ctrl_handler);
+#endif
+e_entity:
+	media_entity_cleanup(entity);
+
+	return ret;
+}
+
+#define USE_Y
+
+static int ds5_fixed_configuration(struct i2c_client *client, struct ds5 *state)
+{
+	struct ds5_sensor *sensor;
+	u16 cfg0 = 0, cfg0_md = 0, cfg1 = 0, cfg1_md = 0;
+	u16 dw = 0, dh = 0, yw = 0, yh = 0, dev_type = 0;
+	int ret;
+
+	ret = ds5_read(state, DS5_DEPTH_STREAM_DT, &cfg0);
+	if (!ret)
+		ret = ds5_read(state, DS5_DEPTH_STREAM_MD, &cfg0_md);
+	if (!ret)
+		ret = ds5_read(state, DS5_DEPTH_RES_WIDTH, &dw);
+	if (!ret)
+		ret = ds5_read(state, DS5_DEPTH_RES_HEIGHT, &dh);
+	if (!ret)
+		ret = ds5_read(state, DS5_IR_STREAM_DT, &cfg1);
+	if (!ret)
+		ret = ds5_read(state, DS5_IR_STREAM_MD, &cfg1_md);
+	if (!ret)
+		ret = ds5_read(state, DS5_IR_RES_WIDTH, &yw);
+	if (!ret)
+		ret = ds5_read(state, DS5_IR_RES_HEIGHT, &yh);
+	if (!ret)
+		ret = ds5_read(state, DS5_DEVICE_TYPE, &dev_type);
+	if (ret < 0)
+		return ret;
+
+	dev_dbg(&client->dev, "%s(): cfg0 %x %ux%u cfg0_md %x %ux%u\n", __func__,
+		 cfg0, dw, dh, cfg0_md, yw, yh);
+
+	dev_dbg(&client->dev, "%s(): cfg1 %x %ux%u cfg1_md %x %ux%u\n", __func__,
+		 cfg1, dw, dh, cfg1_md, yw, yh);
+
+	sensor = &state->depth.sensor;
+	switch (dev_type) {
+	case DS5_DEVICE_TYPE_D43X:
+	case DS5_DEVICE_TYPE_D45X:
+		sensor->formats = ds5_depth_formats_d43x;
+		break;
+	case DS5_DEVICE_TYPE_D46X:
+		sensor->formats = ds5_depth_formats_d46x;
+		break;
+	default:
+		sensor->formats = ds5_depth_formats_d46x;
+	}
+	sensor->n_formats = 1;
+	sensor->mux_pad = DS5_MUX_PAD_DEPTH;
+
+	sensor = &state->motion_t.sensor;
+	sensor->formats = state->variant->formats;
+	sensor->n_formats = state->variant->n_formats;
+	sensor->mux_pad = DS5_MUX_PAD_MOTION_T;
+
+	sensor = &state->rgb.sensor;
+	switch (dev_type) {
+	case DS5_DEVICE_TYPE_D43X:
+	case DS5_DEVICE_TYPE_D46X:
+		sensor->formats = &ds5_onsemi_rgb_format;
+		sensor->n_formats = DS5_ONSEMI_RGB_N_FORMATS;
+		break;
+	case DS5_DEVICE_TYPE_D45X:
+		sensor->formats = &ds5_rlt_rgb_format;
+		sensor->n_formats = DS5_RLT_RGB_N_FORMATS;
+		break;
+	default:
+		sensor->formats = &ds5_onsemi_rgb_format;
+		sensor->n_formats = DS5_ONSEMI_RGB_N_FORMATS;
+	}
+	sensor->mux_pad = DS5_MUX_PAD_RGB;
+
+	sensor = &state->imu.sensor;
+	sensor->formats = ds5_imu_formats;
+	sensor->n_formats = 1;
+	sensor->mux_pad = DS5_MUX_PAD_IMU;
+
+	/* Development: set a configuration during probing */
+	if ((cfg0 & 0xff00) == 0x1800) {
+		/* MIPI CSI-2 YUV420 isn't supported by V4L, reconfigure to Y8 */
+		struct v4l2_subdev_format fmt = {
+			.which = V4L2_SUBDEV_FORMAT_ACTIVE,
+			.pad = 0,
+			/* Use template to fill in .field, .colorspace etc. */
+			.format = ds5_mbus_framefmt_template,
+		};
+
+//#undef USE_Y
+#ifdef USE_Y
+		/* Override .width, .height, .code */
+		fmt.format.width = yw;
+		fmt.format.height = yh;
+		fmt.format.code = MEDIA_BUS_FMT_UYVY8_2X8;
+
+		state->mux.sd.mode_prop_idx = 0;
+		state->motion_t.sensor.streaming = true;
+		state->depth.sensor.streaming = true;
+		ret = __ds5_sensor_set_fmt(state, &state->motion_t.sensor, NULL, &fmt);
+#else
+		fmt.format.width = dw;
+		fmt.format.height = dh;
+		fmt.format.code = MEDIA_BUS_FMT_UYVY8_1X16;
+
+		state->mux.sd.mode_prop_idx = 1;
+		state->motion_t.sensor.streaming = false;
+		state->depth.sensor.streaming = true;
+		ret = __ds5_sensor_set_fmt(state, &state->depth.sensor, NULL, &fmt);
+#endif
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int ds5_parse_cam(struct i2c_client *client, struct ds5 *state)
+{
+	int ret = ds5_fixed_configuration(client, state);
+	if (ret < 0)
+		return ret;
+
+	ds5_sensor_format_init(&state->depth.sensor);
+	ds5_sensor_format_init(&state->motion_t.sensor);
+	ds5_sensor_format_init(&state->rgb.sensor);
+	ds5_sensor_format_init(&state->imu.sensor);
+
+	return 0;
+}
+
+static void ds5_mux_remove(struct ds5 *state)
+{
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+	camera_common_cleanup(&state->mux.sd);
+#endif
+	v4l2_async_unregister_subdev(&state->mux.sd.subdev);
+	v4l2_ctrl_handler_free(state->mux.sd.subdev.ctrl_handler);
+	media_entity_cleanup(&state->mux.sd.subdev.entity);
+}
+
+static const struct regmap_config ds5_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+	.reg_format_endian = REGMAP_ENDIAN_NATIVE,
+	.val_format_endian = REGMAP_ENDIAN_NATIVE,
+};
+
+static int ds5_dfu_wait_for_status(struct ds5 *state)
+{
+	int i, ret = 0;
+	u16 status;
+
+	for (i = 0; i < DS5_START_MAX_COUNT; i++)
+	{
+		ds5_read(state, 0x5000, &status);
+		if (status == 0x0001 || status == 0x0002)
+		{
+			dev_err(&state->client->dev,
+					"%s(): dfu failed status(0x%4x)\n",
+					__func__, status);
+			ret = -EREMOTEIO;
+			break;
+		}
+		if (!status)
+			break;
+		msleep_range(DS5_START_POLL_TIME);
+		}
+
+	return ret;
+};
+
+static int ds5_dfu_switch_to_dfu(struct ds5 *state)
+{
+	int ret;
+	int i = DS5_START_MAX_COUNT;
+	u16 status;
+
+	ds5_raw_write_with_check(state, 0x4900,
+			&cmd_switch_to_dfu, sizeof(cmd_switch_to_dfu));
+	ds5_write_with_check(state, 0x490c, 0x01); /* execute cmd */
+	/*Wait for DFU fw to boot*/
+	do {
+		msleep_range(DS5_START_POLL_TIME*10);
+		ret = ds5_read(state, 0x5000, &status);
+	} while (ret && i-- );
+	return ret;
+};
+
+static int ds5_dfu_wait_for_get_dfu_status(struct ds5 *state,
+		enum dfu_fw_state exp_state)
+{
+	int ret = 0;
+	u16 status,dfu_state_len = 0x0000;
+	unsigned char dfu_asw_buf[DFU_WAIT_RET_LEN];
+	unsigned int dfu_wr_wait_msec = 0;
+	do {
+		ds5_write_with_check(state, 0x5008, 0x0003); // Get Write state
+		do {
+			ds5_read_with_check(state, 0x5000, &status);
+			if (status == 0x0001) {
+				dev_err(&state->client->dev,
+						"%s(): Write status error I2C_STATUS_ERROR(1)\n",
+						__func__);
+				return -EINVAL;
+			} else
+				if (status == 0x0002 && dfu_wr_wait_msec)
+					msleep_range(dfu_wr_wait_msec);
+
+		} while (status);
+
+		ds5_read_with_check(state, 0x5004, &dfu_state_len);
+		if (dfu_state_len != DFU_WAIT_RET_LEN) {
+			dev_err(&state->client->dev,
+					"%s(): Wrong answer len (%d)\n", __func__, dfu_state_len);
+			return -EINVAL;
+		}
+		ds5_raw_read_with_check(state, 0x4e00, &dfu_asw_buf, DFU_WAIT_RET_LEN);
+		if (dfu_asw_buf[0]) {
+			dev_err(&state->client->dev,
+					"%s(): Wrong dfu_status (%d)\n", __func__, dfu_asw_buf[0]);
+			return -EINVAL;
+		}
+		dfu_wr_wait_msec = (((unsigned int)dfu_asw_buf[3]) << 16)
+						| (((unsigned int)dfu_asw_buf[2]) << 8)
+						| dfu_asw_buf[1];
+	} while (dfu_asw_buf[4] == dfuDNBUSY && exp_state == dfuDNLOAD_IDLE);
+
+
+	if (dfu_asw_buf[4] != exp_state) {
+		dev_notice(&state->client->dev,
+				"%s(): Wrong dfu_state (%d) while expected(%d)\n",
+				__func__, dfu_asw_buf[4], exp_state);
+		ret = -EINVAL;
+	}
+	return ret;
+};
+
+static int ds5_dfu_get_dev_info(struct ds5 *state, struct __fw_status *buf)
+{
+	int ret;
+	u16 len = 0;
+
+	ret = ds5_write(state, 0x5008, 0x0002); //Upload DFU cmd
+	if (!ret)
+		ret = ds5_dfu_wait_for_status(state);
+	if (!ret)
+		ds5_read_with_check(state, 0x5004, &len);
+	/*Sanity check*/
+	if (len == sizeof(struct __fw_status)) {
+		ds5_raw_read_with_check(state, 0x4e00, buf, len);
+	} else {
+		dev_err(&state->client->dev,
+				"%s(): Wrong state size (%d)\n",
+				__func__, len);
+		ret = -EINVAL;
+	}
+	return ret;
+};
+
+static int ds5_dfu_detach(struct ds5 *state)
+{
+	int ret;
+	struct __fw_status buf = {0};
+
+	ds5_write_with_check(state, 0x500c, 0x00);
+	ret = ds5_dfu_wait_for_get_dfu_status(state, dfuIDLE);
+	if (!ret)
+		ret = ds5_dfu_get_dev_info(state, &buf);
+	dev_notice(&state->client->dev, "%s():DFU ver (0x%x) recieved\n",
+			__func__, buf.DFU_version);
+	dev_notice(&state->client->dev, "%s():FW last version (0x%x) recieved\n",
+			__func__, buf.FW_lastVersion);
+	dev_notice(&state->client->dev, "%s():FW status (%s)\n",
+			__func__, buf.DFU_isLocked ? "locked" : "unlocked");
+	return ret;
+};
+
+/* When a process reads from our device, this gets called. */
+static ssize_t ds5_dfu_device_read(struct file *flip,
+		char __user *buffer, size_t len, loff_t *offset)
+{
+	struct ds5 *state = flip->private_data;
+	u16 fw_ver, fw_build;
+	char msg[32];
+	int ret = 0;
+
+	if (mutex_lock_interruptible(&state->lock))
+		return -ERESTARTSYS;
+	ret |= ds5_read(state, DS5_FW_VERSION, &fw_ver);
+	ret |= ds5_read(state, DS5_FW_BUILD, &fw_build);
+	if (ret < 0)
+		goto e_dfu_read_failed;
+	snprintf(msg, sizeof(msg) ,"DFU info: \tver:  %d.%d.%d.%d\n",
+			(fw_ver >> 8) & 0xff, fw_ver & 0xff,
+			(fw_build >> 8) & 0xff, fw_build & 0xff);
+
+	if (copy_to_user(buffer, msg, strlen(msg)))
+		ret = -EFAULT;
+	else {
+		state->dfu_dev.msg_write_once = ~state->dfu_dev.msg_write_once;
+		ret = strlen(msg) & state->dfu_dev.msg_write_once;
+	}
+
+e_dfu_read_failed:
+	mutex_unlock(&state->lock);
+	return ret;
+};
+
+static ssize_t ds5_dfu_device_write(struct file *flip,
+		const char __user *buffer, size_t len, loff_t *offset)
+{
+	struct ds5 *state = flip->private_data;
+	int ret = 0;
+
+	if (mutex_lock_interruptible(&state->lock))
+		return -ERESTARTSYS;
+	switch (state->dfu_dev.dfu_state_flag) {
+
+	case DS5_DFU_OPEN:
+		ret = ds5_dfu_switch_to_dfu(state);
+		if (ret < 0) {
+			dev_err(&state->client->dev, "%s(): Switch to dfu failed (%d)\n",
+					__func__, ret);
+			goto dfu_write_error;
+		}
+		/*fallthrough - procceed to recovery*/
+	case DS5_DFU_RECOVERY:
+		ret = ds5_dfu_detach(state);
+		if (ret < 0) {
+			dev_err(&state->client->dev, "%s(): Detach failed (%d)\n",
+					__func__, ret);
+			goto dfu_write_error;
+		}
+		state->dfu_dev.dfu_state_flag = DS5_DFU_IN_PROGRESS;
+		state->dfu_dev.init_v4l_f = 1;
+
+		/*fallthrough - procceed to download*/
+	case DS5_DFU_IN_PROGRESS: {
+		unsigned int dfu_full_blocks = len / DFU_BLOCK_SIZE;
+		unsigned int dfu_part_blocks = len % DFU_BLOCK_SIZE;
+
+		while (dfu_full_blocks--) {
+			if(copy_from_user(state->dfu_dev.dfu_msg, buffer, DFU_BLOCK_SIZE)) {
+				ret = -EFAULT;
+				goto dfu_write_error;
+			}
+			ret = ds5_raw_write(state, 0x4a00,
+					state->dfu_dev.dfu_msg, DFU_BLOCK_SIZE);
+			if (ret < 0)
+				goto dfu_write_error;
+			ret = ds5_dfu_wait_for_get_dfu_status (state, dfuDNLOAD_IDLE);
+			if (ret < 0)
+				goto dfu_write_error;
+			buffer += DFU_BLOCK_SIZE;
+		}
+		if(copy_from_user(state->dfu_dev.dfu_msg , buffer, dfu_part_blocks)) {
+				ret = -EFAULT;
+				goto dfu_write_error;
+		}
+		if (dfu_part_blocks) {
+			ret = ds5_raw_write(state, 0x4a00,
+					state->dfu_dev.dfu_msg, dfu_part_blocks);
+			if (!ret) {
+				ret = ds5_dfu_wait_for_get_dfu_status (state, dfuDNLOAD_IDLE);
+			}
+			if (!ret)
+				ret = ds5_write(state, 0x4a04, 0x00); /*Download complete */
+			if (!ret)
+				ret = ds5_dfu_wait_for_get_dfu_status (state, dfuMANIFEST);
+			if (ret < 0)
+				goto dfu_write_error;
+			state->dfu_dev.dfu_state_flag = DS5_DFU_DONE;
+		}
+		dev_notice(&state->client->dev, "%s(): DFU block (%d) bytes written\n",
+				__func__, (int)len);
+		break;
+	}
+	default:
+		dev_err(&state->client->dev, "%s(): Wrong state (%d)\n",
+				__func__, state->dfu_dev.dfu_state_flag);
+		ret = -EINVAL;
+		goto dfu_write_error;
+
+	};
+	mutex_unlock(&state->lock);
+	return len;
+
+dfu_write_error:
+	state->dfu_dev.dfu_state_flag = DS5_DFU_ERROR;
+	// Reset DFU device to IDLE states
+	ret = ds5_write(state, 0x5010, 0x0);
+	if (!ret)
+		state->dfu_dev.dfu_state_flag = DS5_DFU_IDLE;
+	mutex_unlock(&state->lock);
+	return ret;
+};
+
+static int ds5_dfu_device_open(struct inode *inode, struct file *file)
+{
+	struct ds5 *state = container_of(inode->i_cdev, struct ds5,
+			dfu_dev.ds5_cdev);
+	struct i2c_adapter *parent = i2c_parent_is_i2c_adapter(
+			state->client->adapter);
+
+	if (state->dfu_dev.device_open_count)
+		return -EBUSY;
+	state->dfu_dev.device_open_count++;
+	if (state->dfu_dev.dfu_state_flag != DS5_DFU_RECOVERY)
+		state->dfu_dev.dfu_state_flag = DS5_DFU_OPEN;
+	state->dfu_dev.dfu_msg = devm_kzalloc(&state->client->dev,
+			DFU_BLOCK_SIZE, GFP_KERNEL);
+	if (!state->dfu_dev.dfu_msg)
+		return -ENOMEM;
+
+	file->private_data = state;
+
+	/* get i2c controller and set dfu bus clock rate */
+	while (parent && i2c_parent_is_i2c_adapter(parent))
+		parent = i2c_parent_is_i2c_adapter(state->client->adapter);
+
+	if (!parent)
+		return 0;
+
+	dev_dbg(&state->client->dev, "%s(): i2c-%d bus_clk = %d, set %d\n",
+			__func__,
+			i2c_adapter_id(parent),
+			i2c_get_adapter_bus_clk_rate(parent),
+			DFU_I2C_BUS_CLK_RATE);
+
+	state->dfu_dev.bus_clk_rate = i2c_get_adapter_bus_clk_rate(parent);
+	i2c_set_adapter_bus_clk_rate(parent, DFU_I2C_BUS_CLK_RATE);
+	return 0;
+};
+
+static int ds5_v4l_init(struct i2c_client *c, struct ds5 *state)
+{
+	int ret;
+
+	ret = ds5_parse_cam(c, state);
+	if (ret < 0)
+		return ret;
+
+	ret = ds5_depth_init(c, state);
+	if (ret < 0)
+		return ret;
+
+	ret = ds5_motion_t_init(c, state);
+	if (ret < 0)
+		goto e_depth;
+
+	ret = ds5_rgb_init(c, state);
+	if (ret < 0)
+		goto e_motion_t;
+
+	ret = ds5_imu_init(c, state);
+	if (ret < 0)
+		goto e_rgb;
+
+	ret = ds5_mux_init(c, state);
+	if (ret < 0)
+		goto e_imu;
+
+	ret = ds5_hw_init(c, state);
+	if (ret < 0)
+		goto e_mux;
+
+	ret = ds5_mux_register(c, state);
+	if (ret < 0)
+		goto e_mux;
+
+	return 0;
+e_mux:
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+	camera_common_cleanup(&state->mux.sd);
+#endif
+	v4l2_ctrl_handler_free(state->mux.sd.subdev.ctrl_handler);
+	media_entity_cleanup(&state->mux.sd.subdev.entity);
+e_imu:
+	media_entity_cleanup(&state->imu.sensor.sd.entity);
+e_rgb:
+	media_entity_cleanup(&state->rgb.sensor.sd.entity);
+e_motion_t:
+	media_entity_cleanup(&state->motion_t.sensor.sd.entity);
+e_depth:
+	media_entity_cleanup(&state->depth.sensor.sd.entity);
+	return ret;
+}
+
+static int ds5_dfu_device_release(struct inode *inode, struct file *file)
+{
+	struct ds5 *state = container_of(inode->i_cdev, struct ds5, dfu_dev.ds5_cdev);
+	struct i2c_adapter *parent = i2c_parent_is_i2c_adapter(
+			state->client->adapter);
+
+	state->dfu_dev.device_open_count--;
+	if (state->dfu_dev.dfu_state_flag != DS5_DFU_RECOVERY)
+		state->dfu_dev.dfu_state_flag = DS5_DFU_IDLE;
+	if (state->dfu_dev.dfu_state_flag == DS5_DFU_DONE
+			&& state->dfu_dev.init_v4l_f)
+		ds5_v4l_init(state->client, state);
+	state->dfu_dev.init_v4l_f = 0;
+	if (state->dfu_dev.dfu_msg)
+		devm_kfree(&state->client->dev, state->dfu_dev.dfu_msg);
+	state->dfu_dev.dfu_msg = NULL;
+
+	/* get i2c controller and restore bus clock rate */
+	while (parent && i2c_parent_is_i2c_adapter(parent))
+		parent = i2c_parent_is_i2c_adapter(state->client->adapter);
+	if (!parent)
+		return 0;
+	dev_dbg(&state->client->dev, "%s(): i2c-%d bus_clk %d, restore to %d\n",
+			__func__, i2c_adapter_id(parent),
+			i2c_get_adapter_bus_clk_rate(parent),
+			state->dfu_dev.bus_clk_rate);
+
+	i2c_set_adapter_bus_clk_rate(parent, state->dfu_dev.bus_clk_rate);
+	return 0;
+};
+
+static const struct file_operations ds5_device_file_ops = {
+	.owner = THIS_MODULE,
+	.read = &ds5_dfu_device_read,
+	.write = &ds5_dfu_device_write,
+	.open = &ds5_dfu_device_open,
+	.release = &ds5_dfu_device_release
+};
+
+struct class* g_ds5_class;
+atomic_t primary_chardev=ATOMIC_INIT(0);
+
+static int ds5_chrdev_init(struct i2c_client *c, struct ds5 *state)
+{
+	struct cdev *ds5_cdev = &state->dfu_dev.ds5_cdev;
+	struct class* *ds5_class = &state->dfu_dev.ds5_class;
+	struct device *chr_dev;
+	char dev_name[sizeof(DS5_DRIVER_NAME_DFU) +5];
+	dev_t *dev_num = &c->dev.devt;
+	int ret;
+
+	dev_dbg(&c->dev, "%s()\n", __func__);
+	/* Request the kernel for N_MINOR devices */
+	ret = alloc_chrdev_region(dev_num, 0, 1, DS5_DRIVER_NAME_DFU);
+	if (ret < 0)
+		return ret;
+
+	if (!atomic_cmpxchg (&primary_chardev, 0, MAJOR(*dev_num))) {
+		dev_dbg(&c->dev, "%s(): <Major, Minor>: <%d, %d>\n",
+				__func__, MAJOR(*dev_num), MINOR(*dev_num));
+		/* Create a class : appears at /sys/class */
+		*ds5_class = class_create(THIS_MODULE, DS5_DRIVER_NAME_CLASS);
+		if (IS_ERR(*ds5_class)) {
+			dev_err(&c->dev, "Could not create class device\n");
+			unregister_chrdev_region(0, 1);
+			ret = PTR_ERR(*ds5_class);
+			return ret;
+		}
+		g_ds5_class = *ds5_class;
+	} else
+		*ds5_class = g_ds5_class;
+	/* Associate the cdev with a set of file_operations */
+	cdev_init(ds5_cdev, &ds5_device_file_ops);
+	/* Build up the current device number. To be used further */
+	*dev_num = MKDEV(MAJOR(*dev_num), MINOR(*dev_num));
+	/* Create a device node for this device. */
+	snprintf (dev_name, sizeof(dev_name), "%s%d",
+			DS5_DRIVER_NAME_DFU, MAJOR(*dev_num));
+	chr_dev = device_create(*ds5_class, NULL, *dev_num, NULL, dev_name);
+	if (IS_ERR(chr_dev)) {
+		ret = PTR_ERR(chr_dev);
+		dev_err(&c->dev,"Could not create device\n");
+		class_destroy(*ds5_class);
+		unregister_chrdev_region(0, 1);
+		return ret;
+	}
+	cdev_add(ds5_cdev, *dev_num, 1);
+	return 0;
+};
+
+static int ds5_chrdev_remove(struct ds5 *state)
+{
+	struct class* *ds5_class = &state->dfu_dev.ds5_class;
+	dev_t *dev_num = &state->client->dev.devt;
+
+	dev_dbg(&state->client->dev, "%s()\n", __func__);
+	unregister_chrdev_region(*dev_num, 1);
+	device_destroy(*ds5_class, *dev_num);
+	if (atomic_cmpxchg (&primary_chardev, MAJOR(*dev_num), 0) == MAJOR(*dev_num))
+		class_destroy(*ds5_class);
+	return 0;
+}
+
+/* SYSFS attributes */
+
+static ssize_t ds5_fw_ver_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *c = to_i2c_client(dev);
+	struct ds5 *state = container_of(i2c_get_clientdata(c),
+			struct ds5, mux.sd.subdev);
+
+	ds5_read(state, DS5_FW_VERSION, &state->fw_version);
+	ds5_read(state, DS5_FW_BUILD, &state->fw_build);
+
+	return snprintf(buf, PAGE_SIZE, "D4XX Sensor: %s, Version: %d.%d.%d.%d\n",
+			ds5_get_sensor_name(state),
+			(state->fw_version >> 8) & 0xff, state->fw_version & 0xff,
+			(state->fw_build >> 8) & 0xff, state->fw_build & 0xff);
+}
+
+static DEVICE_ATTR_RO(ds5_fw_ver);
+
+/* Derive 'device_attribute' structure for a read register's attribute */
+struct dev_ds5_reg_attribute {
+	struct device_attribute attr;
+	u16 reg;	// register
+	u8 valid;	// validity of above data
+};
+
+/** Read DS5 register.
+ * ds5_read_reg_show will actually read register from ds5 while
+ * ds5_read_reg_store will store register to read
+ * Example:
+ * echo -n "0xc03c" >ds5_read_reg
+ * Read register result:
+ * cat ds5_read_reg
+ * Expected:
+ * reg:0xc93c, result:0x11
+ */
+static ssize_t ds5_read_reg_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	u16 rbuf;
+	int n;
+	struct i2c_client *c = to_i2c_client(dev);
+	struct ds5 *state = container_of(i2c_get_clientdata(c),
+			struct ds5, mux.sd.subdev);
+	struct dev_ds5_reg_attribute *ds5_rw_attr = container_of(attr,
+			struct dev_ds5_reg_attribute, attr);
+	if (ds5_rw_attr->valid != 1)
+		return -EINVAL;
+	ds5_read(state, ds5_rw_attr->reg, &rbuf);
+
+	n = snprintf(buf, PAGE_SIZE, "register:0x%4x, value:0x%02x\n",
+			ds5_rw_attr->reg, rbuf);
+
+	return n;
+}
+
+/** Read DS5 register - Store reg to attr struct pointer
+ * ds5_read_reg_show will actually read register from ds5 while
+ * ds5_read_reg_store will store module, offset and length
+ */
+static ssize_t ds5_read_reg_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct dev_ds5_reg_attribute *ds5_rw_attr = container_of(attr,
+			struct dev_ds5_reg_attribute, attr);
+	int rc = -1;
+	u32 reg;
+	ds5_rw_attr->valid = 0;
+	/* Decode input */
+	rc = sscanf(buf, "0x%04x", &reg);
+	if (rc != 1)
+		return -EINVAL;
+	ds5_rw_attr->reg = reg;
+	ds5_rw_attr->valid = 1;
+	return count;
+}
+
+#define DS5_RW_REG_ATTR(_name) \
+		struct dev_ds5_reg_attribute dev_attr_##_name = { \
+				__ATTR(_name, S_IRUGO | S_IWUSR, \
+						ds5_read_reg_show, ds5_read_reg_store), \
+						0, 0 }
+
+static DS5_RW_REG_ATTR(ds5_read_reg);
+
+static ssize_t ds5_write_reg_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct i2c_client *c = to_i2c_client(dev);
+	struct ds5 *state = container_of(i2c_get_clientdata(c),
+			struct ds5, mux.sd.subdev);
+
+	int rc = -1;
+	u32 reg, w_val = 0;
+	u16 val = -1;
+	/* Decode input */
+	rc = sscanf(buf, "0x%04x 0x%04x", &reg, &w_val);
+	if (rc != 2)
+		return -EINVAL;
+	val = w_val & 0xffff;
+	mutex_lock(&state->lock);
+	ds5_write(state, reg, val);
+	mutex_unlock(&state->lock);
+	return count;
+}
+
+static DEVICE_ATTR_WO(ds5_write_reg);
+
+static struct attribute *ds5_attributes[] = {
+		&dev_attr_ds5_fw_ver.attr,
+		&dev_attr_ds5_read_reg.attr.attr,
+		&dev_attr_ds5_write_reg.attr,
+		NULL
+};
+
+static const struct attribute_group ds5_attr_group = {
+	.attrs = ds5_attributes,
+};
+
+static int ds5_probe(struct i2c_client *c, const struct i2c_device_id *id)
+{
+	struct ds5 *state = devm_kzalloc(&c->dev, sizeof(*state), GFP_KERNEL);
+	u16 rec_state;
+	int ret, err = 0;
+	const char *str;
+
+	if (!state)
+		return -ENOMEM;
+
+	mutex_init(&state->lock);
+
+
+	state->client = c;
+	dev_warn(&c->dev, "Probing new driver for D45x\n");
+	state->variant = ds5_variants + id->driver_data;
+
+	state->vcc = devm_regulator_get(&c->dev, "vcc");
+	if (IS_ERR(state->vcc)) {
+		ret = PTR_ERR(state->vcc);
+		dev_warn(&c->dev, "failed %d to get vcc regulator\n", ret);
+		return ret;
+	}
+
+	if (state->vcc) {
+		ret = regulator_enable(state->vcc);
+		if (ret < 0) {
+			dev_warn(&c->dev, "failed %d to enable the vcc regulator\n", ret);
+			return ret;
+		}
+	}
+	state->regmap = devm_regmap_init_i2c(c, &ds5_regmap_config);
+	if (IS_ERR(state->regmap)) {
+		ret = PTR_ERR(state->regmap);
+		dev_err(&c->dev, "regmap init failed: %d\n", ret);
+		goto e_regulator;
+	}
+	ret = ds5_chrdev_init(c, state);
+	if (ret < 0)
+		goto e_regulator;
+	ret = ds5_read(state, 0x5020, &rec_state);
+	if (ret < 0) {
+		dev_err(&c->dev, "%s(): cannot communicate with D4XX: %d\n",
+				__func__, ret);
+		goto e_chardev;
+	}
+
+	if (rec_state == 0x201) {
+		dev_info(&c->dev, "%s(): D4XX recovery state\n", __func__);
+		state->dfu_dev.dfu_state_flag = DS5_DFU_RECOVERY;
+		return 0;
+	}
+
+	state->is_depth = 0;
+	state->is_y8 = 0;
+	state->is_rgb = 0;
+	state->is_imu = 0;
+
+	err = of_property_read_string(c->dev.of_node, "cam-type",
+			&str);
+	if (!err && !strncmp(str, "Depth", strlen("Depth")))
+		state->is_depth = 1;
+	if (!err && !strncmp(str, "Y8", strlen("Y8")))
+		state->is_y8 = 1;
+	if (!err && !strncmp(str, "RGB", strlen("RGB")))
+		state->is_rgb = 1;
+	if (!err && !strncmp(str, "IMU", strlen("IMU")))
+		state->is_imu = 1;
+
+	ds5_read_with_check(state, DS5_FW_VERSION, &state->fw_version);
+	ds5_read_with_check(state, DS5_FW_BUILD, &state->fw_build);
+
+	dev_info(&c->dev, "D4XX Sensor: %s, firmware build: %d.%d.%d.%d\n",
+			ds5_get_sensor_name(state),
+			(state->fw_version >> 8) & 0xff, state->fw_version & 0xff,
+			(state->fw_build >> 8) & 0xff, state->fw_build & 0xff);
+
+	ret = ds5_v4l_init(c, state);
+	if (ret < 0)
+		goto e_chardev;
+	/* DONOT!! Override I2C drvdata */
+//	i2c_set_clientdata(c, state);
+
+/*	regulators? clocks?
+	devm_regulator_bulk_get(&c->dev, DS5_N_SUPPLIES, state->supplies);
+	state->clock = devm_clk_get(&c->dev, DS5_CLK_NAME);
+	if (IS_ERR(state->clock)) {
+		ret = -EPROBE_DEFER;
+		goto err;
+	}
+*/
+	/* Custom sysfs attributes */
+	/* create the sysfs file group */
+	err = sysfs_create_group(&state->client->dev.kobj, &ds5_attr_group);
+
+	return 0;
+
+e_chardev:
+	ds5_chrdev_remove(state);
+e_regulator:
+	if (state->vcc)
+		regulator_disable(state->vcc);
+	return ret;
+}
+
+static int ds5_remove(struct i2c_client *c)
+{
+	struct ds5 *state = container_of(i2c_get_clientdata(c), struct ds5, mux.sd.subdev);
+
+	dev_info(&c->dev, "D4XX remove %s\n",
+			ds5_get_sensor_name(state));
+	if (state->vcc)
+		regulator_disable(state->vcc);
+//	gpio_free(state->pwdn_gpio);
+	ds5_chrdev_remove(state);
+	if (state->dfu_dev.dfu_state_flag != DS5_DFU_RECOVERY) {
+		sysfs_remove_group(&c->dev.kobj, &ds5_attr_group);
+		ds5_mux_remove(state);
+	}
+	return 0;
+}
+
+static const struct i2c_device_id ds5_id[] = {
+	{ DS5_DRIVER_NAME, DS5_DS5U },
+	{ DS5_DRIVER_NAME_ASR, DS5_ASR },
+	{ DS5_DRIVER_NAME_AWG, DS5_AWG },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, ds5_id);
+
+static struct i2c_driver ds5_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = DS5_DRIVER_NAME
+	},
+	.probe		= ds5_probe,
+	.remove		= ds5_remove,
+	.id_table	= ds5_id,
+};
+
+module_i2c_driver(ds5_i2c_driver);
+
+MODULE_DESCRIPTION("Intel RealSense D4XX Camera Driver");
+MODULE_AUTHOR( "Guennadi Liakhovetski <guennadi.liakhovetski@intel.com>,\n\
+				Nael Masalha <nael.masalha@intel.com>,\n\
+				Alexander Gantman <alexander.gantman@intel.com>,\n\
+				Emil Jahshan <emil.jahshan@intel.com>,\n\
+				Xin Zhang <xin.x.zhang@intel.com>,\n\
+				Qingwu Zhang <qingwu.zhang@intel.com>,\n\
+				Evgeni Raikhel <evgeni.raikhel@intel.com>,\n\
+				Shikun Ding <shikun.ding@intel.com>");
+MODULE_AUTHOR("Dmitry Perchanov <dmitry.perchanov@intel.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("1.0.1.14");
diff -urN ori/kernel/nvidia/drivers/media/i2c/Kconfig intel/kernel/nvidia/drivers/media/i2c/Kconfig
--- ori/kernel/nvidia/drivers/media/i2c/Kconfig	2022-08-11 11:15:42.000000000 +0800
+++ intel/kernel/nvidia/drivers/media/i2c/Kconfig	2023-04-10 17:17:16.063081193 +0800
@@ -184,6 +184,16 @@
 
 	  To compile this driver as a module, choose M here: the module
 	  will be called hawk_owl.
+config VIDEO_D4XX
+	tristate "D4XX camera sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	help
+		This is a Video4Linux2 sensor-level driver for the Intel
+		D4XX depth camera sensor
+
+		To compile this driver as a module, choose M here: the module
+		will be called d4xx.
+
 endmenu
 
 endif
diff -urN ori/kernel/nvidia/drivers/media/i2c/Makefile intel/kernel/nvidia/drivers/media/i2c/Makefile
--- ori/kernel/nvidia/drivers/media/i2c/Makefile	2022-08-11 11:15:42.000000000 +0800
+++ intel/kernel/nvidia/drivers/media/i2c/Makefile	2023-04-24 10:21:19.217200301 +0800
@@ -18,11 +18,12 @@
 obj-$(CONFIG_I2C_IOEXPANDER_PCA9570) += pca9570.o
 obj-$(CONFIG_VIDEO_TC358840) += tc358840.o
 obj-$(CONFIG_VIDEO_LT6911UXC) +=lt6911uxc.o
-obj-$(CONFIG_I2C_IOEXPANDER_SER_MAX9295) += max9295.o
-obj-$(CONFIG_I2C_IOEXPANDER_DESER_MAX9296) += max9296.o
-obj-$(CONFIG_NV_VIDEO_IMX390) += nv_imx390.o
+obj-y += max9295.o
+obj-y += max9296.o
+#obj-$(CONFIG_NV_VIDEO_IMX390) += nv_imx390.o
 obj-$(CONFIG_NV_VIDEO_AR0234) += nv_ar0234.o
 obj-$(CONFIG_NV_VIDEO_HAWK_OWL) += nv_hawk_owl.o
 obj-$(CONFIG_NV_DESER_MAX96712) += max96712.o
+obj-$(CONFIG_VIDEO_D4XX) += d4xx.o
 obj-$(CONFIG_VIDEO_ECAM) += ar1335.o
 ar1335-objs :=  ar1335_common.o
diff -urN ori/kernel/nvidia/drivers/media/i2c/max9295.c intel/kernel/nvidia/drivers/media/i2c/max9295.c
--- ori/kernel/nvidia/drivers/media/i2c/max9295.c	2022-08-11 11:15:42.000000000 +0800
+++ intel/kernel/nvidia/drivers/media/i2c/max9295.c	2023-04-10 17:17:16.063081193 +0800
@@ -20,6 +20,8 @@
 #include <linux/module.h>
 #include <media/max9295.h>
 
+#define MAX9295_MODULE_VERSION "1.0.0.9"
+
 /* register specifics */
 #define MAX9295_MIPI_RX0_ADDR 0x330
 #define MAX9295_MIPI_RX1_ADDR 0x331
@@ -103,6 +105,11 @@
 	bool st_done;
 };
 
+enum ir_type {
+       Y8_Y8I,
+       Y12I,
+};
+
 struct max9295 {
 	struct i2c_client *i2c_client;
 	struct regmap *regmap;
@@ -111,6 +118,8 @@
 	/* primary serializer properties */
 	__u32 def_addr;
 	__u32 pst2_ref;
+
+	int ir_type_value;
 };
 
 static struct max9295 *prim_priv__;
@@ -475,6 +484,360 @@
 	.cache_type = REGCACHE_RBTREE,
 };
 
+static bool max9295_dynamic_update = true;
+module_param(max9295_dynamic_update, bool, 0664);
+MODULE_PARM_DESC(max9295_dynamic_update, "Update max9295 settings dynamically");
+
+
+static char *max9295_setting_verison = MAX9295_MODULE_VERSION;
+module_param(max9295_setting_verison, charp, 0444);
+MODULE_PARM_DESC(max9295_setting_verison, "Print max9295 setting version");
+
+struct reg_pair {
+	u16 addr;
+	u8 val;
+};
+
+static struct reg_pair map_cmu_regulator[] = {
+	{0x0302, 0x10}, // Increase CMU regulator voltage
+};
+
+static struct reg_pair map_pipe_opt[] = {
+	{0x0002, 0xF3}, // # Enable all pipes
+
+	{0x0331, 0x11}, // Write 0x33 for 4 lanes
+	{0x0308, 0x6F}, // All pipes pull clock from port B
+	{0x0311, 0xF0}, // All pipes pull data from port B
+};
+
+static struct reg_pair map_pipe_y8_opt[] = {
+	{0x0312, 0x0F}, // Double 8-bit data on pipe X, Y, Z & U
+};
+
+static struct reg_pair map_pipe_y12i_opt[] = {
+	{0x0312, 0x0B}, // Double 8-bit data on pipe X, Y & U
+};
+
+static struct reg_pair map_pipe_x_control[] = {
+	/* addr, val */
+	{0x0314, 0x5E}, // Pipe X pulls Depth (DT 0x1E)
+	{0x0315, 0x52}, // Pipe X pulls EMB8 (DT 0x12)
+	{0x0309, 0x01}, // # Pipe X pulls VC0
+	{0x030A, 0x00},
+	{0x031C, 0x30}, // BPP = 16 in pipe X
+	{0x0102, 0x0E}, // LIM_HEART Pipe X: Disabled
+};
+
+static struct reg_pair map_pipe_y_control[] = {
+	/* addr, val */
+	{0x0316, 0x5E}, // Pipe Y pulls RGB (DT 0x1E)
+	{0x0317, 0x52}, // Pipe Y pulls EMB8 (DT 0x12)
+	{0x030B, 0x02}, // Pipe Y pulls VC1
+	{0x030C, 0x00},
+	{0x031D, 0x30}, // BPP = 16 in pipe Y
+	{0x010A, 0x0E}, // LIM_HEART Pipe Y: Disabled
+};
+
+static struct reg_pair map_pipe_z_y8_y8i_control[] = {
+	/* addr, val */
+	{0x0318, 0x6A}, // Pipe Z pulls Y8 (DT 0x2A)
+	{0x0319, 0x5E}, // Pipe Z pulls Y8I (DT 0x1E)
+	{0x030D, 0x04}, // Pipe Z pulls VC2
+	{0x030E, 0x00},
+	{0x031E, 0x30}, // BPP = 16 in pipe Z
+	{0x0112, 0x0E}, // LIM_HEART Pipe Z: Disabled
+};
+
+static struct reg_pair map_pipe_z_y12i_control[] = {
+	/* addr, val */
+	{0x0318, 0x64}, // Pipe Z pulls Y12I (DT 0x24)
+	{0x0319, 0x00}, // Reset to clean setting of Y8/Y8I configs
+	{0x030D, 0x04}, // Pipe Z pulls VC2
+	{0x030E, 0x00},
+	/* Reset reg 0x031E since it's very likely to be modified in Y8/Y8I
+	 * before running Y12I. For Y12I, this reg is not required to be set.
+	 */
+	{0x031E, 0x18},
+	{0x0112, 0x0E}, // LIM_HEART Pipe Z: Disabled
+};
+
+static struct reg_pair map_pipe_u_control[] = {
+	/* addr, val */
+	{0x031A, 0x6A}, // Pipe U pulls IMU (DT 0x2A)
+	{0x030F, 0x08}, // Pipe U pulls VC3
+	{0x0310, 0x00},
+	{0x031F, 0x30}, // BPP = 16 in pipe U
+
+	{0x0315, 0xD2}, // Enable independent VC's
+	{0x011A, 0x0E}, // LIM_HEART Pipe U: Disabled
+};
+
+static struct reg_pair map_depth_trigger[] = {
+//	{0x02D6, 0x84}, // #MFP8
+//	{0x02D7, 0x60}, // #OUT_TYPE bit to 1
+//	{0x02D8, 0x1F},
+	{0x02C1, 0x84}, // #MFP1
+	{0x02C2, 0x20}, // #OUT_TYPE bit to 1 (no pullup)
+	{0x02C3, 0x1F},
+};
+
+static struct reg_pair map_rgb_trigger[] = {
+	{0x02BE, 0x84}, // #MFP0
+	{0x02BF, 0x20}, // #OUT_TYPE bit to 1  (no pullup)
+	{0x02C0, 0x1B},
+};
+
+static bool init_done = false;
+static bool probe_done = false;
+
+static int max9295_set_registers(struct device *dev, struct reg_pair *map,
+				 u32 count)
+{
+	struct max9295 *priv = dev_get_drvdata(dev);
+	int err = 0;
+	u32 j = 0;
+
+	mutex_lock(&priv->lock);
+
+	dev_info(dev, "%s count %u\n", __func__, count);
+
+	for (j = 0; j < count; j++) {
+		err = max9295_write_reg(dev,
+			map[j].addr, map[j].val);
+		if (err != 0) break;
+	}
+
+	mutex_unlock(&priv->lock);
+
+	return err;
+}
+
+static int max9295_init_settings(struct device *dev)
+{
+	int err = 0;
+	struct max9295 *priv = dev_get_drvdata(dev);
+
+	// Set CMU
+	err = max9295_set_registers(dev, map_cmu_regulator,
+				    ARRAY_SIZE(map_cmu_regulator));
+	// Init control
+	err |= max9295_set_registers(dev, map_pipe_opt,
+				     ARRAY_SIZE(map_pipe_opt));
+	err |= max9295_set_registers(dev, map_pipe_y8_opt,
+				     ARRAY_SIZE(map_pipe_y8_opt));
+
+	// Pipe X
+	err |= max9295_set_registers(dev, map_pipe_x_control,
+				     ARRAY_SIZE(map_pipe_x_control));
+	// Pipe Y
+	err |= max9295_set_registers(dev, map_pipe_y_control,
+				     ARRAY_SIZE(map_pipe_y_control));
+	// Pipe Z
+	if (priv->ir_type_value == Y8_Y8I)
+		err |= max9295_set_registers(dev, map_pipe_z_y8_y8i_control,
+				     ARRAY_SIZE(map_pipe_z_y8_y8i_control));
+	else
+		err |= max9295_set_registers(dev, map_pipe_z_y12i_control,
+				     ARRAY_SIZE(map_pipe_z_y12i_control));
+
+	// Pipe U
+	err |= max9295_set_registers(dev, map_pipe_u_control,
+				     ARRAY_SIZE(map_pipe_u_control));
+
+	// Trigger Depth
+	err |= max9295_set_registers(dev, map_depth_trigger,
+				     ARRAY_SIZE(map_depth_trigger));
+	// Trigger RGB
+	err |= max9295_set_registers(dev, map_rgb_trigger,
+				     ARRAY_SIZE(map_rgb_trigger));
+
+	if (err == 0) {
+		dev_info(dev, "%s done\n", __func__);
+		init_done = true;
+	}
+
+	return err;
+}
+
+int max9295_update_pipe(struct device *dev, int sensor_type, u32 fourcc)
+{
+	int err = 0;
+	struct max9295 *priv;
+
+	if (!probe_done)
+		return 0;
+
+	if (!max9295_dynamic_update) {
+		dev_info(dev, "%s, don't update dynamically\n", __func__);
+		return 0;
+	}
+
+	dev_dbg(dev, "%s st %d, fourcc %u\n", __func__, sensor_type, fourcc);
+
+	if (!init_done) {
+		dev_info(dev, "%s, SerDes device may not exist\n", __func__);
+		return 0;
+	}
+
+	if (sensor_type != IR_SENSOR)
+		return 0;
+
+	priv = dev_get_drvdata(dev);
+	if ((priv->ir_type_value != Y8_Y8I) &&
+	    (fourcc == V4L2_PIX_FMT_GREY || fourcc == V4L2_PIX_FMT_Y8I)) {
+		// Init control
+		err = max9295_set_registers(dev, map_pipe_y8_opt,
+					ARRAY_SIZE(map_pipe_y8_opt));
+		// Pipe Z
+		err |= max9295_set_registers(dev, map_pipe_z_y8_y8i_control,
+					ARRAY_SIZE(map_pipe_z_y8_y8i_control));
+		if (err == 0)
+			priv->ir_type_value = Y8_Y8I;
+	} else if ((priv->ir_type_value != Y12I) &&
+		   (fourcc == V4L2_PIX_FMT_Y12I)) {
+		// Init control
+		err = max9295_set_registers(dev, map_pipe_y12i_opt,
+					ARRAY_SIZE(map_pipe_y12i_opt));
+		// Pipe Z
+		err |= max9295_set_registers(dev, map_pipe_z_y12i_control,
+					ARRAY_SIZE(map_pipe_z_y12i_control));
+		if (err == 0)
+			priv->ir_type_value = Y12I;
+	}
+
+	return err;
+}
+EXPORT_SYMBOL(max9295_update_pipe);
+
+static int max9295_get_dump(struct device *dev, char *data_addr,
+			    struct reg_pair *pair, u32 pair_size)
+{
+	struct max9295 *priv = dev_get_drvdata(dev);
+	int err;
+	u32 val = 0;
+	char *addr = data_addr;
+	int data_size = 0;
+	int cnt = 0;
+	u32 j = 0;
+
+	mutex_lock(&priv->lock);
+
+	for (j = 0; j < pair_size; j++) {
+		val = 0;
+		err = regmap_read(priv->regmap, pair[j].addr, &val);
+
+		if (!err) {
+			cnt = snprintf(addr, 100 - data_size, "0x%04x:0x%x\n",
+				       pair[j].addr, val);
+			addr += cnt;
+			data_size += cnt;
+			dev_info(dev,
+				"%s:i2c read, addr 0x%x, value %x\n",
+				__func__, pair[j].addr, val);
+		} else {
+			dev_warn(dev,
+				"%s:i2c read, err %x, addr 0x%x, value %x\n",
+				__func__, err, pair[j].addr, val);
+		}
+	};
+
+	mutex_unlock(&priv->lock);
+
+	return data_size;
+}
+
+#ifdef CONFIG_SYSFS
+
+static ssize_t max9295_dev_dump_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	char *data_addr = buf;
+	int data_size = 0;
+	int count = 0;
+
+	if (!buf)
+		return -ENOMEM;
+
+	data_size = max9295_get_dump(dev, data_addr, map_cmu_regulator,
+				     ARRAY_SIZE(map_cmu_regulator));
+	count += data_size;
+	data_addr += data_size;
+
+	data_size = max9295_get_dump(dev, data_addr, map_pipe_opt,
+				     ARRAY_SIZE(map_pipe_opt));
+	count += data_size;
+	data_addr += data_size;
+
+	data_size = max9295_get_dump(dev, data_addr, map_pipe_y8_opt,
+				     ARRAY_SIZE(map_pipe_y8_opt));
+	count += data_size;
+	data_addr += data_size;
+
+	data_size = max9295_get_dump(dev, data_addr, map_pipe_x_control,
+				     ARRAY_SIZE(map_pipe_x_control));
+	count += data_size;
+	data_addr += data_size;
+
+	data_size = max9295_get_dump(dev, data_addr, map_pipe_y_control,
+				     ARRAY_SIZE(map_pipe_y_control));
+	count += data_size;
+	data_addr += data_size;
+
+	data_size = max9295_get_dump(dev, data_addr, map_pipe_z_y8_y8i_control,
+				     ARRAY_SIZE(map_pipe_z_y8_y8i_control));
+	count += data_size;
+	data_addr += data_size;
+
+	data_size = max9295_get_dump(dev, data_addr, map_pipe_u_control,
+				     ARRAY_SIZE(map_pipe_u_control));
+	count += data_size;
+	data_addr += data_size;
+
+	data_size = max9295_get_dump(dev, data_addr, map_depth_trigger,
+				     ARRAY_SIZE(map_depth_trigger));
+	count += data_size;
+	data_addr += data_size;
+
+	data_size = max9295_get_dump(dev, data_addr, map_rgb_trigger,
+				     ARRAY_SIZE(map_rgb_trigger));
+	count += data_size;
+	data_addr += data_size;
+	*data_addr = '0';
+
+	dev_info(dev, "%s, buf %p, count %d, \n", __func__, buf, count);
+
+	return count;
+}
+
+static DEVICE_ATTR(register_dump, 0444, max9295_dev_dump_show, NULL);
+
+static ssize_t refresh_setting_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	int ret;
+
+	ret = max9295_init_settings(dev);
+	if (ret)
+		return ret;
+
+	return count;
+}
+static DEVICE_ATTR_WO(refresh_setting);
+
+static struct attribute *max9295_attributes[] = {
+	&dev_attr_register_dump.attr,
+	&dev_attr_refresh_setting.attr,
+	NULL
+};
+
+static const struct attribute_group max9295_attr_group = {
+	.attrs = max9295_attributes,
+};
+
+#endif /* CONFIG_SYSFS */
+
+
 static int max9295_probe(struct i2c_client *client,
 				const struct i2c_device_id *id)
 {
@@ -514,6 +877,25 @@
 
 	dev_set_drvdata(&client->dev, priv);
 
+	priv->ir_type_value = Y8_Y8I;
+
+#ifdef CONFIG_SYSFS
+	err = sysfs_create_group(&client->dev.kobj, &max9295_attr_group);
+	if (err)
+		dev_warn(&client->dev, "%s, failed to create sysfs, err %d\n",
+			 __func__, err);
+#endif /* CONFIG_SYSFS */
+
+	/* don't break probe stage */
+	err = max9295_init_settings(&client->dev);
+	if (err) {
+		dev_warn(&client->dev, "%s, failed to init settings \n",
+			 __func__);
+		err = 0;
+	}
+
+	probe_done = true;
+
 	/* dev communication gets validated when GMSL link setup is done */
 	dev_info(&client->dev, "%s:  success\n", __func__);
 
@@ -526,6 +908,11 @@
 
 	if (client != NULL) {
 		priv = dev_get_drvdata(&client->dev);
+
+#ifdef CONFIG_SYSFS
+		sysfs_remove_group(&client->dev.kobj, &max9295_attr_group);
+#endif /* CONFIG_SYSFS */
+
 		mutex_destroy(&priv->lock);
 		i2c_unregister_device(client);
 		client = NULL;
@@ -571,4 +958,6 @@
 
 MODULE_DESCRIPTION("GMSL Serializer driver max9295");
 MODULE_AUTHOR("Sudhir Vyas <svyas@nvidia.com>");
+MODULE_AUTHOR("Dmitry Perchanov <dmitry.perchanov@intel.com>");
+MODULE_VERSION(MAX9295_MODULE_VERSION);
 MODULE_LICENSE("GPL v2");
diff -urN ori/kernel/nvidia/drivers/media/i2c/max9296.c intel/kernel/nvidia/drivers/media/i2c/max9296.c
--- ori/kernel/nvidia/drivers/media/i2c/max9296.c	2022-08-11 11:15:42.000000000 +0800
+++ intel/kernel/nvidia/drivers/media/i2c/max9296.c	2023-04-24 10:56:32.435509116 +0800
@@ -15,7 +15,7 @@
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
-
+#define DEBUG #define DEBUG 11
 #include <linux/gpio.h>
 #include <linux/module.h>
 #include <linux/of.h>
@@ -104,6 +104,11 @@
 	u32 st_id_sel;
 };
 
+enum ir_type {
+	Y8_Y8I,
+	Y12I,
+};
+
 struct max9296 {
 	struct i2c_client *i2c_client;
 	struct regmap *regmap;
@@ -124,6 +129,8 @@
 	int reset_gpio;
 	int pw_ref;
 	struct regulator *vdd_cam_1v2;
+
+	int ir_type_value;
 };
 
 static int max9296_write_reg(struct device *dev,
@@ -220,7 +227,7 @@
 	if (priv->pw_ref == 0) {
 		usleep_range(1, 2);
 		if (priv->reset_gpio)
-			gpio_set_value(priv->reset_gpio, 0);
+			gpio_set_value(priv->reset_gpio, 1);
 
 		usleep_range(30, 50);
 
@@ -234,7 +241,7 @@
 
 		/*exit reset mode: XCLR */
 		if (priv->reset_gpio) {
-			gpio_set_value(priv->reset_gpio, 0);
+			gpio_set_value(priv->reset_gpio, 1);
 			usleep_range(30, 50);
 			gpio_set_value(priv->reset_gpio, 1);
 			usleep_range(30, 50);
@@ -264,7 +271,7 @@
 		/* enter reset mode: XCLR */
 		usleep_range(1, 2);
 		if (priv->reset_gpio)
-			gpio_set_value(priv->reset_gpio, 0);
+			gpio_set_value(priv->reset_gpio, 1);
 
 		if (priv->vdd_cam_1v2)
 			regulator_disable(priv->vdd_cam_1v2);
@@ -780,6 +787,507 @@
 }
 EXPORT_SYMBOL(max9296_setup_streaming);
 
+static bool max9296_dynamic_update = true;
+module_param(max9296_dynamic_update, bool, 0664);
+MODULE_PARM_DESC(max9296_dynamic_update, "Update max9296 settings dynamically");
+
+
+static char *max9296_setting_verison = "1.0.0.8";
+module_param(max9296_setting_verison, charp, 0444);
+MODULE_PARM_DESC(max9296_setting_verison, "Print max9296 setting version");
+
+static struct reg_pair map_cmu_regulator[] = {
+#if 0
+	{0x0302, 0x10}, // Increase CMU regulator voltage
+#else
+
+
+#endif
+};
+
+static struct reg_pair map_pipe_opt[] = {
+#if 0
+	{0x1458, 0x28}, // PHY A Optimization
+	{0x1459, 0x68}, // PHY A Optimization
+	{0x1558, 0x28}, // PHY B Optimization
+	{0x1559, 0x68}, // PHY B Optimization
+	{0x0010, 0x31}, // One-shot reset  enable auto-link
+
+	{0x044A, 0x50}, // 4 lanes on port A, write 0x50 for 2 lanes
+	{0x0320, 0x2F}, // 1500Mbps/lane on port A
+//	{0x031C, 0x00}, // Do not un-double 8bpp (Un-double 8bpp data)
+//	{0x031F, 0x00}, // Do not un-double 8bpp
+	{0x0473, 0x10}, // 0x02: ALT_MEM_MAP8, 0x10: ALT2_MEM_MAP8
+	// VC2 VS will come from pipe Z, not needed for pipe U
+#else
+
+	{0x1458,0x28},
+	{0x1459,0x68},
+	{0x1558,0x28},
+	{0x1559,0x68},
+	{0x1658,0x28},
+	{0x1659,0x68},
+	{0x1758,0x28},
+	{0x1759,0x68},
+
+	{0x0006,0xF1},
+
+
+	{0x00F4,0x0f},   // Enable pipe 0 -3
+	{0x00F0,0x10},   // Link A ID 0 to pipe 0 // Link A ID 1 to pipe 1
+	{0x00F1,0x32},   // Link A ID 2 to pipe 2  // Link A ID 3 to pipe 3
+
+	{0x08A0,0x01},     // CSI output is 2x4
+	{0x08A3,0x44},     // Default 4x2 lane mapping
+	{0x08A4,0x44},     // Default 4x2 lane mapping
+
+	{0x090A,0x40},
+	{0x094A,0x40},     // 2 lanes on port D
+	{0x098A,0x40},     // 2 lanes on port E
+	{0x09CA,0x40},
+
+	{0x1D00,0xF4},
+	{0x1E00,0xF4},
+
+	{0x0415,0x2f},
+	{0x0418,0x2f},     // 1500Mbps/lane on port D
+	{0x041B,0x2f},     // 1500Mbps/lane on port E
+	{0x041E,0x2f},
+
+	{0x1D00,0xF5},
+	{0x1E00,0xF5},
+
+	{0x0933, 0x10},
+
+
+#endif
+};
+
+static struct reg_pair map_pipe_x_control[] = {
+#if 0
+	/* addr, val */
+	{0x040B, 0x0F}, // Enable 4 mappings for Pipe X
+	{0x040D, 0x1E}, // Map Depth VC0
+	{0x040E, 0x1E},
+	{0x040F, 0x00}, // Map frame start  VC0
+	{0x0410, 0x00},
+	{0x0411, 0x01}, // Map frame end  VC0
+	{0x0412, 0x01},
+	{0x0413, 0x12}, // Map EMB8, VC0
+	{0x0414, 0x12},
+	{0x042D, 0x55}, // All mappings to PHY1 (master for port A)
+
+	// SEQ_MISS_EN: Disabled / DIS_PKT_DET: Disabled
+	{0x0100, 0x23}, // pipe X
+
+
+#else
+	{0x090B,0x0f},     // Enable 3 mappings  Pipe 0//video2
+	{0x092D,0x00},     // All mappings to controller 1 (port A)
+	{0x090D,0x1E},     // Input RAW10, VC0
+	{0x090E,0x1E},     // Output RAW10, VC0
+	{0x090F,0x00},     // Input FS, VC0
+	{0x0910,0x00},     // Output FS, VC0
+	{0x0911,0x01},     // Input FE, VC0
+	{0x0912,0x01},     // Output FE, VC0
+	{0x0913,0x12},     // Input FE, VC0
+	{0x0914,0x12},     // Output FE, VC0
+	{0x0100,0x03},
+
+#endif
+};
+
+static struct reg_pair map_pipe_y_control[] = {
+#if 0
+	/* addr, val */
+	{0x044B, 0x0F}, // Enable 4 mappings for Pipe Y
+	{0x044D, 0x5E}, // Map RGB VC1
+	{0x044E, 0x5E},
+	{0x044F, 0x40}, // Map frame start  VC1
+	{0x0450, 0x40},
+	{0x0451, 0x41}, // Map frame end  VC1
+	{0x0452, 0x41},
+	{0x0453, 0x52}, // Map EMB8, VC1
+	{0x0454, 0x52},
+	{0x046D, 0x55}, // All mappings to PHY1 (master for port A)
+
+	// SEQ_MISS_EN: Disabled / DIS_PKT_DET: Disabled
+	{0x0112, 0x23}, // pipe Y
+
+#else
+	{0x094B,0x0f},     // Enable 3 mappings  Pipe 1  //video3
+	{0x096D,0x00},     // All mappings to controller 1 (port A)
+	{0x094D,0x5E},     // Input RAW10, VC0
+	{0x094E,0x5E},     // Output RAW10, VC1
+	{0x094F,0x40},     // Input FS, VC0
+	{0x0950,0x40},     // Output FS, VC1
+	{0x0951,0x41},     // Input FE, VC0
+	{0x0952,0x41},     // Output FE, VC1
+	{0x0953,0x52},     // Input FE, VC0
+	{0x0954,0x52},     // Output FE, VC1
+	{0x0112,0x03},
+
+
+
+#endif
+};
+
+static struct reg_pair map_pipe_z_y8_y8i_control[] = {
+#if 0
+	/* addr, val */
+	{0x048B, 0x0F}, // Enable 4 mappings for Pipe Z
+	{0x048D, 0xAA}, // Map Y8 VC2
+	{0x048E, 0xAA},
+	{0x048F, 0x80}, // Map frame start  VC2
+	{0x0490, 0x80},
+	{0x0491, 0x81}, // Map frame end  VC2
+	{0x0492, 0x81},
+	{0x0493, 0x9E}, // Map Y8I, VC2
+	{0x0494, 0x9E},
+	{0x04AD, 0x55}, // Map to PHY1 (master for port A)
+
+	// SEQ_MISS_EN: Disabled / DIS_PKT_DET: Disabled
+	{0x0124, 0x23}, // pipe Z
+
+#else
+	{0x098B,0x0f},     // Enable 3 mappings Pipe 2  //video1
+	{0x09AD,0x00},     // All mappings to controller 1 (port A)
+	{0x098D,0xAA},     // Input RAW10, VC0
+	{0x098E,0xAA},     // Output RAW10, VC2
+	{0x098F,0x80},     // Input FS, VC0
+	{0x0990,0x80},     // Output FS, VC2
+	{0x0991,0x81},     // Input FE, VC0
+	{0x0992,0x81},     // Output FE, VC2
+	{0x0993,0x9E},     // Input FE, VC0
+	{0x0994,0x9E},     // Output FE, VC2
+	{0x0124,0x03},
+
+
+
+#endif
+
+
+
+};
+
+static struct reg_pair map_pipe_z_y12i_control[] = {
+#if 0
+	/* addr, val */
+	{0x048B, 0x07}, // Enable 3 mappings for Pipe Z
+	{0x048D, 0xA4}, // Map Y12I VC2
+	{0x048E, 0xA4},
+	{0x048F, 0x80}, // Map frame start  VC2
+	{0x0490, 0x80},
+	{0x0491, 0x81}, // Map frame end  VC2
+	{0x0492, 0x81},
+	{0x0493, 0x00}, // Reset to unmap EMB8, VC2
+	{0x0494, 0x00},
+	{0x04AD, 0x15}, // Map to PHY1 (master for port A)
+
+	// SEQ_MISS_EN: Disabled / DIS_PKT_DET: Disabled
+	{0x0124, 0x23}, // pipe Z
+#else
+
+
+
+
+#endif
+};
+
+static struct reg_pair map_pipe_u_control[] = {
+#if 0
+	/* addr, val */
+	{0x04CB, 0x07}, // Enable 3 mappings for Pipe U
+	{0x04CD, 0xEA}, // Map IMUI VC3
+	{0x04CE, 0xEA},
+	{0x04CF, 0xC0}, // Map frame start  VC3
+	{0x04D0, 0xC0},
+	{0x04D1, 0xC1}, // Map frame end  VC3
+	{0x04D2, 0xC1},
+	{0x04ED, 0x15}, // Map to PHY1 (master for port A)
+
+	// SEQ_MISS_EN: Disabled / DIS_PKT_DET: Disabled
+	{0x0136, 0x23}, // pipe U
+
+#endif
+
+	{0x09CB,0x0F},     // Enable 3 mappings  Pipe 3  //video0
+	{0x09ED,0x00},     // All mappings to controller 1 (port A)
+	{0x09CD,0xEA},     // Input RAW10, VC0
+	{0x09CE,0xEA},     // Output RAW10, VC3
+	{0x09CF,0xC0},     // Input FS, VC0
+	{0x09D0,0xc0},     // Output FS, VC3
+	{0x09D1,0xC1},     // Input FE, VC0
+	{0x09D2,0xc1},     // Output FE, VC3
+	{0x0136,0x03}, // pipe U
+
+	{0x08A2,0xF0},
+
+
+
+};
+
+static struct reg_pair map_depth_trigger[] = {
+//	{0x02C5, 0x82}, // #MFP7
+//	{0x02C6, 0x1F},
+};
+
+static struct reg_pair map_rgb_trigger[] = {
+//	{0x02CB, 0x82}, // #MFP9
+//	{0x02CC, 0x1B},
+};
+
+static bool init_done = false;
+static bool probe_done = false;
+
+static int max9296_set_registers(struct device *dev, struct reg_pair *map,
+				 u32 count)
+{
+	struct max9296 *priv = dev_get_drvdata(dev);
+	int err = 0;
+	u32 j = 0;
+
+	mutex_lock(&priv->lock);
+
+	dev_info(dev, "%s count %u\n", __func__, count);
+
+	for (j = 0; j < count; j++) {
+		err = max9296_write_reg(dev,
+			map[j].addr, map[j].val);
+		if (err != 0) break;
+	}
+
+	mutex_unlock(&priv->lock);
+
+	return err;
+}
+
+static int max9296_init_settings(struct device *dev)
+{
+	int err = 0;
+	struct max9296 *priv = dev_get_drvdata(dev);
+
+	// Set CMU
+	err = max9296_set_registers(dev, map_cmu_regulator,
+				    ARRAY_SIZE(map_cmu_regulator));
+	// Init control
+	err |= max9296_set_registers(dev, map_pipe_opt,
+				     ARRAY_SIZE(map_pipe_opt));
+
+	// Pipe X
+	err |= max9296_set_registers(dev, map_pipe_x_control,
+				     ARRAY_SIZE(map_pipe_x_control));
+	// Pipe Y
+	err |= max9296_set_registers(dev, map_pipe_y_control,
+				     ARRAY_SIZE(map_pipe_y_control));
+	// Pipe Z
+	if (priv->ir_type_value == Y8_Y8I)
+		err |= max9296_set_registers(dev, map_pipe_z_y8_y8i_control,
+				     ARRAY_SIZE(map_pipe_z_y8_y8i_control));
+	else
+		err |= max9296_set_registers(dev, map_pipe_z_y12i_control,
+				     ARRAY_SIZE(map_pipe_z_y12i_control));
+
+	// Pipe U
+	err |= max9296_set_registers(dev, map_pipe_u_control,
+				     ARRAY_SIZE(map_pipe_u_control));
+
+	// Trigger Depth
+	err |= max9296_set_registers(dev, map_depth_trigger,
+				     ARRAY_SIZE(map_depth_trigger));
+	// Trigger RGB
+	err |= max9296_set_registers(dev, map_rgb_trigger,
+				     ARRAY_SIZE(map_rgb_trigger));
+
+	if (err == 0) {
+		dev_info(dev, "%s done\n", __func__);
+		init_done = true;
+		printk("********write success**********\n\r");
+	} else {
+		printk("********write error**********\n\r");
+	}
+
+
+	return err;
+}
+
+int max9296_update_pipe(struct device *dev, int sensor_type, u32 fourcc)
+{
+	int err = 0;
+	struct max9296 *priv;
+	const int reset_sleep = 5;
+	if (!probe_done)
+		return 0;
+
+	if (!max9296_dynamic_update) {
+		dev_info(dev, "%s, don't update dynamically\n", __func__);
+		return 0;
+	}
+
+	dev_dbg(dev, "%s st %d, fourcc %u\n", __func__, sensor_type, fourcc);
+
+	if (!init_done) {
+		dev_info(dev, "%s, SerDes device may not exist\n", __func__);
+		return 0;
+	}
+
+	if (sensor_type != IR_SENSOR)
+		return 0;
+
+	priv = dev_get_drvdata(dev);
+	if ((priv->ir_type_value != Y8_Y8I) &&
+	    (fourcc == V4L2_PIX_FMT_GREY || fourcc == V4L2_PIX_FMT_Y8I)) {
+		// Init control
+		err |= max9296_set_registers(dev, map_pipe_opt,
+					     ARRAY_SIZE(map_pipe_opt));
+		/* needed to settle serdes line after reset */
+		usleep_range(reset_sleep * 1000, reset_sleep * 1000 + 500);
+		// Pipe Z
+		err = max9296_set_registers(dev, map_pipe_z_y8_y8i_control,
+					ARRAY_SIZE(map_pipe_z_y8_y8i_control));
+		if (err == 0)
+			priv->ir_type_value = Y8_Y8I;
+	} else if ((priv->ir_type_value != Y12I) &&
+		   (fourcc == V4L2_PIX_FMT_Y12I)) {
+		// Init control
+		err |= max9296_set_registers(dev, map_pipe_opt,
+					     ARRAY_SIZE(map_pipe_opt));
+		/* needed to settle serdes line after reset */
+		usleep_range(reset_sleep * 1000, reset_sleep * 1000 + 500);
+		// Pipe Z
+		err = max9296_set_registers(dev, map_pipe_z_y12i_control,
+					ARRAY_SIZE(map_pipe_z_y12i_control));
+		if (err == 0)
+			priv->ir_type_value = Y12I;
+	}
+
+	return err;
+}
+EXPORT_SYMBOL(max9296_update_pipe);
+
+static int max9296_get_dump(struct device *dev, char *data_addr,
+			    struct reg_pair *pair, u32 pair_size)
+{
+	struct max9296 *priv = dev_get_drvdata(dev);
+	int err;
+	u32 val = 0;
+	char *addr = data_addr;
+	int data_size = 0;
+	int cnt = 0;
+	u32 j = 0;
+
+	mutex_lock(&priv->lock);
+
+	for (j = 0; j < pair_size; j++) {
+		val = 0;
+		err = regmap_read(priv->regmap, pair[j].addr, &val);
+
+		if (!err) {
+			cnt = snprintf(addr, PAGE_SIZE, "0x%04x:0x%x\n",
+				       pair[j].addr, val);
+			addr += cnt;
+			data_size += cnt;
+			dev_info(dev,
+				"%s:i2c read, addr 0x%x, value %x\n",
+				__func__, pair[j].addr, val);
+		} else {
+			dev_warn(dev,
+				"%s:i2c read, err %x, addr 0x%x, value %x\n",
+				__func__, err, pair[j].addr, val);
+		}
+	};
+
+	mutex_unlock(&priv->lock);
+
+	return data_size;
+}
+
+#ifdef CONFIG_SYSFS
+
+static ssize_t max9296_dev_dump_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	char *data_addr = buf;
+	int data_size = 0;
+	int count = 0;
+
+	if (!buf)
+		return -ENOMEM;
+
+	data_size = max9296_get_dump(dev, data_addr, map_cmu_regulator,
+				     ARRAY_SIZE(map_cmu_regulator));
+	count += data_size;
+	data_addr += data_size;
+
+	data_size = max9296_get_dump(dev, data_addr, map_pipe_opt,
+				     ARRAY_SIZE(map_pipe_opt));
+	count += data_size;
+	data_addr += data_size;
+
+	data_size = max9296_get_dump(dev, data_addr, map_pipe_x_control,
+				     ARRAY_SIZE(map_pipe_x_control));
+	count += data_size;
+	data_addr += data_size;
+
+	data_size = max9296_get_dump(dev, data_addr, map_pipe_y_control,
+				     ARRAY_SIZE(map_pipe_y_control));
+	count += data_size;
+	data_addr += data_size;
+
+	data_size = max9296_get_dump(dev, data_addr, map_pipe_z_y8_y8i_control,
+				     ARRAY_SIZE(map_pipe_z_y8_y8i_control));
+	count += data_size;
+	data_addr += data_size;
+
+	data_size = max9296_get_dump(dev, data_addr, map_pipe_u_control,
+				     ARRAY_SIZE(map_pipe_u_control));
+	count += data_size;
+	data_addr += data_size;
+
+	data_size = max9296_get_dump(dev, data_addr, map_depth_trigger,
+				     ARRAY_SIZE(map_depth_trigger));
+	count += data_size;
+	data_addr += data_size;
+
+	data_size = max9296_get_dump(dev, data_addr, map_rgb_trigger,
+				     ARRAY_SIZE(map_rgb_trigger));
+	count += data_size;
+	data_addr += data_size;
+	*data_addr = '0';
+
+	dev_info(dev, "%s, buf %p, count %d, \n", __func__, buf, count);
+
+	return count;
+}
+
+static DEVICE_ATTR(register_dump, 0444, max9296_dev_dump_show, NULL);
+
+static ssize_t refresh_setting_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	int ret;
+
+	ret = max9296_init_settings(dev);
+	if (ret)
+		return ret;
+
+	return count;
+}
+static DEVICE_ATTR_WO(refresh_setting);
+
+static struct attribute *max9296_attributes[] = {
+	&dev_attr_register_dump.attr,
+	&dev_attr_refresh_setting.attr,
+	NULL
+};
+
+static const struct attribute_group max9296_attr_group = {
+	.attrs = max9296_attributes,
+};
+
+#endif /* CONFIG_SYSFS */
+
 static const struct of_device_id max9296_of_match[] = {
 	{ .compatible = "maxim,max9296", },
 	{ },
@@ -793,6 +1301,7 @@
 	int err = 0;
 	const char *str_value;
 	int value;
+	 int gpio = 0;
 	const struct of_device_id *match;
 
 	if (!node)
@@ -834,7 +1343,20 @@
 	if (priv->reset_gpio < 0) {
 		dev_err(&client->dev, "reset-gpios not found %d\n", err);
 		return err;
-	}
+	} else
+		 gpio_direction_output(priv->reset_gpio, 1);
+
+
+	gpio = of_get_named_gpio(node,
+	                        "pwdn-gpios", 0);
+	if(gpio > 0)
+		gpio_direction_output(gpio, 1);
+	gpio = of_get_named_gpio(node,
+			"pwr-gpios", 0);
+	 if(gpio > 0)
+		 gpio_direction_output(gpio, 1);
+
+
 
 	/* digital 1.2v */
 	if (of_get_property(node, "vdd_cam_1v2-supply", NULL)) {
@@ -895,6 +1417,25 @@
 
 	dev_set_drvdata(&client->dev, priv);
 
+	priv->ir_type_value = Y8_Y8I;
+
+#ifdef CONFIG_SYSFS
+	err = sysfs_create_group(&client->dev.kobj, &max9296_attr_group);
+	if (err)
+		dev_warn(&client->dev, "%s, failed to create sysfs, err %d",
+			 __func__, err);
+#endif /* CONFIG_SYSFS */
+
+	/* don't break probe stage */
+	err = max9296_init_settings(&client->dev);
+	if (err) {
+		dev_warn(&client->dev, "%s, failed to init settings \n",
+			 __func__);
+		err = 0;
+	}
+
+	probe_done = true;
+
 	/* dev communication gets validated when GMSL link setup is done */
 	dev_info(&client->dev, "%s:  success\n", __func__);
 
@@ -908,6 +1449,11 @@
 
 	if (client != NULL) {
 		priv = dev_get_drvdata(&client->dev);
+
+#ifdef CONFIG_SYSFS
+		sysfs_remove_group(&client->dev.kobj, &max9296_attr_group);
+#endif /* CONFIG_SYSFS */
+
 		mutex_destroy(&priv->lock);
 		i2c_unregister_device(client);
 		client = NULL;
diff -urN ori/kernel/nvidia/drivers/media/i2c/max9296.c_bk intel/kernel/nvidia/drivers/media/i2c/max9296.c_bk
--- ori/kernel/nvidia/drivers/media/i2c/max9296.c_bk	1970-01-01 08:00:00.000000000 +0800
+++ intel/kernel/nvidia/drivers/media/i2c/max9296.c_bk	2023-04-24 08:01:57.148698748 +0800
@@ -0,0 +1,1351 @@
+/*
+ * max9296.c - max9296 GMSL Deserializer driver
+ *
+ * Copyright (c) 2018-2022, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/gpio.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <media/camera_common.h>
+#include <linux/module.h>
+#include <media/max9296.h>
+
+/* register specifics */
+#define MAX9296_DST_CSI_MODE_ADDR 0x330
+#define MAX9296_LANE_MAP1_ADDR 0x333
+#define MAX9296_LANE_MAP2_ADDR 0x334
+
+#define MAX9296_LANE_CTRL0_ADDR 0x40A
+#define MAX9296_LANE_CTRL1_ADDR 0x44A
+#define MAX9296_LANE_CTRL2_ADDR 0x48A
+#define MAX9296_LANE_CTRL3_ADDR 0x4CA
+
+#define MAX9296_TX11_PIPE_X_EN_ADDR 0x40B
+#define MAX9296_TX45_PIPE_X_DST_CTRL_ADDR 0x42D
+
+#define MAX9296_PIPE_X_SRC_0_MAP_ADDR 0x40D
+#define MAX9296_PIPE_X_DST_0_MAP_ADDR 0x40E
+#define MAX9296_PIPE_X_SRC_1_MAP_ADDR 0x40F
+#define MAX9296_PIPE_X_DST_1_MAP_ADDR 0x410
+#define MAX9296_PIPE_X_SRC_2_MAP_ADDR 0x411
+#define MAX9296_PIPE_X_DST_2_MAP_ADDR 0x412
+
+#define MAX9296_PIPE_X_ST_SEL_ADDR 0x50
+
+#define MAX9296_PWDN_PHYS_ADDR 0x332
+#define MAX9296_PHY1_CLK_ADDR 0x320
+#define MAX9296_CTRL0_ADDR 0x10
+
+/* data defines */
+#define MAX9296_CSI_MODE_4X2 0x1
+#define MAX9296_CSI_MODE_2X4 0x4
+#define MAX9296_LANE_MAP1_4X2 0x44
+#define MAX9296_LANE_MAP2_4X2 0x44
+#define MAX9296_LANE_MAP1_2X4 0x4E
+#define MAX9296_LANE_MAP2_2X4 0xE4
+
+#define MAX9296_LANE_CTRL_MAP(num_lanes) \
+	(((num_lanes) << 6) & 0xF0)
+
+#define MAX9296_ALLPHYS_NOSTDBY 0xF0
+#define MAX9296_ST_ID_SEL_INVALID 0xF
+
+#define MAX9296_PHY1_CLK 0x2C
+
+#define MAX9296_RESET_ALL 0x80
+
+/* Dual GMSL MAX9296A/B */
+#define MAX9296_MAX_SOURCES 2
+
+#define MAX9296_MAX_PIPES 4
+
+#define MAX9296_PIPE_X 0
+#define MAX9296_PIPE_Y 1
+#define MAX9296_PIPE_Z 2
+#define MAX9296_PIPE_U 3
+#define MAX9296_PIPE_INVALID 0xF
+
+
+#define MAX9296_CSI_CTRL_0 0
+#define MAX9296_CSI_CTRL_1 1
+#define MAX9296_CSI_CTRL_2 2
+#define MAX9296_CSI_CTRL_3 3
+
+#define MAX9296_INVAL_ST_ID 0xFF
+
+/* Use reset value as per spec, confirm with vendor */
+#define MAX9296_RESET_ST_ID 0x00
+
+struct max9296_source_ctx {
+	struct gmsl_link_ctx *g_ctx;
+	bool st_enabled;
+};
+
+struct pipe_ctx {
+	u32 id;
+	u32 dt_type;
+	u32 dst_csi_ctrl;
+	u32 st_count;
+	u32 st_id_sel;
+};
+
+enum ir_type {
+	Y8_Y8I,
+	Y12I,
+};
+
+struct max9296 {
+	struct i2c_client *i2c_client;
+	struct regmap *regmap;
+	u32 num_src;
+	u32 max_src;
+	u32 num_src_found;
+	u32 src_link;
+	bool splitter_enabled;
+	struct max9296_source_ctx sources[MAX9296_MAX_SOURCES];
+	struct mutex lock;
+	u32 sdev_ref;
+	bool lane_setup;
+	bool link_setup;
+	struct pipe_ctx pipe[MAX9296_MAX_PIPES];
+	u8 csi_mode;
+	u8 lane_mp1;
+	u8 lane_mp2;
+	int reset_gpio;
+	int pw_ref;
+	struct regulator *vdd_cam_1v2;
+
+	int ir_type_value;
+};
+
+static int max9296_write_reg(struct device *dev,
+	u16 addr, u8 val)
+{
+	struct max9296 *priv;
+	int err;
+
+	priv = dev_get_drvdata(dev);
+
+	err = regmap_write(priv->regmap, addr, val);
+	if (err)
+		dev_err(dev,
+		"%s:i2c write failed, 0x%x = %x\n",
+		__func__, addr, val);
+
+	/* delay before next i2c command as required for SERDES link */
+	usleep_range(100, 110);
+
+	return err;
+}
+
+static int max9296_get_sdev_idx(struct device *dev,
+			struct device *s_dev, unsigned int *idx)
+{
+	struct max9296 *priv = dev_get_drvdata(dev);
+	unsigned int i;
+	int err = 0;
+
+	mutex_lock(&priv->lock);
+	for (i = 0; i < priv->max_src; i++) {
+		if (priv->sources[i].g_ctx->s_dev == s_dev)
+			break;
+	}
+	if (i == priv->max_src) {
+		dev_err(dev, "no sdev found\n");
+		err = -EINVAL;
+		goto ret;
+	}
+
+	if (idx)
+		*idx = i;
+
+ret:
+	mutex_unlock(&priv->lock);
+	return err;
+}
+
+static void max9296_pipes_reset(struct max9296 *priv)
+{
+	/*
+	 * This is default pipes combination. add more mappings
+	 * for other combinations and requirements.
+	 */
+	struct pipe_ctx pipe_defaults[] = {
+		{MAX9296_PIPE_X, GMSL_CSI_DT_RAW_12,
+			MAX9296_CSI_CTRL_1, 0, MAX9296_INVAL_ST_ID},
+		{MAX9296_PIPE_Y, GMSL_CSI_DT_RAW_12,
+			MAX9296_CSI_CTRL_1, 0, MAX9296_INVAL_ST_ID},
+		{MAX9296_PIPE_Z, GMSL_CSI_DT_EMBED,
+			MAX9296_CSI_CTRL_1, 0, MAX9296_INVAL_ST_ID},
+		{MAX9296_PIPE_U, GMSL_CSI_DT_EMBED,
+			MAX9296_CSI_CTRL_1, 0, MAX9296_INVAL_ST_ID}
+	};
+
+	/*
+	 * Add DT props for num-streams and stream sequence, and based on that
+	 * set the appropriate pipes defaults.
+	 * For now default it supports "2 RAW12 and 2 EMBED" 1:1 mappings.
+	 */
+	memcpy(priv->pipe, pipe_defaults, sizeof(pipe_defaults));
+}
+
+static void max9296_reset_ctx(struct max9296 *priv)
+{
+	unsigned int i;
+
+	priv->link_setup = false;
+	priv->lane_setup = false;
+	priv->num_src_found = 0;
+	priv->src_link = 0;
+	priv->splitter_enabled = false;
+	max9296_pipes_reset(priv);
+	for (i = 0; i < priv->num_src; i++)
+		priv->sources[i].st_enabled = false;
+}
+
+int max9296_power_on(struct device *dev)
+{
+	struct max9296 *priv = dev_get_drvdata(dev);
+	int err = 0;
+
+	mutex_lock(&priv->lock);
+	if (priv->pw_ref == 0) {
+		usleep_range(1, 2);
+		if (priv->reset_gpio)
+			gpio_set_value(priv->reset_gpio, 0);
+
+		usleep_range(30, 50);
+
+		if (priv->vdd_cam_1v2) {
+			err = regulator_enable(priv->vdd_cam_1v2);
+			if (unlikely(err))
+				goto ret;
+		}
+
+		usleep_range(30, 50);
+
+		/*exit reset mode: XCLR */
+		if (priv->reset_gpio) {
+			gpio_set_value(priv->reset_gpio, 0);
+			usleep_range(30, 50);
+			gpio_set_value(priv->reset_gpio, 1);
+			usleep_range(30, 50);
+		}
+
+		/* delay to settle reset */
+		msleep(20);
+	}
+
+	priv->pw_ref++;
+
+ret:
+	mutex_unlock(&priv->lock);
+
+	return err;
+}
+EXPORT_SYMBOL(max9296_power_on);
+
+void max9296_power_off(struct device *dev)
+{
+	struct max9296 *priv = dev_get_drvdata(dev);
+
+	mutex_lock(&priv->lock);
+	priv->pw_ref--;
+
+	if (priv->pw_ref == 0) {
+		/* enter reset mode: XCLR */
+		usleep_range(1, 2);
+		if (priv->reset_gpio)
+			gpio_set_value(priv->reset_gpio, 0);
+
+		if (priv->vdd_cam_1v2)
+			regulator_disable(priv->vdd_cam_1v2);
+	}
+
+	mutex_unlock(&priv->lock);
+}
+EXPORT_SYMBOL(max9296_power_off);
+
+static int max9296_write_link(struct device *dev, u32 link)
+{
+	if (link == GMSL_SERDES_CSI_LINK_A) {
+		max9296_write_reg(dev, MAX9296_CTRL0_ADDR, 0x01);
+		max9296_write_reg(dev, MAX9296_CTRL0_ADDR, 0x21);
+	} else if (link == GMSL_SERDES_CSI_LINK_B) {
+		max9296_write_reg(dev, MAX9296_CTRL0_ADDR, 0x02);
+		max9296_write_reg(dev, MAX9296_CTRL0_ADDR, 0x22);
+	} else {
+		dev_err(dev, "%s: invalid gmsl link\n", __func__);
+		return -EINVAL;
+	}
+
+	/* delay to settle link */
+	msleep(100);
+
+	return 0;
+}
+
+int max9296_setup_link(struct device *dev, struct device *s_dev)
+{
+	struct max9296 *priv = dev_get_drvdata(dev);
+	int err = 0;
+	unsigned int i = 0;
+
+	err = max9296_get_sdev_idx(dev, s_dev, &i);
+	if (err)
+		return err;
+
+	mutex_lock(&priv->lock);
+
+	if (!priv->splitter_enabled) {
+		err = max9296_write_link(dev,
+				priv->sources[i].g_ctx->serdes_csi_link);
+		if (err)
+			goto ret;
+
+		priv->link_setup = true;
+	}
+
+ret:
+	mutex_unlock(&priv->lock);
+
+	return err;
+}
+EXPORT_SYMBOL(max9296_setup_link);
+
+int max9296_setup_control(struct device *dev, struct device *s_dev)
+{
+	struct max9296 *priv = dev_get_drvdata(dev);
+	int err = 0;
+	unsigned int i = 0;
+
+	err = max9296_get_sdev_idx(dev, s_dev, &i);
+	if (err)
+		return err;
+
+	mutex_lock(&priv->lock);
+
+	if (!priv->link_setup) {
+		dev_err(dev, "%s: invalid state\n", __func__);
+		err = -EINVAL;
+		goto error;
+	}
+
+	if (priv->sources[i].g_ctx->serdev_found) {
+		priv->num_src_found++;
+		priv->src_link = priv->sources[i].g_ctx->serdes_csi_link;
+	}
+
+	/* Enable splitter mode */
+	if ((priv->max_src > 1U) &&
+		(priv->num_src_found > 0U) &&
+		(priv->splitter_enabled == false)) {
+		max9296_write_reg(dev, MAX9296_CTRL0_ADDR, 0x03);
+		max9296_write_reg(dev, MAX9296_CTRL0_ADDR, 0x23);
+
+		priv->splitter_enabled = true;
+
+		/* delay to settle link */
+		msleep(100);
+	}
+
+	max9296_write_reg(dev,
+			MAX9296_PWDN_PHYS_ADDR, MAX9296_ALLPHYS_NOSTDBY);
+
+	priv->sdev_ref++;
+
+	/* Reset splitter mode if all devices are not found */
+	if ((priv->sdev_ref == priv->max_src) &&
+		(priv->splitter_enabled == true) &&
+		(priv->num_src_found > 0U) &&
+		(priv->num_src_found < priv->max_src)) {
+		err = max9296_write_link(dev, priv->src_link);
+		if (err)
+			goto error;
+
+		priv->splitter_enabled = false;
+	}
+
+error:
+	mutex_unlock(&priv->lock);
+	return err;
+}
+EXPORT_SYMBOL(max9296_setup_control);
+
+int max9296_reset_control(struct device *dev, struct device *s_dev)
+{
+	struct max9296 *priv = dev_get_drvdata(dev);
+	int err = 0;
+
+	mutex_lock(&priv->lock);
+	if (!priv->sdev_ref) {
+		dev_info(dev, "%s: dev is already in reset state\n", __func__);
+		goto ret;
+	}
+
+	priv->sdev_ref--;
+	if (priv->sdev_ref == 0) {
+		max9296_reset_ctx(priv);
+		max9296_write_reg(dev, MAX9296_CTRL0_ADDR, MAX9296_RESET_ALL);
+
+		/* delay to settle reset */
+		msleep(100);
+	}
+
+ret:
+	mutex_unlock(&priv->lock);
+
+	return err;
+}
+EXPORT_SYMBOL(max9296_reset_control);
+
+int max9296_sdev_register(struct device *dev, struct gmsl_link_ctx *g_ctx)
+{
+	struct max9296 *priv = NULL;
+	unsigned int i;
+	int err = 0;
+
+	if (!dev || !g_ctx || !g_ctx->s_dev) {
+		dev_err(dev, "%s: invalid input params\n", __func__);
+		return -EINVAL;
+	}
+
+	priv = dev_get_drvdata(dev);
+
+	mutex_lock(&priv->lock);
+
+	if (priv->num_src > priv->max_src) {
+		dev_err(dev,
+			"%s: MAX9296 inputs size exhausted\n", __func__);
+		err = -ENOMEM;
+		goto error;
+	}
+
+	/* Check csi mode compatibility */
+	if (!((priv->csi_mode == MAX9296_CSI_MODE_2X4) ?
+			((g_ctx->csi_mode == GMSL_CSI_1X4_MODE) ||
+				(g_ctx->csi_mode == GMSL_CSI_2X4_MODE)) :
+			((g_ctx->csi_mode == GMSL_CSI_2X2_MODE) ||
+				(g_ctx->csi_mode == GMSL_CSI_4X2_MODE)))) {
+		dev_err(dev,
+			"%s: csi mode not supported\n", __func__);
+		err = -EINVAL;
+		goto error;
+	}
+
+	for (i = 0; i < priv->num_src; i++) {
+		if (g_ctx->serdes_csi_link ==
+			priv->sources[i].g_ctx->serdes_csi_link) {
+			dev_err(dev,
+				"%s: serdes csi link is in use\n", __func__);
+			err = -EINVAL;
+			goto error;
+		}
+		/*
+		 * All sdevs should have same num-csi-lanes regardless of
+		 * dst csi port selected.
+		 * Later if there is any usecase which requires each port
+		 * to be configured with different num-csi-lanes, then this
+		 * check should be performed per port.
+		 */
+		if (g_ctx->num_csi_lanes !=
+				priv->sources[i].g_ctx->num_csi_lanes) {
+			dev_err(dev,
+				"%s: csi num lanes mismatch\n", __func__);
+			err = -EINVAL;
+			goto error;
+		}
+	}
+
+	priv->sources[priv->num_src].g_ctx = g_ctx;
+	priv->sources[priv->num_src].st_enabled = false;
+
+	priv->num_src++;
+
+error:
+	mutex_unlock(&priv->lock);
+	return err;
+}
+EXPORT_SYMBOL(max9296_sdev_register);
+
+int max9296_sdev_unregister(struct device *dev, struct device *s_dev)
+{
+	struct max9296 *priv = NULL;
+	int err = 0;
+	unsigned int i = 0;
+
+	if (!dev || !s_dev) {
+		dev_err(dev, "%s: invalid input params\n", __func__);
+		return -EINVAL;
+	}
+
+	priv = dev_get_drvdata(dev);
+	mutex_lock(&priv->lock);
+
+	if (priv->num_src == 0) {
+		dev_err(dev, "%s: no source found\n", __func__);
+		err = -ENODATA;
+		goto error;
+	}
+
+	for (i = 0; i < priv->num_src; i++) {
+		if (s_dev == priv->sources[i].g_ctx->s_dev) {
+			priv->sources[i].g_ctx = NULL;
+			break;
+		}
+	}
+
+	if (i == priv->num_src) {
+		dev_err(dev,
+			"%s: requested device not found\n", __func__);
+		err = -EINVAL;
+		goto error;
+	}
+	priv->num_src--;
+
+error:
+	mutex_unlock(&priv->lock);
+	return err;
+}
+EXPORT_SYMBOL(max9296_sdev_unregister);
+
+static int max9296_get_available_pipe(struct device *dev,
+				u32 st_data_type, u32 dst_csi_port)
+{
+	struct max9296 *priv = dev_get_drvdata(dev);
+	int i;
+
+	for (i = 0; i < MAX9296_MAX_PIPES; i++) {
+		/*
+		 * TODO: Enable a pipe for multi stream configuration having
+		 * similar stream data type. For now use st_count as a flag
+		 * for 1 to 1 mapping in pipe and stream data type, same can
+		 * be extended as count for many to 1 mapping. Would also need
+		 * few more checks such as input stream id select, dst port etc.
+		 */
+		if ((priv->pipe[i].dt_type == st_data_type) &&
+			((dst_csi_port == GMSL_CSI_PORT_A) ?
+				(priv->pipe[i].dst_csi_ctrl ==
+					MAX9296_CSI_CTRL_0) ||
+				(priv->pipe[i].dst_csi_ctrl ==
+					MAX9296_CSI_CTRL_1) :
+				(priv->pipe[i].dst_csi_ctrl ==
+					MAX9296_CSI_CTRL_2) ||
+				(priv->pipe[i].dst_csi_ctrl ==
+					MAX9296_CSI_CTRL_3)) &&
+			(!priv->pipe[i].st_count))
+			break;
+	}
+
+	if (i == MAX9296_MAX_PIPES) {
+		dev_err(dev, "%s: all pipes are busy\n", __func__);
+		return -ENOMEM;
+	}
+
+	return i;
+}
+
+struct reg_pair {
+	u16 addr;
+	u8 val;
+};
+
+static int max9296_setup_pipeline(struct device *dev,
+		struct gmsl_link_ctx *g_ctx)
+{
+	struct max9296 *priv = dev_get_drvdata(dev);
+	struct gmsl_stream *g_stream;
+	struct reg_pair *map_list;
+	u32 arr_sz = 0;
+	int pipe_id = 0;
+	u32 i = 0;
+	u32 j = 0;
+	u32 vc_idx = 0;
+
+	for (i = 0; i < g_ctx->num_streams; i++) {
+		/* Base data type mapping: pipeX/RAW12/CSICNTR1 */
+		struct reg_pair map_pipe_raw12[] = {
+			/* addr, val */
+			{MAX9296_TX11_PIPE_X_EN_ADDR, 0x7},
+			{MAX9296_TX45_PIPE_X_DST_CTRL_ADDR, 0x15},
+			{MAX9296_PIPE_X_SRC_0_MAP_ADDR, 0x2C},
+			{MAX9296_PIPE_X_DST_0_MAP_ADDR, 0x2C},
+			{MAX9296_PIPE_X_SRC_1_MAP_ADDR, 0x00},
+			{MAX9296_PIPE_X_DST_1_MAP_ADDR, 0x00},
+			{MAX9296_PIPE_X_SRC_2_MAP_ADDR, 0x01},
+			{MAX9296_PIPE_X_DST_2_MAP_ADDR, 0x01},
+		};
+
+		/* Base data type mapping: pipeX/EMBED/CSICNTR1 */
+		struct reg_pair map_pipe_embed[] = {
+			/* addr, val */
+			{MAX9296_TX11_PIPE_X_EN_ADDR, 0x7},
+			{MAX9296_TX45_PIPE_X_DST_CTRL_ADDR, 0x15},
+			{MAX9296_PIPE_X_SRC_0_MAP_ADDR, 0x12},
+			{MAX9296_PIPE_X_DST_0_MAP_ADDR, 0x12},
+			{MAX9296_PIPE_X_SRC_1_MAP_ADDR, 0x00},
+			{MAX9296_PIPE_X_DST_1_MAP_ADDR, 0x00},
+			{MAX9296_PIPE_X_SRC_2_MAP_ADDR, 0x01},
+			{MAX9296_PIPE_X_DST_2_MAP_ADDR, 0x01},
+		};
+
+		g_stream = &g_ctx->streams[i];
+		g_stream->des_pipe = MAX9296_PIPE_INVALID;
+
+		if (g_stream->st_data_type == GMSL_CSI_DT_RAW_12) {
+			map_list = map_pipe_raw12;
+			arr_sz = ARRAY_SIZE(map_pipe_raw12);
+		} else if (g_stream->st_data_type == GMSL_CSI_DT_EMBED) {
+			map_list = map_pipe_embed;
+			arr_sz = ARRAY_SIZE(map_pipe_embed);
+		} else if (g_stream->st_data_type == GMSL_CSI_DT_UED_U1) {
+			dev_dbg(dev,
+				"%s: No mapping for GMSL_CSI_DT_UED_U1\n",
+				__func__);
+			continue;
+		} else {
+			dev_err(dev, "%s: Invalid data type\n", __func__);
+			return -EINVAL;
+		}
+
+		pipe_id = max9296_get_available_pipe(dev,
+				g_stream->st_data_type, g_ctx->dst_csi_port);
+		if (pipe_id < 0)
+			return pipe_id;
+
+		for (j = 0, vc_idx = 3; j < arr_sz; j++, vc_idx += 2) {
+			/* update pipe configuration */
+			map_list[j].addr += (0x40 * pipe_id);
+			/* update vc id configuration */
+			if (vc_idx < arr_sz)
+				map_list[vc_idx].val |=
+					(g_ctx->dst_vc << 6);
+
+			max9296_write_reg(dev, map_list[j].addr,
+						map_list[j].val);
+		}
+
+		/* Set stream id select input */
+		if (g_stream->st_id_sel == GMSL_ST_ID_UNUSED) {
+			dev_err(dev, "%s: Invalid stream st_id_sel\n",
+				__func__);
+			return -EINVAL;
+		}
+
+		g_stream->des_pipe = MAX9296_PIPE_X_ST_SEL_ADDR + pipe_id;
+
+		/* Update pipe internals */
+		priv->pipe[pipe_id].st_count++;
+		priv->pipe[pipe_id].st_id_sel = g_stream->st_id_sel;
+	}
+
+	return 0;
+}
+
+int max9296_start_streaming(struct device *dev, struct device *s_dev)
+{
+	struct max9296 *priv = dev_get_drvdata(dev);
+	struct gmsl_link_ctx *g_ctx;
+	struct gmsl_stream *g_stream;
+	int err = 0;
+	unsigned int i = 0;
+
+	err = max9296_get_sdev_idx(dev, s_dev, &i);
+	if (err)
+		return err;
+
+	mutex_lock(&priv->lock);
+	g_ctx = priv->sources[i].g_ctx;
+
+	for (i = 0; i < g_ctx->num_streams; i++) {
+		g_stream = &g_ctx->streams[i];
+
+		if (g_stream->des_pipe != MAX9296_PIPE_INVALID)
+			max9296_write_reg(dev, g_stream->des_pipe,
+						g_stream->st_id_sel);
+	}
+	mutex_unlock(&priv->lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(max9296_start_streaming);
+
+int max9296_stop_streaming(struct device *dev, struct device *s_dev)
+{
+	struct max9296 *priv = dev_get_drvdata(dev);
+	struct gmsl_link_ctx *g_ctx;
+	struct gmsl_stream *g_stream;
+	int err = 0;
+	unsigned int i = 0;
+
+	err = max9296_get_sdev_idx(dev, s_dev, &i);
+	if (err)
+		return err;
+
+	mutex_lock(&priv->lock);
+	g_ctx = priv->sources[i].g_ctx;
+
+	for (i = 0; i < g_ctx->num_streams; i++) {
+		g_stream = &g_ctx->streams[i];
+
+		if (g_stream->des_pipe != MAX9296_PIPE_INVALID)
+			max9296_write_reg(dev, g_stream->des_pipe,
+						MAX9296_RESET_ST_ID);
+	}
+
+	mutex_unlock(&priv->lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(max9296_stop_streaming);
+
+int max9296_setup_streaming(struct device *dev, struct device *s_dev)
+{
+	struct max9296 *priv = dev_get_drvdata(dev);
+	struct gmsl_link_ctx *g_ctx;
+	int err = 0;
+	unsigned int i = 0;
+	u16 lane_ctrl_addr;
+
+	err = max9296_get_sdev_idx(dev, s_dev, &i);
+	if (err)
+		return err;
+
+	mutex_lock(&priv->lock);
+	if (priv->sources[i].st_enabled)
+		goto ret;
+
+	g_ctx = priv->sources[i].g_ctx;
+
+	err = max9296_setup_pipeline(dev, g_ctx);
+	if (err)
+		goto ret;
+
+	/* Derive CSI lane map register */
+	switch(g_ctx->dst_csi_port) {
+	case GMSL_CSI_PORT_A:
+	case GMSL_CSI_PORT_D:
+		lane_ctrl_addr = MAX9296_LANE_CTRL1_ADDR;
+		break;
+	case GMSL_CSI_PORT_B:
+	case GMSL_CSI_PORT_E:
+		lane_ctrl_addr = MAX9296_LANE_CTRL2_ADDR;
+		break;
+	case GMSL_CSI_PORT_C:
+		lane_ctrl_addr = MAX9296_LANE_CTRL0_ADDR;
+		break;
+	case GMSL_CSI_PORT_F:
+		lane_ctrl_addr = MAX9296_LANE_CTRL3_ADDR;
+		break;
+	default:
+		dev_err(dev, "%s: invalid gmsl csi port!\n", __func__);
+		err = -EINVAL;
+		goto ret;
+	};
+
+	/*
+	 * rewrite num_lanes to same dst port should not be an issue,
+	 * as the device compatibility is already
+	 * checked during sdev registration against the des properties.
+	 */
+	max9296_write_reg(dev, lane_ctrl_addr,
+		MAX9296_LANE_CTRL_MAP(g_ctx->num_csi_lanes-1));
+
+	if (!priv->lane_setup) {
+		max9296_write_reg(dev,
+			MAX9296_DST_CSI_MODE_ADDR, priv->csi_mode);
+		max9296_write_reg(dev,
+			MAX9296_LANE_MAP1_ADDR, priv->lane_mp1);
+		max9296_write_reg(dev,
+			MAX9296_LANE_MAP2_ADDR, priv->lane_mp2);
+		max9296_write_reg(dev,
+			MAX9296_PHY1_CLK_ADDR, MAX9296_PHY1_CLK);
+
+		priv->lane_setup = true;
+	}
+
+	priv->sources[i].st_enabled = true;
+
+ret:
+	mutex_unlock(&priv->lock);
+	return err;
+}
+EXPORT_SYMBOL(max9296_setup_streaming);
+
+static bool max9296_dynamic_update = true;
+module_param(max9296_dynamic_update, bool, 0664);
+MODULE_PARM_DESC(max9296_dynamic_update, "Update max9296 settings dynamically");
+
+
+static char *max9296_setting_verison = "1.0.0.8";
+module_param(max9296_setting_verison, charp, 0444);
+MODULE_PARM_DESC(max9296_setting_verison, "Print max9296 setting version");
+
+static struct reg_pair map_cmu_regulator[] = {
+	{0x0302, 0x10}, // Increase CMU regulator voltage
+};
+
+static struct reg_pair map_pipe_opt[] = {
+	{0x1458, 0x28}, // PHY A Optimization
+	{0x1459, 0x68}, // PHY A Optimization
+	{0x1558, 0x28}, // PHY B Optimization
+	{0x1559, 0x68}, // PHY B Optimization
+	{0x0010, 0x31}, // One-shot reset  enable auto-link
+
+	{0x044A, 0x50}, // 4 lanes on port A, write 0x50 for 2 lanes
+	{0x0320, 0x2F}, // 1500Mbps/lane on port A
+//	{0x031C, 0x00}, // Do not un-double 8bpp (Un-double 8bpp data)
+//	{0x031F, 0x00}, // Do not un-double 8bpp
+	{0x0473, 0x10}, // 0x02: ALT_MEM_MAP8, 0x10: ALT2_MEM_MAP8
+	// VC2 VS will come from pipe Z, not needed for pipe U
+};
+
+static struct reg_pair map_pipe_x_control[] = {
+	/* addr, val */
+	{0x040B, 0x0F}, // Enable 4 mappings for Pipe X
+	{0x040D, 0x1E}, // Map Depth VC0
+	{0x040E, 0x1E},
+	{0x040F, 0x00}, // Map frame start  VC0
+	{0x0410, 0x00},
+	{0x0411, 0x01}, // Map frame end  VC0
+	{0x0412, 0x01},
+	{0x0413, 0x12}, // Map EMB8, VC0
+	{0x0414, 0x12},
+	{0x042D, 0x55}, // All mappings to PHY1 (master for port A)
+
+	// SEQ_MISS_EN: Disabled / DIS_PKT_DET: Disabled
+	{0x0100, 0x23}, // pipe X
+};
+
+static struct reg_pair map_pipe_y_control[] = {
+	/* addr, val */
+	{0x044B, 0x0F}, // Enable 4 mappings for Pipe Y
+	{0x044D, 0x5E}, // Map RGB VC1
+	{0x044E, 0x5E},
+	{0x044F, 0x40}, // Map frame start  VC1
+	{0x0450, 0x40},
+	{0x0451, 0x41}, // Map frame end  VC1
+	{0x0452, 0x41},
+	{0x0453, 0x52}, // Map EMB8, VC1
+	{0x0454, 0x52},
+	{0x046D, 0x55}, // All mappings to PHY1 (master for port A)
+
+	// SEQ_MISS_EN: Disabled / DIS_PKT_DET: Disabled
+	{0x0112, 0x23}, // pipe Y
+};
+
+static struct reg_pair map_pipe_z_y8_y8i_control[] = {
+	/* addr, val */
+	{0x048B, 0x0F}, // Enable 4 mappings for Pipe Z
+	{0x048D, 0xAA}, // Map Y8 VC2
+	{0x048E, 0xAA},
+	{0x048F, 0x80}, // Map frame start  VC2
+	{0x0490, 0x80},
+	{0x0491, 0x81}, // Map frame end  VC2
+	{0x0492, 0x81},
+	{0x0493, 0x9E}, // Map Y8I, VC2
+	{0x0494, 0x9E},
+	{0x04AD, 0x55}, // Map to PHY1 (master for port A)
+
+	// SEQ_MISS_EN: Disabled / DIS_PKT_DET: Disabled
+	{0x0124, 0x23}, // pipe Z
+};
+
+static struct reg_pair map_pipe_z_y12i_control[] = {
+	/* addr, val */
+	{0x048B, 0x07}, // Enable 3 mappings for Pipe Z
+	{0x048D, 0xA4}, // Map Y12I VC2
+	{0x048E, 0xA4},
+	{0x048F, 0x80}, // Map frame start  VC2
+	{0x0490, 0x80},
+	{0x0491, 0x81}, // Map frame end  VC2
+	{0x0492, 0x81},
+	{0x0493, 0x00}, // Reset to unmap EMB8, VC2
+	{0x0494, 0x00},
+	{0x04AD, 0x15}, // Map to PHY1 (master for port A)
+
+	// SEQ_MISS_EN: Disabled / DIS_PKT_DET: Disabled
+	{0x0124, 0x23}, // pipe Z
+};
+
+static struct reg_pair map_pipe_u_control[] = {
+	/* addr, val */
+	{0x04CB, 0x07}, // Enable 3 mappings for Pipe U
+	{0x04CD, 0xEA}, // Map IMUI VC3
+	{0x04CE, 0xEA},
+	{0x04CF, 0xC0}, // Map frame start  VC3
+	{0x04D0, 0xC0},
+	{0x04D1, 0xC1}, // Map frame end  VC3
+	{0x04D2, 0xC1},
+	{0x04ED, 0x15}, // Map to PHY1 (master for port A)
+
+	// SEQ_MISS_EN: Disabled / DIS_PKT_DET: Disabled
+	{0x0136, 0x23}, // pipe U
+};
+
+static struct reg_pair map_depth_trigger[] = {
+	{0x02C5, 0x82}, // #MFP7
+	{0x02C6, 0x1F},
+};
+
+static struct reg_pair map_rgb_trigger[] = {
+	{0x02CB, 0x82}, // #MFP9
+	{0x02CC, 0x1B},
+};
+
+static bool init_done = false;
+static bool probe_done = false;
+
+static int max9296_set_registers(struct device *dev, struct reg_pair *map,
+				 u32 count)
+{
+	struct max9296 *priv = dev_get_drvdata(dev);
+	int err = 0;
+	u32 j = 0;
+
+	mutex_lock(&priv->lock);
+
+	dev_info(dev, "%s count %u\n", __func__, count);
+
+	for (j = 0; j < count; j++) {
+		err = max9296_write_reg(dev,
+			map[j].addr, map[j].val);
+		if (err != 0) break;
+	}
+
+	mutex_unlock(&priv->lock);
+
+	return err;
+}
+
+static int max9296_init_settings(struct device *dev)
+{
+	int err = 0;
+	struct max9296 *priv = dev_get_drvdata(dev);
+
+	// Set CMU
+	err = max9296_set_registers(dev, map_cmu_regulator,
+				    ARRAY_SIZE(map_cmu_regulator));
+	// Init control
+	err |= max9296_set_registers(dev, map_pipe_opt,
+				     ARRAY_SIZE(map_pipe_opt));
+
+	// Pipe X
+	err |= max9296_set_registers(dev, map_pipe_x_control,
+				     ARRAY_SIZE(map_pipe_x_control));
+	// Pipe Y
+	err |= max9296_set_registers(dev, map_pipe_y_control,
+				     ARRAY_SIZE(map_pipe_y_control));
+	// Pipe Z
+	if (priv->ir_type_value == Y8_Y8I)
+		err |= max9296_set_registers(dev, map_pipe_z_y8_y8i_control,
+				     ARRAY_SIZE(map_pipe_z_y8_y8i_control));
+	else
+		err |= max9296_set_registers(dev, map_pipe_z_y12i_control,
+				     ARRAY_SIZE(map_pipe_z_y12i_control));
+
+	// Pipe U
+	err |= max9296_set_registers(dev, map_pipe_u_control,
+				     ARRAY_SIZE(map_pipe_u_control));
+
+	// Trigger Depth
+	err |= max9296_set_registers(dev, map_depth_trigger,
+				     ARRAY_SIZE(map_depth_trigger));
+	// Trigger RGB
+	err |= max9296_set_registers(dev, map_rgb_trigger,
+				     ARRAY_SIZE(map_rgb_trigger));
+
+	if (err == 0) {
+		dev_info(dev, "%s done\n", __func__);
+		init_done = true;
+	}
+
+	return err;
+}
+
+int max9296_update_pipe(struct device *dev, int sensor_type, u32 fourcc)
+{
+	int err = 0;
+	struct max9296 *priv;
+	const int reset_sleep = 5;
+	if (!probe_done)
+		return 0;
+
+	if (!max9296_dynamic_update) {
+		dev_info(dev, "%s, don't update dynamically\n", __func__);
+		return 0;
+	}
+
+	dev_dbg(dev, "%s st %d, fourcc %u\n", __func__, sensor_type, fourcc);
+
+	if (!init_done) {
+		dev_info(dev, "%s, SerDes device may not exist\n", __func__);
+		return 0;
+	}
+
+	if (sensor_type != IR_SENSOR)
+		return 0;
+
+	priv = dev_get_drvdata(dev);
+	if ((priv->ir_type_value != Y8_Y8I) &&
+	    (fourcc == V4L2_PIX_FMT_GREY || fourcc == V4L2_PIX_FMT_Y8I)) {
+		// Init control
+		err |= max9296_set_registers(dev, map_pipe_opt,
+					     ARRAY_SIZE(map_pipe_opt));
+		/* needed to settle serdes line after reset */
+		usleep_range(reset_sleep * 1000, reset_sleep * 1000 + 500);
+		// Pipe Z
+		err = max9296_set_registers(dev, map_pipe_z_y8_y8i_control,
+					ARRAY_SIZE(map_pipe_z_y8_y8i_control));
+		if (err == 0)
+			priv->ir_type_value = Y8_Y8I;
+	} else if ((priv->ir_type_value != Y12I) &&
+		   (fourcc == V4L2_PIX_FMT_Y12I)) {
+		// Init control
+		err |= max9296_set_registers(dev, map_pipe_opt,
+					     ARRAY_SIZE(map_pipe_opt));
+		/* needed to settle serdes line after reset */
+		usleep_range(reset_sleep * 1000, reset_sleep * 1000 + 500);
+		// Pipe Z
+		err = max9296_set_registers(dev, map_pipe_z_y12i_control,
+					ARRAY_SIZE(map_pipe_z_y12i_control));
+		if (err == 0)
+			priv->ir_type_value = Y12I;
+	}
+
+	return err;
+}
+EXPORT_SYMBOL(max9296_update_pipe);
+
+static int max9296_get_dump(struct device *dev, char *data_addr,
+			    struct reg_pair *pair, u32 pair_size)
+{
+	struct max9296 *priv = dev_get_drvdata(dev);
+	int err;
+	u32 val = 0;
+	char *addr = data_addr;
+	int data_size = 0;
+	int cnt = 0;
+	u32 j = 0;
+
+	mutex_lock(&priv->lock);
+
+	for (j = 0; j < pair_size; j++) {
+		val = 0;
+		err = regmap_read(priv->regmap, pair[j].addr, &val);
+
+		if (!err) {
+			cnt = snprintf(addr, PAGE_SIZE, "0x%04x:0x%x\n",
+				       pair[j].addr, val);
+			addr += cnt;
+			data_size += cnt;
+			dev_info(dev,
+				"%s:i2c read, addr 0x%x, value %x\n",
+				__func__, pair[j].addr, val);
+		} else {
+			dev_warn(dev,
+				"%s:i2c read, err %x, addr 0x%x, value %x\n",
+				__func__, err, pair[j].addr, val);
+		}
+	};
+
+	mutex_unlock(&priv->lock);
+
+	return data_size;
+}
+
+#ifdef CONFIG_SYSFS
+
+static ssize_t max9296_dev_dump_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	char *data_addr = buf;
+	int data_size = 0;
+	int count = 0;
+
+	if (!buf)
+		return -ENOMEM;
+
+	data_size = max9296_get_dump(dev, data_addr, map_cmu_regulator,
+				     ARRAY_SIZE(map_cmu_regulator));
+	count += data_size;
+	data_addr += data_size;
+
+	data_size = max9296_get_dump(dev, data_addr, map_pipe_opt,
+				     ARRAY_SIZE(map_pipe_opt));
+	count += data_size;
+	data_addr += data_size;
+
+	data_size = max9296_get_dump(dev, data_addr, map_pipe_x_control,
+				     ARRAY_SIZE(map_pipe_x_control));
+	count += data_size;
+	data_addr += data_size;
+
+	data_size = max9296_get_dump(dev, data_addr, map_pipe_y_control,
+				     ARRAY_SIZE(map_pipe_y_control));
+	count += data_size;
+	data_addr += data_size;
+
+	data_size = max9296_get_dump(dev, data_addr, map_pipe_z_y8_y8i_control,
+				     ARRAY_SIZE(map_pipe_z_y8_y8i_control));
+	count += data_size;
+	data_addr += data_size;
+
+	data_size = max9296_get_dump(dev, data_addr, map_pipe_u_control,
+				     ARRAY_SIZE(map_pipe_u_control));
+	count += data_size;
+	data_addr += data_size;
+
+	data_size = max9296_get_dump(dev, data_addr, map_depth_trigger,
+				     ARRAY_SIZE(map_depth_trigger));
+	count += data_size;
+	data_addr += data_size;
+
+	data_size = max9296_get_dump(dev, data_addr, map_rgb_trigger,
+				     ARRAY_SIZE(map_rgb_trigger));
+	count += data_size;
+	data_addr += data_size;
+	*data_addr = '0';
+
+	dev_info(dev, "%s, buf %p, count %d, \n", __func__, buf, count);
+
+	return count;
+}
+
+static DEVICE_ATTR(register_dump, 0444, max9296_dev_dump_show, NULL);
+
+static ssize_t refresh_setting_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	int ret;
+
+	ret = max9296_init_settings(dev);
+	if (ret)
+		return ret;
+
+	return count;
+}
+static DEVICE_ATTR_WO(refresh_setting);
+
+static struct attribute *max9296_attributes[] = {
+	&dev_attr_register_dump.attr,
+	&dev_attr_refresh_setting.attr,
+	NULL
+};
+
+static const struct attribute_group max9296_attr_group = {
+	.attrs = max9296_attributes,
+};
+
+#endif /* CONFIG_SYSFS */
+
+static const struct of_device_id max9296_of_match[] = {
+	{ .compatible = "maxim,max9296", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, max9296_of_match);
+
+static int max9296_parse_dt(struct max9296 *priv,
+				struct i2c_client *client)
+{
+	struct device_node *node = client->dev.of_node;
+	int err = 0;
+	const char *str_value;
+	int value;
+	const struct of_device_id *match;
+
+	if (!node)
+		return -EINVAL;
+
+	match = of_match_device(max9296_of_match, &client->dev);
+	if (!match) {
+		dev_err(&client->dev, "Failed to find matching dt id\n");
+		return -EFAULT;
+	}
+
+	err = of_property_read_string(node, "csi-mode", &str_value);
+	if (err < 0) {
+		dev_err(&client->dev, "csi-mode property not found\n");
+		return err;
+	}
+
+	if (!strcmp(str_value, "2x4")) {
+		priv->csi_mode = MAX9296_CSI_MODE_2X4;
+		priv->lane_mp1 = MAX9296_LANE_MAP1_2X4;
+		priv->lane_mp2 = MAX9296_LANE_MAP2_2X4;
+	} else if (!strcmp(str_value, "4x2")) {
+		priv->csi_mode = MAX9296_CSI_MODE_4X2;
+		priv->lane_mp1 = MAX9296_LANE_MAP1_4X2;
+		priv->lane_mp2 = MAX9296_LANE_MAP2_4X2;
+	} else {
+		dev_err(&client->dev, "invalid csi mode\n");
+		return -EINVAL;
+	}
+
+	err = of_property_read_u32(node, "max-src", &value);
+	if (err < 0) {
+		dev_err(&client->dev, "No max-src info\n");
+		return err;
+	}
+	priv->max_src = value;
+
+	priv->reset_gpio = of_get_named_gpio(node, "reset-gpios", 0);
+	if (priv->reset_gpio < 0) {
+		dev_err(&client->dev, "reset-gpios not found %d\n", err);
+		return err;
+	}
+
+	/* digital 1.2v */
+	if (of_get_property(node, "vdd_cam_1v2-supply", NULL)) {
+		priv->vdd_cam_1v2 = regulator_get(&client->dev, "vdd_cam_1v2");
+		if (IS_ERR(priv->vdd_cam_1v2)) {
+			dev_err(&client->dev,
+				"vdd_cam_1v2 regulator get failed\n");
+			err = PTR_ERR(priv->vdd_cam_1v2);
+			priv->vdd_cam_1v2 = NULL;
+			return err;
+		}
+	} else {
+		priv->vdd_cam_1v2 = NULL;
+	}
+
+	return 0;
+}
+
+static struct regmap_config max9296_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+	.cache_type = REGCACHE_RBTREE,
+};
+
+static int max9296_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
+{
+	struct max9296 *priv;
+	int err = 0;
+
+	dev_info(&client->dev, "[MAX9296]: probing GMSL Deserializer\n");
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+	priv->i2c_client = client;
+	priv->regmap = devm_regmap_init_i2c(priv->i2c_client,
+				&max9296_regmap_config);
+	if (IS_ERR(priv->regmap)) {
+		dev_err(&client->dev,
+			"regmap init failed: %ld\n", PTR_ERR(priv->regmap));
+		return -ENODEV;
+	}
+
+	err = max9296_parse_dt(priv, client);
+	if (err) {
+		dev_err(&client->dev, "unable to parse dt\n");
+		return -EFAULT;
+	}
+
+	max9296_pipes_reset(priv);
+
+	if (priv->max_src > MAX9296_MAX_SOURCES) {
+		dev_err(&client->dev,
+			"max sources more than currently supported\n");
+		return -EINVAL;
+	}
+
+	mutex_init(&priv->lock);
+
+	dev_set_drvdata(&client->dev, priv);
+
+	priv->ir_type_value = Y8_Y8I;
+
+#ifdef CONFIG_SYSFS
+	err = sysfs_create_group(&client->dev.kobj, &max9296_attr_group);
+	if (err)
+		dev_warn(&client->dev, "%s, failed to create sysfs, err %d",
+			 __func__, err);
+#endif /* CONFIG_SYSFS */
+
+	/* don't break probe stage */
+	err = max9296_init_settings(&client->dev);
+	if (err) {
+		dev_warn(&client->dev, "%s, failed to init settings \n",
+			 __func__);
+		err = 0;
+	}
+
+	probe_done = true;
+
+	/* dev communication gets validated when GMSL link setup is done */
+	dev_info(&client->dev, "%s:  success\n", __func__);
+
+	return err;
+}
+
+
+static int max9296_remove(struct i2c_client *client)
+{
+	struct max9296 *priv;
+
+	if (client != NULL) {
+		priv = dev_get_drvdata(&client->dev);
+
+#ifdef CONFIG_SYSFS
+		sysfs_remove_group(&client->dev.kobj, &max9296_attr_group);
+#endif /* CONFIG_SYSFS */
+
+		mutex_destroy(&priv->lock);
+		i2c_unregister_device(client);
+		client = NULL;
+	}
+
+	return 0;
+}
+
+static const struct i2c_device_id max9296_id[] = {
+	{ "max9296", 0 },
+	{ },
+};
+
+MODULE_DEVICE_TABLE(i2c, max9296_id);
+
+static struct i2c_driver max9296_i2c_driver = {
+	.driver = {
+		.name = "max9296",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(max9296_of_match),
+	},
+	.probe = max9296_probe,
+	.remove = max9296_remove,
+	.id_table = max9296_id,
+};
+
+static int __init max9296_init(void)
+{
+	return i2c_add_driver(&max9296_i2c_driver);
+}
+
+static void __exit max9296_exit(void)
+{
+	i2c_del_driver(&max9296_i2c_driver);
+}
+
+module_init(max9296_init);
+module_exit(max9296_exit);
+
+MODULE_DESCRIPTION("Dual GMSL Deserializer driver max9296");
+MODULE_AUTHOR("Sudhir Vyas <svyas@nvidia.com");
+MODULE_LICENSE("GPL v2");
diff -urN ori/kernel/nvidia/drivers/media/platform/tegra/camera/sensor_common.c intel/kernel/nvidia/drivers/media/platform/tegra/camera/sensor_common.c
--- ori/kernel/nvidia/drivers/media/platform/tegra/camera/sensor_common.c	2022-08-11 11:15:42.000000000 +0800
+++ intel/kernel/nvidia/drivers/media/platform/tegra/camera/sensor_common.c	2023-04-10 17:17:16.063081193 +0800
@@ -265,6 +265,10 @@
 		*format = V4L2_PIX_FMT_UYVY;
 	else if (strncmp(pixel_t, "yuv_vyuy16", size) == 0)
 		*format = V4L2_PIX_FMT_VYUY;
+	else if (strncmp(pixel_t, "grey_y8", size) == 0)
+		*format = V4L2_PIX_FMT_GREY;
+	else if (strncmp(pixel_t, "grey_y16", size) == 0)
+		*format = V4L2_PIX_FMT_Y16;
 	else {
 		pr_err("%s: Need to extend format%s\n", __func__, pixel_t);
 		return -EINVAL;
diff -urN ori/kernel/nvidia/drivers/media/platform/tegra/camera/vi/channel.c intel/kernel/nvidia/drivers/media/platform/tegra/camera/vi/channel.c
--- ori/kernel/nvidia/drivers/media/platform/tegra/camera/vi/channel.c	2022-08-11 11:15:42.000000000 +0800
+++ intel/kernel/nvidia/drivers/media/platform/tegra/camera/vi/channel.c	2023-04-10 17:17:20.595069716 +0800
@@ -40,6 +40,10 @@
 #include <media/v4l2-dv-timings.h>
 #include <media/vi.h>
 
+#include <media/gmsl-link.h>
+#include <media/max9296.h>
+#include <media/max9295.h>
+
 #include <linux/clk/tegra.h>
 #define CREATE_TRACE_POINTS
 #include <trace/events/camera_common.h>
@@ -208,7 +212,12 @@
 	 * different. Aligned width also may force a sensor mode change other
 	 * than the requested one
 	 */
-	*height = clamp(*height, TEGRA_MIN_HEIGHT, TEGRA_MAX_HEIGHT);
+    /* For D4XX IMU, the total size of one frame is 32 while the width:height
+     * should be set to 32:1. Therefore, ignored the clamping on height here by
+     * replacing TEGRA_MIN_HEIGHT with 1U ((unsigned int) 1).
+     */
+    *height = clamp(*height, 1U /*TEGRA_MIN_HEIGHT*/, TEGRA_MAX_HEIGHT);
+
 
 	/* Clamp the requested bytes per line value. If the maximum bytes per
 	 * line value is zero, the module doesn't support user configurable line
@@ -1037,7 +1046,8 @@
 
 	cap->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;
 	cap->device_caps |= V4L2_CAP_EXT_PIX_FORMAT;
-	cap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;
+	cap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS |
+			V4L2_CAP_META_CAPTURE;
 
 	strlcpy(cap->driver, "tegra-video", sizeof(cap->driver));
 	strlcpy(cap->card, chan->video->name, sizeof(cap->card));
@@ -2049,6 +2059,15 @@
 	v4l2_fill_mbus_format(&fmt.format, pix, vfmt->code);
 
 	ret = v4l2_subdev_call(sd, pad, set_fmt, &cfg, &fmt);
+	/* if set_fmt not found target format and specify the default one, update
+	* pix->pixelformat and vfmt to keep aligned with format set by set_fmt
+	*/
+	if (!ret && fmt.format.code != vfmt->code) {
+		int idx = tegra_core_get_idx_by_code(chan, fmt.format.code, 0);
+		pix->pixelformat = tegra_core_get_fourcc_by_idx(chan, idx);
+		vfmt = tegra_core_get_format_by_fourcc(chan, pix->pixelformat);
+	}
+
 	if (ret == -ENOIOCTLCMD)
 		return -ENOTTY;
 
@@ -2080,6 +2099,7 @@
 	const struct tegra_video_format *vfmt;
 	struct v4l2_subdev_format fmt;
 	struct v4l2_subdev *sd = chan->subdev_on_csi;
+	struct tegra_mc_vi *vi = chan->vi;
 	struct v4l2_subdev_pad_config cfg = {};
 	int ret = 0;
 
@@ -2087,6 +2107,22 @@
 	if (!vfmt)
 		return -EINVAL;
 
+	if (vi->ser_dev) {
+		ret = max9295_update_pipe(vi->ser_dev, chan->id, vfmt->fourcc);
+		dev_dbg(vi->ser_dev, "%s, chan id %d, data_type %x\n",
+				__func__, chan->id, vfmt->img_dt);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (vi->dser_dev) {
+		ret = max9296_update_pipe(vi->dser_dev, chan->id, vfmt->fourcc);
+		dev_dbg(vi->dser_dev, "%s, chan id %d, data_type %x\n",
+				__func__, chan->id, vfmt->img_dt);
+		if (ret < 0)
+			return ret;
+	}
+
 	fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
 	fmt.pad = 0;
 	v4l2_fill_mbus_format(&fmt.format, pix, vfmt->code);
@@ -2214,6 +2250,62 @@
 	return ret;
 }
 
+static int
+__tegra_channel_get_parm(struct tegra_channel *chan,
+                        struct v4l2_streamparm *a)
+{
+	struct v4l2_subdev *sd = chan->subdev_on_csi;
+	int ret = 0;
+	struct v4l2_subdev_frame_interval interval;
+
+	/* dmipx: fixing G_PARM EINVAL error */
+//	ret = v4l2_subdev_call(sd, video, g_frame_interval, &interval);
+	ret = sd->ops->video->g_frame_interval(sd, &interval);
+
+	a->parm.capture.timeperframe.numerator = interval.interval.numerator;
+	a->parm.capture.timeperframe.denominator = interval.interval.denominator;
+
+	return ret;
+}
+
+static int tegra_channel_get_parm(struct file *file, void *fh, struct v4l2_streamparm *a)
+{
+	struct tegra_channel *chan = video_drvdata(file);
+
+	a->parm.capture.timeperframe.numerator = 1;
+	a->parm.capture.timeperframe.denominator = 12;
+
+	return __tegra_channel_get_parm(chan, a);
+}
+
+static int
+__tegra_channel_set_parm(struct tegra_channel *chan,
+                        struct v4l2_streamparm *a)
+{
+	struct v4l2_subdev *sd = chan->subdev_on_csi;
+	int ret = 0;
+
+	struct v4l2_subdev_frame_interval interval;
+	interval.pad = 1;
+	interval.interval.numerator = a->parm.capture.timeperframe.numerator;
+	interval.interval.denominator = a->parm.capture.timeperframe.denominator;
+
+	ret = v4l2_subdev_call(sd, video, s_frame_interval, &interval);
+	if (ret == -ENOIOCTLCMD)
+			return -ENOTTY;
+
+	return ret;
+}
+static int tegra_channel_set_parm(struct file *file, void *fh, struct v4l2_streamparm *a)
+{
+	struct tegra_channel *chan = video_drvdata(file);
+
+	if (vb2_is_busy(&chan->queue))
+			return -EBUSY;
+
+	return __tegra_channel_set_parm(chan, a);
+}
+
 #ifdef CONFIG_COMPAT
 #if LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0)
 static long tegra_channel_compat_ioctl(struct file *filp,
@@ -2270,6 +2362,9 @@
 	.vidioc_s_input			= tegra_channel_s_input,
 	.vidioc_log_status		= tegra_channel_log_status,
 	.vidioc_default			= tegra_channel_default_ioctl,
+    .vidioc_g_parm			= tegra_channel_get_parm,
+    .vidioc_s_parm			= tegra_channel_set_parm,
+
 };
 
 static int tegra_channel_close(struct file *fp);
@@ -2406,6 +2501,331 @@
 	return ret;
 }
 
+static int tegra_metadata_open(struct file *fp)
+{
+	struct video_device *vdev = video_devdata(fp);
+	struct tegra_channel *chan = video_get_drvdata(vdev);
+	int ret;
+
+	mutex_lock(&chan->embedded.lock);
+	ret = v4l2_fh_open(fp);
+	mutex_unlock(&chan->embedded.lock);
+
+	return ret;
+}
+
+static int tegra_metadata_close(struct file *fp)
+{
+	struct video_device *vdev = video_devdata(fp);
+	struct tegra_channel *chan = video_get_drvdata(vdev);
+	int ret = _vb2_fop_release(fp, &chan->embedded.lock);
+
+	return ret;
+}
+
+static const struct v4l2_file_operations tegra_metadata_fops = {
+	.owner          = THIS_MODULE,
+	.unlocked_ioctl = video_ioctl2,
+	.open           = tegra_metadata_open,
+	.release        = tegra_metadata_close,
+	.read           = vb2_fop_read,
+	.poll           = vb2_fop_poll,
+	.mmap           = vb2_fop_mmap,
+};
+
+static int tegra_metadata_querycap(struct file *file, void *fh,
+                                 struct v4l2_capability *cap)
+{
+	struct v4l2_fh *vfh = file->private_data;
+	struct tegra_channel *chan = video_drvdata(file);
+
+	/* FIXME: why do Device Caps show V4L2_CAP_EXT_PIX_FORMAT? */
+	cap->device_caps = V4L2_CAP_META_CAPTURE | V4L2_CAP_STREAMING;
+	cap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS |
+			V4L2_CAP_EXT_PIX_FORMAT | V4L2_CAP_VIDEO_CAPTURE;
+
+	strlcpy(cap->driver, "tegra-embedded", sizeof(cap->driver));
+	strlcpy(cap->card, vfh->vdev->name, sizeof(cap->card));
+	snprintf(cap->bus_info, sizeof(cap->bus_info), "platform:%s:%u",
+			dev_name(chan->vi->dev), chan->port[0]);
+
+	return 0;
+}
+
+static int tegra_metadata_enum_format(struct file *file, void *fh,
+                                     struct v4l2_fmtdesc *f)
+{
+	if (f->index)
+		return -EINVAL;
+
+	f->pixelformat = V4L2_META_FMT_D4XX;
+	strlcpy(f->description, "D4XX metadata format", sizeof(f->description));
+
+	return 0;
+}
+
+static int tegra_metadata_get_format(struct file *file, void *fh,
+                                    struct v4l2_format *format)
+{
+	struct v4l2_fh *vfh = file->private_data;
+	struct v4l2_meta_format *fmt = &format->fmt.meta;
+
+	if (format->type != vfh->vdev->queue->type)
+		return -EINVAL;
+
+	memset(fmt, 0, sizeof(*fmt));
+
+	fmt->dataformat = V4L2_META_FMT_D4XX;
+	fmt->buffersize = 255;
+
+	return 0;
+}
+static int tegra_metadata_set_format(struct file *file, void *fh,
+                                    struct v4l2_format *format)
+{
+   return 0;
+}
+
+static int tegra_metadata_try_format(struct file *file, void *fh,
+                                    struct v4l2_format *format)
+{
+    return 0;
+}
+static const struct v4l2_ioctl_ops tegra_metadata_ioctl_ops = {
+	.vidioc_querycap                = tegra_metadata_querycap,
+	.vidioc_enum_fmt_meta_cap       = tegra_metadata_enum_format,
+	.vidioc_g_fmt_meta_cap          = tegra_metadata_get_format,
+	.vidioc_s_fmt_meta_cap          = tegra_metadata_set_format,
+	.vidioc_try_fmt_meta_cap        = tegra_metadata_try_format,
+	.vidioc_reqbufs                 = vb2_ioctl_reqbufs,
+	.vidioc_querybuf                = vb2_ioctl_querybuf,
+	.vidioc_qbuf                    = vb2_ioctl_qbuf,
+	.vidioc_dqbuf                   = vb2_ioctl_dqbuf,
+	.vidioc_create_bufs             = vb2_ioctl_create_bufs,
+	.vidioc_expbuf                  = vb2_ioctl_expbuf,
+	.vidioc_streamon                = vb2_ioctl_streamon,
+	.vidioc_streamoff               = vb2_ioctl_streamoff,
+};
+
+static int tegra_metadata_queue_setup(struct vb2_queue *vq,
+                    unsigned int *nbuffers, unsigned int *nplanes,
+                    unsigned int sizes[], struct device *alloc_devs[])
+{
+	struct tegra_channel *chan = vb2_get_drv_priv(vq);
+
+	if (*nplanes) {
+		if (*nplanes != 1)
+			return -EINVAL;
+
+		if (sizes[0] < 255)
+			return -EINVAL;
+
+		return 0;
+	}
+
+	*nplanes = 1;
+	sizes[0] = 255;
+	alloc_devs[0] = chan->vi->dev;
+
+
+	return 0;
+}
+
+static int tegra_metadata_buffer_prepare(struct vb2_buffer *vb)
+{
+	if (vb->num_planes != 1)
+		return -EINVAL;
+
+	if (vb2_plane_size(vb, 0) < 255)
+		return -EINVAL;
+
+	return 0;
+}
+
+static void tegra_metadata_buffer_queue(struct vb2_buffer *vb)
+{
+	struct tegra_channel *chan = vb2_get_drv_priv(vb->vb2_queue);
+
+	spin_lock(&chan->embedded.spin_lock);
+	if (chan->embedded.num_buffers < 16) {
+		chan->embedded.buffers[chan->embedded.head] = vb;
+		chan->embedded.head++;
+		if (chan->embedded.head > 15)
+			chan->embedded.head = chan->embedded.head - 16;
+		chan->embedded.num_buffers++;
+	}
+	spin_unlock(&chan->embedded.spin_lock);
+}
+
+static int tegra_metadata_start_streaming(struct vb2_queue *vq, unsigned int count)
+{
+	return 0;
+}
+
+static void tegra_metadata_stop_streaming(struct vb2_queue *vq)
+{
+	struct tegra_channel *chan = vb2_get_drv_priv(vq);
+	int i = 0;
+
+	spin_lock(&chan->embedded.spin_lock);
+	for (i = 0; i < chan->embedded.num_buffers; i++) {
+		struct vb2_buffer *evb;
+		evb = chan->embedded.buffers[chan->embedded.tail];
+		chan->embedded.buffers[chan->embedded.tail] = NULL;
+		chan->embedded.tail++;
+		if (chan->embedded.tail > 15)
+			chan->embedded.tail = chan->embedded.tail - 16;
+		vb2_buffer_done(evb, VB2_BUF_STATE_ERROR);
+	}
+	spin_unlock(&chan->embedded.spin_lock);
+
+	chan->embedded.head = 0;
+	chan->embedded.tail = 0;;
+	chan->embedded.num_buffers = 0;
+}
+
+static const struct vb2_ops tegra_metadata_qops = {
+	.queue_setup            = tegra_metadata_queue_setup,
+	.buf_prepare            = tegra_metadata_buffer_prepare,
+	.buf_queue              = tegra_metadata_buffer_queue,
+	.wait_prepare           = vb2_ops_wait_prepare,
+	.wait_finish            = vb2_ops_wait_finish,
+	.start_streaming        = tegra_metadata_start_streaming,
+	.stop_streaming         = tegra_metadata_stop_streaming,
+};
+
+int tegra_channel_init_video_embedded(struct tegra_channel *chan)
+{
+	struct video_device *video;
+	struct vb2_queue *queue = &chan->embedded.queue;
+	struct tegra_mc_vi *vi = chan->vi;
+	int ret;
+
+	mutex_init(&chan->embedded.lock);
+	spin_lock_init(&chan->embedded.spin_lock);
+
+	video = chan->embedded.video = video_device_alloc();
+	chan->embedded.pad.flags = MEDIA_PAD_FL_SINK;
+
+	ret = tegra_media_entity_init(&video->entity, 1,
+									&chan->embedded.pad, false, false);
+	if (ret < 0) {
+		video_device_release(video);
+		dev_err(vi->dev, "%s(): metadata entity init: %d\n",
+				__func__, ret);
+		return ret;
+	}
+
+	ret = v4l2_ctrl_handler_init(&chan->embedded.ctrl_handler,
+									MAX_CID_CONTROLS);
+	if (chan->embedded.ctrl_handler.error) {
+		dev_err(&video->dev, "failed to init control handler\n");
+		return ret;
+	}
+
+	video->fops = &tegra_metadata_fops;
+	video->v4l2_dev = &vi->v4l2_dev;
+	video->queue = queue;
+	snprintf(video->name, sizeof(video->name), "%s-metadata-%u",
+			dev_name(vi->dev), chan->port[0]);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0)
+	video->vfl_type = VFL_TYPE_GRABBER;
+#else
+	video->vfl_type = VFL_TYPE_VIDEO;
+	video->device_caps = V4L2_CAP_META_CAPTURE | V4L2_CAP_STREAMING;
+#endif
+	video->vfl_dir = VFL_DIR_RX;
+	video->release = video_device_release_empty;
+	video->ioctl_ops = &tegra_metadata_ioctl_ops;
+	video->ctrl_handler = &chan->embedded.ctrl_handler;
+	video->lock = &chan->embedded.lock;
+
+	video_set_drvdata(video, chan);
+
+#if defined(CONFIG_VIDEOBUF2_DMA_CONTIG)
+	/* get the buffers queue... */
+	ret = tegra_vb2_dma_init(vi->dev, &chan->embedded.alloc_ctx,
+					SZ_64K, &vi->vb2_dma_alloc_refcnt);
+	if (ret < 0)
+		goto ctx_alloc_error;
+
+#endif
+//#if defined(CONFIG_VIDEOBUF2_DMA_CONTIG)
+	/* get the buffers queue... */
+//     chan->embedded.alloc_ctx = vb2_dma_contig_init_ctx(vi->dev);
+//     if (IS_ERR(chan->embedded.alloc_ctx)) {
+//             dev_err(vi->dev, "%s(): vb2 buffer init: %ld\n", __func__,
+//                     PTR_ERR(chan->embedded.alloc_ctx));
+//             goto ctx_alloc_error;
+//     }
+//#endif
+
+	queue->type = V4L2_BUF_TYPE_META_CAPTURE;
+	queue->io_modes = VB2_MMAP | VB2_DMABUF | VB2_READ | VB2_USERPTR;
+	queue->lock = &chan->embedded.lock;
+	queue->drv_priv = chan;
+	queue->buf_struct_size = sizeof(struct tegra_channel_buffer);
+	queue->ops = &tegra_metadata_qops;
+#if defined(CONFIG_VIDEOBUF2_DMA_CONTIG)
+	queue->mem_ops = &vb2_dma_contig_memops;
+#endif
+	queue->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC |
+			V4L2_BUF_FLAG_TSTAMP_SRC_EOF;
+	ret = vb2_queue_init(queue);
+	if (ret < 0) {
+		dev_err(vi->dev, "%s(): metadata queue initialize: %d\n",
+				__func__, ret);
+		goto vb2_queue_error;
+	}
+
+	return 0;
+
+vb2_queue_error:
+#if defined(CONFIG_VIDEOBUF2_DMA_CONTIG)
+	tegra_vb2_dma_cleanup(vi->dev, chan->embedded.alloc_ctx,
+			&vi->vb2_dma_alloc_refcnt);
+ctx_alloc_error:
+#endif
+	media_entity_cleanup(&video->entity);
+
+	return ret;
+}
+
+int tegra_channel_cleanup_video_embedded(struct tegra_channel *chan)
+{
+	struct video_device *video = chan->embedded.video;
+	struct vb2_queue *queue = &chan->embedded.queue;
+	struct device *vi_unit_dev = tegra_channel_get_vi_unit(chan);
+
+	if (!video)
+		return -EINVAL;
+
+	video_unregister_device(video);
+
+	/* release embedded data buffer */
+	if (chan->emb_buf_size > 0) {
+		dma_free_coherent(vi_unit_dev,
+				chan->emb_buf_size,
+				chan->emb_buf_addr, chan->emb_buf);
+		chan->emb_buf_size = 0;
+		vb2_queue_release(queue);
+#if defined(CONFIG_VIDEOBUF2_DMA_CONTIG)
+		tegra_vb2_dma_cleanup(vi_unit_dev, chan->embedded.alloc_ctx,
+						&chan->vi->vb2_dma_alloc_refcnt);
+#endif
+	}
+
+	v4l2_ctrl_handler_free(&chan->embedded.ctrl_handler);
+
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	media_entity_cleanup(&video->entity);
+#endif
+
+	video_device_release(video);
+
+	return 0;
+}
+
 int tegra_channel_init_video(struct tegra_channel *chan)
 {
 	struct tegra_mc_vi *vi = chan->vi;
@@ -2594,6 +3014,13 @@
 			chan->emb_buf_size,
 			chan->emb_buf_addr, chan->emb_buf);
 		chan->emb_buf_size = 0;
+		vb2_queue_release(&chan->embedded.queue);
+#if defined(CONFIG_VIDEOBUF2_DMA_CONTIG)
+               tegra_vb2_dma_cleanup(vi_unit_dev, chan->embedded.alloc_ctx,
+                               &chan->vi->vb2_dma_alloc_refcnt);
+               //vb2_dma_contig_cleanup_ctx(chan->embedded.alloc_ctx);
+#endif
+		media_entity_cleanup(&chan->embedded.video->entity);
 	}
 
 	tegra_channel_dealloc_buffer_queue(chan);
diff -urN ori/kernel/nvidia/drivers/media/platform/tegra/camera/vi/graph.c intel/kernel/nvidia/drivers/media/platform/tegra/camera/vi/graph.c
--- ori/kernel/nvidia/drivers/media/platform/tegra/camera/vi/graph.c	2022-08-11 11:15:42.000000000 +0800
+++ intel/kernel/nvidia/drivers/media/platform/tegra/camera/vi/graph.c	2023-04-10 17:17:16.063081193 +0800
@@ -373,9 +373,14 @@
 	struct tegra_channel *chan =
 		container_of(notifier, struct tegra_channel, notifier);
 	struct tegra_vi_graph_entity *entity;
+	struct camera_common_data *s_data;
+	struct device_node *node;
+	struct sensor_mode_properties *sensor_mode = NULL;
+	int idx;
+
 	int ret;
 
-	dev_dbg(chan->vi->dev, "notify complete, all subdevs registered\n");
+	dev_err(chan->vi->dev, "notify complete, all subdevs registered\n");
 
 	/* Allocate video_device */
 	ret = tegra_channel_init_video(chan);
@@ -401,26 +406,60 @@
 		if (entity->entity != NULL) {
 			ret = tegra_vi_graph_build_one(chan, entity);
 			if (ret < 0)
-				goto graph_error;
+				goto link_error;
 		}
 	}
 
 	/* Create links for channels */
 	ret = tegra_vi_graph_build_links(chan);
 	if (ret < 0)
-		goto graph_error;
+		goto link_error;
+
+	/* Init embedded channel only if embedded is set in DT*/
+	s_data = to_camera_common_data(chan->subdev_on_csi->dev);
+	node = chan->subdev_on_csi->dev->of_node;
+	if (s_data && node) {
+		idx = s_data->mode_prop_idx;
+		if (idx < s_data->sensor_props.num_modes)
+			sensor_mode = &s_data->sensor_props.sensor_modes[idx];
+	}
+
+	if (sensor_mode &&
+		sensor_mode->image_properties.embedded_metadata_height > 0) {
+		ret = tegra_channel_init_video_embedded(chan);
+		if (ret < 0) {
+			dev_err(chan->vi->dev,
+					"failed to initialize embedded channel\n");
+			goto register_embedded_device_error;
+		}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0)
+	ret = video_register_device(chan->embedded.video, VFL_TYPE_GRABBER, -1);
+#else
+	ret = video_register_device(chan->embedded.video, VFL_TYPE_VIDEO, -1);
+#endif
+		if (ret < 0) {
+			dev_err(&chan->video->dev, "failed to register embedded %s: %d\n",
+					chan->embedded.video->name, ret);
+			goto register_embedded_device_error;
+		}
+	}
+
 
 	ret = v4l2_device_register_subdev_nodes(&chan->vi->v4l2_dev);
 	if (ret < 0) {
 		dev_err(chan->vi->dev, "failed to register subdev nodes\n");
-		goto graph_error;
+		goto register_nodes_error;
 	}
 
 	chan->link_status++;
 
 	return 0;
 
-graph_error:
+register_nodes_error:
+	video_unregister_device(chan->embedded.video);
+register_embedded_device_error:
+	tegra_vi_graph_remove_links(chan);
+link_error:
 	video_unregister_device(chan->video);
 register_device_error:
 	video_device_release(chan->video);
@@ -482,6 +521,7 @@
 
 	/* cleanup for complete */
 	if (chan->link_status) {
+		tegra_channel_cleanup_video_embedded(chan);
 		tegra_vi_graph_remove_links(chan);
 		tegra_channel_cleanup_video(chan);
 		chan->link_status--;
diff -urN ori/kernel/nvidia/drivers/media/platform/tegra/camera/vi/mc_common.c intel/kernel/nvidia/drivers/media/platform/tegra/camera/vi/mc_common.c
--- ori/kernel/nvidia/drivers/media/platform/tegra/camera/vi/mc_common.c	2022-08-11 11:15:42.000000000 +0800
+++ intel/kernel/nvidia/drivers/media/platform/tegra/camera/vi/mc_common.c	2023-04-10 17:17:16.063081193 +0800
@@ -24,6 +24,10 @@
 #include <media/vi.h>
 #include <media/vi2_registers.h>
 
+#include <media/gmsl-link.h>
+#include <media/max9296.h>
+#include <media/max9295.h>
+
 #include "dev.h"
 #include "host1x/host1x.h"
 
@@ -166,6 +170,11 @@
 	int i;
 	struct tegra_channel *item;
 	struct device_node *node = dev->dev.of_node;
+	struct device_node *dser_node = NULL;
+	struct i2c_client *dser_i2c = NULL;
+	struct device_node *ser_node = NULL;
+	struct i2c_client *ser_i2c = NULL;
+	dev_info(&dev->dev, "%s, parse max9295/max9296\n", __func__);
 
 	err = of_property_read_u32(node, "num-channels", &num_channels);
 	if (err) {
@@ -173,6 +182,29 @@
 			"Failed to find num of channels, set to 0\n");
 		num_channels = 0;
 	}
+
+	vi->dser_dev = NULL;
+	dser_node = of_parse_phandle(node, "nvidia,gmsl-dser-device", 0);
+	if (dser_node) {
+		dser_i2c = of_find_i2c_device_by_node(dser_node);
+		of_node_put(dser_node);
+		if (dser_i2c) {
+			dev_info(&dev->dev, "dser_i2c->addr 0x%x", dser_i2c->addr);
+			vi->dser_dev = &dser_i2c->dev;
+		}
+	}
+
+	vi->ser_dev = NULL;
+	ser_node = of_parse_phandle(node, "nvidia,gmsl-ser-device", 0);
+	if (ser_node) {
+		ser_i2c = of_find_i2c_device_by_node(ser_node);
+		of_node_put(ser_node);
+		if (ser_i2c) {
+			dev_info(&dev->dev, "ser_i2c->addr 0x%x", ser_i2c->addr);
+			vi->ser_dev = &ser_i2c->dev;
+		}
+	}
+
 	vi->num_channels = num_channels;
 	for (i = 0; i < num_channels; i++) {
 		item = devm_kzalloc(vi->dev, sizeof(*item), GFP_KERNEL);
diff -urN ori/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi4_formats.h intel/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi4_formats.h
--- ori/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi4_formats.h	2022-08-11 11:15:42.000000000 +0800
+++ intel/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi4_formats.h	2023-04-10 17:17:16.063081193 +0800
@@ -87,6 +87,9 @@
 	/* RAW 7: TODO */
 
 	/* RAW 8 */
+	TEGRA_VIDEO_FORMAT(RAW8, 8, Y8_1X8, 1, 1, T_L8,
+				RAW8, GREY, "Greyscale 8"),
+
 	TEGRA_VIDEO_FORMAT(RAW8, 8, SRGGB8_1X8, 1, 1, T_L8,
 				RAW8, SRGGB8, "RGRG.. GBGB.."),
 	TEGRA_VIDEO_FORMAT(RAW8, 8, SGRBG8_1X8, 1, 1, T_L8,
@@ -117,22 +120,22 @@
 				RAW12, SBGGR12, "BGBG.. GRGR.."),
 
 	/* RGB888 */
-	TEGRA_VIDEO_FORMAT(RGB888, 24, RGB888_1X24, 4, 1, T_A8R8G8B8,
-				RGB888, ABGR32, "BGRA-8-8-8-8"),
+	// TEGRA_VIDEO_FORMAT(RGB888, 24, RGB888_1X24, 4, 1, T_A8R8G8B8,
+	// 			RGB888, ABGR32, "BGRA-8-8-8-8"),
 	TEGRA_VIDEO_FORMAT(RGB888, 24, RGB888_1X32_PADHI, 4, 1, T_A8B8G8R8,
 				RGB888, RGB32, "RGB-8-8-8-8"),
 
 	/* YUV422 */
-	TEGRA_VIDEO_FORMAT(YUV422, 16, UYVY8_1X16, 2, 1, T_U8_Y8__V8_Y8,
-				YUV422_8, UYVY, "YUV 4:2:2"),
-	TEGRA_VIDEO_FORMAT(YUV422, 16, VYUY8_1X16, 2, 1, T_V8_Y8__U8_Y8,
-				YUV422_8, VYUY, "YUV 4:2:2"),
+	// TEGRA_VIDEO_FORMAT(YUV422, 16, UYVY8_1X16, 2, 1, T_U8_Y8__V8_Y8,
+	// 			YUV422_8, UYVY, "YUV 4:2:2"),
+	// TEGRA_VIDEO_FORMAT(YUV422, 16, VYUY8_1X16, 2, 1, T_V8_Y8__U8_Y8,
+	// 			YUV422_8, VYUY, "YUV 4:2:2"),
 	TEGRA_VIDEO_FORMAT(YUV422, 16, YUYV8_1X16, 2, 1, T_Y8_U8__Y8_V8,
 				YUV422_8, YUYV, "YUV 4:2:2"),
 	TEGRA_VIDEO_FORMAT(YUV422, 16, YVYU8_1X16, 2, 1, T_Y8_V8__Y8_U8,
 				YUV422_8, YVYU, "YUV 4:2:2"),
-	TEGRA_VIDEO_FORMAT(YUV422, 16, UYVY8_1X16, 1, 1, T_Y8__V8U8_N422,
-				YUV422_8, NV16, "NV16"),
+	// TEGRA_VIDEO_FORMAT(YUV422, 16, UYVY8_1X16, 1, 1, T_Y8__V8U8_N422,
+	// 			YUV422_8, NV16, "NV16"),
 	TEGRA_VIDEO_FORMAT(YUV422, 16, UYVY8_2X8, 2, 1, T_U8_Y8__V8_Y8,
 				YUV422_8, UYVY, "YUV 4:2:2 UYVY"),
 	TEGRA_VIDEO_FORMAT(YUV422, 16, VYUY8_2X8, 2, 1, T_V8_Y8__U8_Y8,
@@ -141,6 +144,19 @@
 				YUV422_8, YUYV, "YUV 4:2:2 YUYV"),
 	TEGRA_VIDEO_FORMAT(YUV422, 16, YVYU8_2X8, 2, 1, T_Y8_V8__Y8_U8,
 				YUV422_8, YVYU, "YUV 4:2:2 YVYU"),
+
+	TEGRA_VIDEO_FORMAT(YUV422, 16, UYVY8_1X16, 2, 1, T_U8_Y8__V8_Y8,
+				YUV422_8, Z16, "Depth 16"),
+	TEGRA_VIDEO_FORMAT(YUV422, 16, VYUY8_1X16, 2, 1, T_V8_Y8__U8_Y8,
+				YUV422_8, Y8I, "Y8I 16"),
+	// TODO: RealSesne calibration format Y12I should be 3-byte,
+	// R[7:3]R[3:0] | L[3:0]R[11:8] | L[11:8]L[7:4]
+	// but, currently, it's 4-byte, one byte is added as alignment
+	// R[7:3]R[3:0] | L[3:0]R[11:8] | L[11:8]L[7:4] | ALIGN[7:0]
+	TEGRA_VIDEO_FORMAT(RGB888, 24, RGB888_1X24, 4, 1, T_A8R8G8B8,
+				RGB888, Y12I, "Y12I 24"),
+
+
 };
 
 #endif
diff -urN ori/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi5_fops.c intel/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi5_fops.c
--- ori/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi5_fops.c	2022-08-11 11:15:42.000000000 +0800
+++ intel/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi5_fops.c	2023-04-10 17:17:16.063081193 +0800
@@ -270,7 +270,7 @@
 
 	setup.queue_depth = chan->capture_queue_depth;
 
-	trace_tegra_channel_capture_setup(chan, 0);
+	trace_tegra_channel_capture_setup(chan, vi_port);
 
 	chan->request[vi_port] = dma_alloc_coherent(chan->tegra_vi_channel[vi_port]->rtcpu_dev,
 					setup.queue_depth * setup.request_size,
@@ -375,12 +375,45 @@
 	struct tegra_channel_buffer *buf)
 {
 	struct vb2_v4l2_buffer *vbuf = &buf->buf;
+	struct vb2_buffer *evb;
+	struct vb2_v4l2_buffer *evbuf;
 
 	vbuf->sequence = chan->sequence++;
 	vbuf->field = V4L2_FIELD_NONE;
 	vb2_set_plane_payload(&vbuf->vb2_buf, 0, chan->format.sizeimage);
 
+	evb = NULL;
+	if ((chan->embedded_data_height == 1)) {
+		void* frm_buffer;
+		spin_lock(&chan->embedded.spin_lock);
+		if (0 < chan->embedded.num_buffers ){
+			evb = chan->embedded.buffers[chan->embedded.tail];
+			chan->embedded.buffers[chan->embedded.tail] = NULL;
+			chan->embedded.tail++;
+			if (chan->embedded.tail > 15)
+					chan->embedded.tail = chan->embedded.tail - 16;
+			chan->embedded.num_buffers--;
+		}
+		spin_unlock(&chan->embedded.spin_lock);
+
+		if(evb) {
+			frm_buffer = vb2_plane_vaddr(evb, 0);
+			if (frm_buffer != NULL) {
+				memcpy(frm_buffer,chan->emb_buf_addr, 255);
+			}
+		}
+	}
+
 	vb2_buffer_done(&vbuf->vb2_buf, buf->vb2_state);
+	if (chan->embedded_data_height == 1 && evb) {
+		evbuf = to_vb2_v4l2_buffer(evb);
+		evbuf->sequence = vbuf->sequence;
+		/*FIXME: define 236 68 bytes metadata*/
+		vb2_set_plane_payload(evb, 0, 68);
+		evb->timestamp = vbuf->vb2_buf.timestamp;
+		vb2_buffer_done(evb, buf->vb2_state);
+	}
+
 }
 
 static void vi5_capture_enqueue(struct tegra_channel *chan,
@@ -432,6 +465,88 @@
 	spin_unlock_irqrestore(&chan->capture_state_lock, flags);
 }
 
+static int vi5_channel_error_recover_internal(struct tegra_channel *chan)
+{
+	int err = 0;
+	int vi_port = 0;
+	struct tegra_channel_buffer *buf;
+	struct v4l2_subdev *csi_subdev;
+	dev_dbg(chan->vi->dev, "%s() vc: %d\n", __func__, chan->virtual_channel);
+
+	/* stop vi channel */
+	for(vi_port = 0; vi_port < chan->valid_ports; vi_port++) {
+		err = vi_capture_release(chan->tegra_vi_channel[vi_port],
+			CAPTURE_CHANNEL_RESET_FLAG_IMMEDIATE);
+		if (err) {
+			dev_err(&chan->video->dev, "vi capture release failed\n");
+			goto done;
+		}
+		vi_channel_close_ex(chan->id, chan->tegra_vi_channel[vi_port]);
+		chan->tegra_vi_channel[vi_port] = NULL;
+	}
+
+	if (!list_empty(&chan->release)){
+			dev_warn(chan->vi->dev, "CHAN-RELEASE not EMPTY\n");
+	}
+	/* release all previously-enqueued capture buffers to temporary list */
+	while (!list_empty(&chan->capture)) {
+		buf = dequeue_buffer(chan, false);
+		if (!buf)
+			break;
+		spin_lock(&chan->release_lock);
+		list_add_tail(&buf->queue, &chan->release);
+		spin_unlock(&chan->release_lock);
+	}
+	while (!list_empty(&chan->dequeue)) {
+		buf = dequeue_dequeue_buffer(chan);
+		if (!buf)
+			break;
+		spin_lock(&chan->release_lock);
+		list_add_tail(&buf->queue, &chan->release);
+		spin_unlock(&chan->release_lock);
+	}
+
+	/* reset nvcsi stream */
+	csi_subdev = tegra_channel_find_linked_csi_subdev(chan);
+	if (!csi_subdev) {
+		dev_err(chan->vi->dev, "unable to find linked csi subdev\n");
+		err = -1;
+		goto done;
+	}
+
+	v4l2_subdev_call(csi_subdev, core, sync,
+		V4L2_SYNC_EVENT_SUBDEV_ERROR_RECOVER);
+
+	/* restart vi channel */
+	for(vi_port = 0; vi_port < chan->valid_ports; vi_port++) {
+		chan->tegra_vi_channel[vi_port] = vi_channel_open_ex(chan->id + vi_port, false);
+		if (IS_ERR(chan->tegra_vi_channel[vi_port])) {
+			err = PTR_ERR(chan);
+			goto done;
+		}
+		err = tegra_channel_capture_setup(chan, vi_port);
+		if (err < 0)
+			goto done;
+	}
+
+	chan->sequence = 0;
+	tegra_channel_init_ring_buffer(chan);
+	chan->capture_reqs_enqueued = 0;
+
+	chan->capture_state = CAPTURE_IDLE;
+
+	while (!list_empty(&chan->release)) {
+		buf = list_entry(chan->release.next, struct tegra_channel_buffer,
+			queue);
+		list_del_init(&buf->queue);
+		buf->vb2_state = VB2_BUF_STATE_ACTIVE;
+		vi5_capture_enqueue(chan, buf);
+	}
+
+done:
+	return err;
+}
+
 static void vi5_capture_dequeue(struct tegra_channel *chan,
 	struct tegra_channel_buffer *buf)
 {
@@ -476,15 +591,29 @@
 			} else {
 				dev_warn(vi->dev,
 					"corr_err: discarding frame %d, flags: %d, "
-					"err_data %d\n",
+					"err_data %d, vc: %d\n",
 					descr->status.frame_id, descr->status.flags,
-					descr->status.err_data);
+					descr->status.err_data, chan->virtual_channel);
 #if LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0)
 					buf->vb2_state = VB2_BUF_STATE_REQUEUEING;
 #else
 					buf->vb2_state = VB2_BUF_STATE_ERROR;
 #endif
-			goto done;
+				/* D457: err_data 131072 (20000h) & 512 (200h) leading to channel
+				* timeout. This happens when first frame is corrupted - no md
+				* and less lines than requested. Channel reset time is 6ms */
+				if (descr->status.err_data & 0x20200) {
+					spin_lock_irqsave(&chan->capture_state_lock, flags);
+					chan->capture_state = CAPTURE_ERROR;
+					spin_unlock_irqrestore(&chan->capture_state_lock, flags);
+					buf->vb2_state = VB2_BUF_STATE_ERROR;
+					vi5_channel_error_recover_internal(chan);
+				}
+				/* REQUEUE */
+				buf->vb2_state = VB2_BUF_STATE_ACTIVE;
+				vi5_capture_enqueue(chan, buf);
+
+				return;
 			}
 		} else if (!vi_port) {
 			gang_prev_frame_id = descr->status.frame_id;
@@ -529,7 +658,6 @@
 	trace_tegra_channel_capture_frame("eof", &ts);
 #endif
 
-done:
 	goto rel_buf;
 
 uncorr_err:
@@ -632,6 +760,9 @@
 		wait_event_interruptible(chan->start_wait,
 			(kthread_should_stop() || !list_empty(&chan->capture)));
 
+		dev_dbg(chan->vi->dev, "reqs:%d depth:%d\n",
+				chan->capture_reqs_enqueued, chan->capture_queue_depth);
+
 		while (!(kthread_should_stop() || list_empty(&chan->capture))) {
 			spin_lock_irqsave(&chan->capture_state_lock, flags);
 			if ((chan->capture_state == CAPTURE_ERROR)
@@ -823,6 +954,8 @@
 							sensor_mode->\
 							 image_properties.\
 						      embedded_metadata_height;
+						if (chan->id != 0 && chan->id != 1)
+							chan->embedded_data_height = 0;
 						/* rounding up to page size */
 						emb_buf_size =
 							round_up(chan->\
diff -urN ori/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi5_formats.h intel/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi5_formats.h
--- ori/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi5_formats.h	2022-08-11 11:15:42.000000000 +0800
+++ intel/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi5_formats.h	2023-04-10 17:17:16.063081193 +0800
@@ -87,6 +87,8 @@
 	/* RAW 7: TODO */
 
 	/* RAW 8 */
+	TEGRA_VIDEO_FORMAT(RAW8, 8, Y8_1X8, 1, 1, T_R8,
+				RAW8, GREY, "Greyscale 8"),
 	TEGRA_VIDEO_FORMAT(RAW8, 8, SRGGB8_1X8, 1, 1, T_R8,
 				RAW8, SRGGB8, "RGRG.. GBGB.."),
 	TEGRA_VIDEO_FORMAT(RAW8, 8, SGRBG8_1X8, 1, 1, T_R8,
@@ -117,22 +119,22 @@
 				RAW12, SBGGR12, "BGBG.. GRGR.."),
 
 	/* RGB888 */
-	TEGRA_VIDEO_FORMAT(RGB888, 24, RGB888_1X24, 4, 1, T_A8R8G8B8,
-				RGB888, ABGR32, "BGRA-8-8-8-8"),
+	// TEGRA_VIDEO_FORMAT(RGB888, 24, RGB888_1X24, 4, 1, T_A8R8G8B8,
+	// 			RGB888, ABGR32, "BGRA-8-8-8-8"),
 	TEGRA_VIDEO_FORMAT(RGB888, 24, RGB888_1X32_PADHI, 4, 1, T_A8B8G8R8,
 				RGB888, RGB32, "RGB-8-8-8-8"),
 
 	/* YUV422 */
-	TEGRA_VIDEO_FORMAT(YUV422, 16, UYVY8_1X16, 2, 1, T_U8_Y8__V8_Y8,
-				YUV422_8, UYVY, "YUV 4:2:2"),
-	TEGRA_VIDEO_FORMAT(YUV422, 16, VYUY8_1X16, 2, 1, T_V8_Y8__U8_Y8,
-				YUV422_8, VYUY, "YUV 4:2:2"),
+	// TEGRA_VIDEO_FORMAT(YUV422, 16, UYVY8_1X16, 2, 1, T_U8_Y8__V8_Y8,
+	// 			YUV422_8, UYVY, "YUV 4:2:2"),
+	// TEGRA_VIDEO_FORMAT(YUV422, 16, VYUY8_1X16, 2, 1, T_V8_Y8__U8_Y8,
+	// 			YUV422_8, VYUY, "YUV 4:2:2"),
 	TEGRA_VIDEO_FORMAT(YUV422, 16, YUYV8_1X16, 2, 1, T_Y8_U8__Y8_V8,
 				YUV422_8, YUYV, "YUV 4:2:2"),
 	TEGRA_VIDEO_FORMAT(YUV422, 16, YVYU8_1X16, 2, 1, T_Y8_V8__Y8_U8,
 				YUV422_8, YVYU, "YUV 4:2:2"),
-	TEGRA_VIDEO_FORMAT(YUV422, 16, UYVY8_1X16, 1, 1, T_Y8__V8U8_N422,
-				YUV422_8, NV16, "NV16"),
+	// TEGRA_VIDEO_FORMAT(YUV422, 16, UYVY8_1X16, 1, 1, T_Y8__V8U8_N422,
+	// 			YUV422_8, NV16, "NV16"),
 	TEGRA_VIDEO_FORMAT(YUV422, 16, UYVY8_2X8, 2, 1, T_U8_Y8__V8_Y8,
 				YUV422_8, UYVY, "YUV 4:2:2 UYVY"),
 	TEGRA_VIDEO_FORMAT(YUV422, 16, VYUY8_2X8, 2, 1, T_V8_Y8__U8_Y8,
@@ -141,6 +143,18 @@
 				YUV422_8, YUYV, "YUV 4:2:2 YUYV"),
 	TEGRA_VIDEO_FORMAT(YUV422, 16, YVYU8_2X8, 2, 1, T_Y8_V8__Y8_U8,
 				YUV422_8, YVYU, "YUV 4:2:2 YVYU"),
+
+	TEGRA_VIDEO_FORMAT(YUV422, 16, UYVY8_1X16, 2, 1, T_U8_Y8__V8_Y8,
+				YUV422_8, Z16, "Depth 16"),
+	TEGRA_VIDEO_FORMAT(YUV422, 16, VYUY8_1X16, 2, 1, T_V8_Y8__U8_Y8,
+				YUV422_8, Y8I, "Y8I 16"),
+	// TODO: RealSesne calibration format Y12I should be 3-byte,
+	// R[7:3]R[3:0] | L[3:0]R[11:8] | L[11:8]L[7:4]
+	// but, currently, it's 4-byte, one byte is added as alignment
+	// R[7:3]R[3:0] | L[3:0]R[11:8] | L[11:8]L[7:4] | ALIGN[7:0]
+	TEGRA_VIDEO_FORMAT(RGB888, 24, RGB888_1X24, 4, 1, T_A8R8G8B8,
+				RGB888, Y12I, "Y12I 24"),
+
 };
 
 #endif
diff -urN ori/kernel/nvidia/drivers/video/tegra/camera/tegra_camera_platform.c intel/kernel/nvidia/drivers/video/tegra/camera/tegra_camera_platform.c
--- ori/kernel/nvidia/drivers/video/tegra/camera/tegra_camera_platform.c	2022-08-11 11:15:42.000000000 +0800
+++ intel/kernel/nvidia/drivers/video/tegra/camera/tegra_camera_platform.c	2023-04-10 17:17:16.063081193 +0800
@@ -1153,6 +1153,11 @@
 	struct tegra_camera_info *info;
 	int ret = 0;
 
+	/* TODO: workarouud for Xavier */
+	if (NULL == tegra_camera_misc.parent) {
+		return 0;
+    }
+
 	info = dev_get_drvdata(tegra_camera_misc.parent);
 	if (!info)
 		return -EINVAL;
diff -urN ori/kernel/nvidia/include/media/gmsl-link.h intel/kernel/nvidia/include/media/gmsl-link.h
--- ori/kernel/nvidia/include/media/gmsl-link.h	2022-08-11 11:15:42.000000000 +0800
+++ intel/kernel/nvidia/include/media/gmsl-link.h	2023-04-10 17:17:16.063081193 +0800
@@ -56,6 +56,13 @@
 
 #define GMSL_ST_ID_UNUSED 0xFF
 
+enum sensor_type {
+	DEPTH_SENSOR,
+	RGB_SENSOR,
+	IR_SENSOR,
+	IMU_SENSOR,
+};
+
 /**
  * Maximum number of data streams (\ref gmsl_stream elements) in a GMSL link
  * (\ref gmsl_link_ctx).
diff -urN ori/kernel/nvidia/include/media/max9295.h intel/kernel/nvidia/include/media/max9295.h
--- ori/kernel/nvidia/include/media/max9295.h	2022-08-11 11:15:42.000000000 +0800
+++ intel/kernel/nvidia/include/media/max9295.h	2023-04-10 17:17:16.063081193 +0800
@@ -25,6 +25,7 @@
 #ifndef __MAX9295_H__
 #define __MAX9295_H__
 
+#include <linux/types.h>
 #include <media/gmsl-link.h>
 /**
  * \defgroup max9295 MAX9295 serializer driver
@@ -35,6 +36,7 @@
  * @{
  */
 
+int max9295_update_pipe(struct device *dev, int sensor_type, u32 fourcc);
 
 /**
  * @brief  Powers on a serializer device and performs the I2C overrides
diff -urN ori/kernel/nvidia/include/media/max9296.h intel/kernel/nvidia/include/media/max9296.h
--- ori/kernel/nvidia/include/media/max9296.h	2022-08-11 11:15:42.000000000 +0800
+++ intel/kernel/nvidia/include/media/max9296.h	2023-04-10 17:17:16.063081193 +0800
@@ -25,6 +25,7 @@
 #ifndef __MAX9296_H__
 #define __MAX9296_H__
 
+#include <linux/types.h>
 #include <media/gmsl-link.h>
 /**
  * \defgroup max9296 MAX9296 deserializer driver
@@ -35,6 +36,8 @@
  * @{
  */
 
+int max9296_update_pipe(struct device *dev, int sensor_type, u32 fourcc);
+
 /**
  * Puts a deserializer device in single exclusive link mode, so link-specific
  * I2C overrides can be performed for sensor and serializer devices.
diff -urN ori/kernel/nvidia/include/media/mc_common.h intel/kernel/nvidia/include/media/mc_common.h
--- ori/kernel/nvidia/include/media/mc_common.h	2022-08-11 11:15:42.000000000 +0800
+++ intel/kernel/nvidia/include/media/mc_common.h	2023-04-10 17:17:16.063081193 +0800
@@ -42,6 +42,7 @@
 #define	ENABLE		1
 #define	DISABLE		0
 #define MAX_SYNCPT_PER_CHANNEL	3
+#define MAX_CHANNELS 6
 
 #define CAPTURE_MIN_BUFFERS	1U
 #define CAPTURE_MAX_BUFFERS	240U
@@ -227,9 +228,27 @@
 	unsigned int gang_height;
 	unsigned int gang_bytesperline;
 	unsigned int gang_sizeimage;
+
 	unsigned int embedded_data_width;
 	unsigned int embedded_data_height;
 
+	struct {
+		struct video_device *video;
+		struct mutex lock;
+		spinlock_t spin_lock;
+		struct vb2_queue queue;
+		/*FIXME: 16 is max queued metadata buffers
+		* define 16
+		*/
+		struct vb2_buffer *buffers[16];
+		unsigned int head;
+		unsigned int tail;
+		unsigned int num_buffers;
+		void *alloc_ctx;
+		struct media_pad pad;
+		struct v4l2_ctrl_handler ctrl_handler;
+	} embedded;
+
 	DECLARE_BITMAP(fmts_bitmap, MAX_FORMAT_NUM);
 	atomic_t power_on_refcnt;
 	struct v4l2_fh *fh;
@@ -308,6 +327,9 @@
 	unsigned int num_channels;
 	unsigned int num_subdevs;
 
+	struct device *dser_dev;
+	struct device *ser_dev;
+
 	struct tegra_csi_device *csi;
 	struct list_head vi_chans;
 	struct tegra_channel *tpg_start;
@@ -412,7 +434,10 @@
 int tegra_channel_set_power(struct tegra_channel *chan, bool on);
 
 int tegra_channel_init_video(struct tegra_channel *chan);
+int tegra_channel_init_video_embedded(struct tegra_channel *chan);
 int tegra_channel_cleanup_video(struct tegra_channel *chan);
+int tegra_channel_cleanup_video_embedded(struct tegra_channel *chan);
+
 
 struct tegra_vi_fops {
 	int (*vi_power_on)(struct tegra_channel *chan);
diff -urN ori/kernel/nvidia/include/media/tegra_camera_core.h intel/kernel/nvidia/include/media/tegra_camera_core.h
--- ori/kernel/nvidia/include/media/tegra_camera_core.h	2022-08-11 11:15:42.000000000 +0800
+++ intel/kernel/nvidia/include/media/tegra_camera_core.h	2023-04-10 17:17:16.063081193 +0800
@@ -23,7 +23,7 @@
 /* Width alignment */
 #define TEGRA_WIDTH_ALIGNMENT	1
 /* Stride alignment */
-#define TEGRA_STRIDE_ALIGNMENT	1
+#define TEGRA_STRIDE_ALIGNMENT	64
 /* Height alignment */
 #define TEGRA_HEIGHT_ALIGNMENT	1
 /* Size alignment */
@@ -37,6 +37,8 @@
 #define TEGRA_IMAGE_FORMAT_DEF	32
 
 enum tegra_image_dt {
+	TEGRA_IMAGE_DT_EMBEDDED_8 = 18,
+
 	TEGRA_IMAGE_DT_YUV420_8 = 24,
 	TEGRA_IMAGE_DT_YUV420_10,
 
@@ -56,6 +58,12 @@
 	TEGRA_IMAGE_DT_RAW10,
 	TEGRA_IMAGE_DT_RAW12,
 	TEGRA_IMAGE_DT_RAW14,
+
+	TEGRA_IMAGE_DT_USER_1 = 48,
+	TEGRA_IMAGE_DT_USER_2,
+	TEGRA_IMAGE_DT_USER_3,
+	TEGRA_IMAGE_DT_USER_4,
+
 };
 
 /* Supported CSI to VI Data Formats */
